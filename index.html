
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="ÏûéÏΩî, ÏÑúÎ∞îÏù¥Î≤å, ÏûéÏΩî ÏÑúÎ∞îÏù¥Î≤å, ÏûéÏΩî ÏÑúÎ∞îÏù¥Î≤Ñ, ifko, ifko survivor">
    <meta name="description" content="IFKO SURVIVOR - ÏûéÏΩîÏôÄ Ìï®ÍªòÌïòÎäî Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ ÏÑúÎ∞îÏù¥Î≤å Í≤åÏûÑ. Îã§ÏñëÌïú Î¨¥Í∏∞ÏôÄ Ïä§ÌÇ¨Î°ú Ï†ÅÎì§ÏùÑ Î¨ºÎ¶¨ÏπòÍ≥† ÏÉùÏ°¥ÌïòÏÑ∏Ïöî!">
    <meta name="author" content="IFKO">
    <meta property="og:title" content="IFKO SURVIVOR">
    <meta property="og:description" content="ÏûéÏΩî ÏÑúÎ∞îÏù¥Î≤å - Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ ÏäàÌåÖ Ïï°ÏÖò">
    <meta property="og:type" content="website">
    <title>IFKO SURVIVOR</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåå</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Exo+2:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ffcc;
            --primary-dark: #00cc99;
            --accent: #ff0099;
            --accent-dark: #cc0077;
            --gold: #ffd700;
            --void: #9d00ff;
            --bg: #050508;
            --glass: rgba(20, 20, 30, 0.9);
            --border: rgba(255, 255, 255, 0.15);
            --font: 'Noto Sans KR', 'Exo 2', sans-serif;
        }

        body.void-mode {
            --primary: #bc13fe;
            --primary-dark: #8a0bbd;
            --bg: #1a0524;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        body {
            margin: 0; padding: 0; background-color: #000; color: white;
            font-family: var(--font); overflow: hidden;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            background: var(--bg); overflow: hidden; transition: background 0.5s;
        }

        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

        /* Effects */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 15; opacity: 0.3;
        }
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 16;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; z-index: 20;
        }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }

        /* HUD */
        #hud { padding: 15px; justify-content: space-between; height: 100%; z-index: 30; }
        .top-row { 
            display: flex; flex-direction: column; align-items: center; width: 100%; pointer-events: none; 
        }
        
        .stat-box {
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid var(--border); backdrop-filter: blur(4px);
            display: flex; align-items: center; gap: 15px;
            pointer-events: auto;
        }
        .stat-text { font-size: 0.9rem; font-weight: 700; display: flex; gap: 10px; align-items: center; }
        
        .bar-container {
            background: rgba(0,0,0,0.5); border-radius: 5px;
            overflow: hidden; position: relative;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .bar-fill { height: 100%; transition: width 0.2s ease-out; border-radius: 5px; }
        #hp-bar { background: linear-gradient(90deg, #ff3333, #ff6666); width: 100%; box-shadow: 0 0 8px rgba(255,51,51,0.5); }
        #xp-bar { background: linear-gradient(90deg, #00ccff, #33ffff); width: 0%; box-shadow: 0 0 8px rgba(51,255,255,0.5); }

        #timer {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 1.8rem; font-weight: 900; color: #fff;
            text-shadow: 0 0 15px rgba(0,0,0,0.8); letter-spacing: 2px; font-family: 'Exo 2';
        }

        #pause-btn {
            width: 45px; height: 45px; background: var(--glass);
            border: 1px solid var(--border); border-radius: 12px;
            color: white; font-size: 1.2rem; display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #pause-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.1); }

        /* Ultimate Button */
        #ult-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            background: radial-gradient(circle, #ff0099, #550033);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 0 20px rgba(255,0,153,0.6);
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #ult-btn:active { transform: scale(0.9); }
        #ult-btn.disabled { filter: grayscale(1) brightness(0.4); box-shadow: none; border-color: #333; cursor: not-allowed; }
        #ult-icon { font-size: 2rem; }
        #ult-label { font-size: 0.7rem; font-weight: bold; margin-top: -2px; }

        /* Boss HUD */
        #boss-hud {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 500px; opacity: 0; transition: opacity 0.5s;
            display: flex; flex-direction: column; align-items: center;
        }
        #boss-hud.active { opacity: 1; }
        #boss-name { color: #bc13fe; font-weight: 900; font-size: 1rem; margin-bottom: 5px; letter-spacing: 3px; text-shadow: 0 0 10px #bc13fe; }
        #boss-hp-container { width: 100%; height: 20px; background: rgba(0,0,0,0.8); border: 2px solid #4a0b63; border-radius: 4px; overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #9d00ff, #bc13fe); box-shadow: 0 0 10px #9d00ff; }

        /* Event HUD */
        #event-hud {
            position: absolute; top: 150px; width: 100%; text-align: center;
            font-size: 1.5rem; font-weight: 900; color: #ffd700;
            text-shadow: 0 0 10px #ff3300; display: none; z-index: 35;
            animation: pulse 1s infinite;
        }

        /* Common Menu Styles */
        .menu-screen {
            background: rgba(8, 8, 12, 0.98);
            justify-content: center; align-items: center; text-align: center;
            backdrop-filter: blur(10px); z-index: 50;
        }
        
        .screen-title {
            font-size: 2.5rem; margin: 0 0 5px 0;
            background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; color: transparent;
            font-family: 'Exo 2'; font-style: italic; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        .screen-subtitle { color: #888; margin-bottom: 25px; font-size: 0.9rem; letter-spacing: 1px; }

        /* Buttons */
        .btn {
            padding: 12px 24px; font-size: 1rem;
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            border: none; border-radius: 8px;
            color: #000; font-family: var(--font); font-weight: 900;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            position: relative; overflow: hidden;
            min-width: 140px;
        }
        .btn::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent); pointer-events: none;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 255, 204, 0.5); filter: brightness(1.1); }
        .btn:active { transform: translateY(1px); box-shadow: 0 2px 10px rgba(0, 255, 204, 0.3); }

        .btn-secondary {
            background: linear-gradient(135deg, #333, #444); color: #ccc;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn-secondary:hover { box-shadow: 0 6px 15px rgba(0,0,0,0.7); color: #fff; }
        
        .btn-danger {
            background: linear-gradient(135deg, #990033, #ff3333); color: white;
            box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent-dark), var(--accent)); color: white;
            box-shadow: 0 4px 15px rgba(255, 0, 153, 0.3);
        }
        .btn-accent:hover { box-shadow: 0 6px 20px rgba(255, 0, 153, 0.5); }

        .btn-small { padding: 5px 10px; font-size: 0.8rem; min-width: auto; }

        /* Menu Grid */
        .menu-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;
            max-width: 500px; width: 100%; margin-bottom: 20px;
        }
        .menu-grid .btn { width: 100%; padding: 10px; font-size: 0.9rem; }

        /* Upgrade Cards */
        .card-container {
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
            padding: 20px; max-height: 70vh; overflow-y: auto; width: 100%;
            touch-action: pan-y;
        }
        /* Custom scrollbar for webkit */
        .card-container::-webkit-scrollbar, .list-layout::-webkit-scrollbar { width: 8px; }
        .card-container::-webkit-scrollbar-track, .list-layout::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        .card-container::-webkit-scrollbar-thumb, .list-layout::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        
        .card {
            width: 160px; min-height: 250px;
            background: linear-gradient(160deg, rgba(25,25,35,0.9), rgba(10,10,15,0.95));
            border: 1px solid var(--border); border-radius: 12px;
            padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--primary); box-shadow: 0 10px 25px rgba(0, 255, 204, 0.2); }
        .card:active { transform: scale(0.98); }
        
        .card-icon { font-size: 3rem; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.1)); }
        .card-title { font-size: 1.1rem; font-weight: 700; color: var(--primary); margin-bottom: 8px; line-height: 1.2; }
        .card-desc { font-size: 0.8rem; color: #aaa; line-height: 1.4; margin-bottom: 10px; flex-grow: 1; }
        .card-type { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; width: 100%; }
        
        .card.evolution { border-color: var(--accent); background: linear-gradient(160deg, #2a0a1a, #1a050d); animation: pulse 2s infinite; }
        .card.evolution .card-title { color: var(--accent); }
        .card.evolution:hover { box-shadow: 0 10px 30px rgba(255, 0, 153, 0.5); }

        .card.hidden-tier { border-color: var(--void); background: linear-gradient(160deg, #120024, #05000a); }
        .card.hidden-tier .card-title { color: var(--void); text-shadow: 0 0 5px var(--void); }

        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } 50% { box-shadow: 0 0 25px rgba(255,0,153,0.6); } 100% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } }

        .card.locked { opacity: 0.7; filter: grayscale(1); border-style: dashed; }

        /* Lists */
        .list-layout {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px; width: 100%; max-width: 900px; padding: 10px;
            max-height: 65vh; overflow-y: auto; touch-action: pan-y;
        }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid var(--border);
            border-radius: 10px; padding: 12px; display: flex; flex-direction: column; align-items: center;
            transition: 0.2s; position: relative;
        }
        .shop-item:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.3); }
        .shop-item h3 { margin: 5px 0; color: #fff; font-size: 0.95rem; }
        .shop-item p { margin: 0 0 10px 0; color: #888; font-size: 0.8rem; text-align: center; line-height: 1.3; }
        
        .currency-display {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.3rem; color: var(--gold); font-weight: 900;
            display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.6);
            padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,215,0,0.3);
            z-index: 100;
        }

        /* Skin Grid */
        .skin-grid { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 700px; overflow-y: auto; max-height: 60vh; }
        .skin-item {
            width: 100px; height: 140px; border: 2px solid #444; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; background: rgba(20,20,20,0.8); position: relative;
        }
        .skin-item.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(0,255,204,0.3); background: rgba(0,255,204,0.05); }
        .skin-item.locked { opacity: 0.6; border-color: #222; cursor: not-allowed; }
        .skin-preview { font-size: 3rem; margin-bottom: 10px; }
        .skin-name { font-size: 0.85rem; color: #ddd; font-weight: bold; }
        .lock-icon { position: absolute; top: 8px; right: 8px; font-size: 1rem; color: #777; }

        /* Gacha */
        #gacha-result {
            width: 300px; padding: 30px; border: 1px solid var(--gold);
            background: radial-gradient(circle at center, #222, #050505);
            border-radius: 20px; display: none; flex-direction: column; align-items: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2); animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .gacha-icon { font-size: 6rem; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(255,255,255,0.5)); }

        /* Joystick */
        #joystick-zone { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        #joystick-base {
            position: absolute; width: 120px; height: 120px;
            border: 2px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #joystick-knob {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(255,255,255,0.5);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #dash-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.8rem; pointer-events: none; letter-spacing: 1px;
            text-shadow: 0 1px 2px #000;
        }
        #scroll-hint {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 0.7rem; pointer-events: none; letter-spacing: 1px;
        }
        #zoom-indicator {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 10px;
            font-size: 0.8rem; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        /* Class & Ultimate Selection */
        .class-badge { font-size: 0.7rem; background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; margin-top: 5px; }
        .selected-check { position: absolute; top: 10px; right: 10px; color: var(--primary); font-size: 1.2rem; display: none; }
        .shop-item.selected { border-color: var(--primary); background: rgba(0, 255, 204, 0.05); }
        .shop-item.selected .selected-check { display: block; }
        
        .ult-card {
            width: 100%; border: 1px solid #444; border-radius: 10px; background: rgba(0,0,0,0.5);
            padding: 15px; margin-bottom: 10px; cursor: pointer; display:flex; align-items:center; gap: 15px; transition: 0.2s;
        }
        .ult-card:hover { border-color: #666; background: rgba(255,255,255,0.05); }
        .ult-card.selected { border-color: var(--accent); background: rgba(255,0,153,0.1); }
        .ult-icon-l { font-size: 2.5rem; }

        /* Achievement Item */
        .achieve-item {
            background: rgba(0,0,0,0.5); border: 1px solid #444; border-radius: 8px;
            padding: 10px; display: flex; align-items: center; justify-content: space-between;
            width: 100%; opacity: 0.6;
        }
        .achieve-item.completed { border-color: var(--gold); background: rgba(255,215,0,0.1); opacity: 1; }
        .achieve-info { text-align: left; }
        .achieve-title { font-weight: bold; font-size: 0.9rem; color: #fff; }
        .achieve-desc { font-size: 0.75rem; color: #aaa; }
        .achieve-reward { font-weight: bold; color: var(--gold); font-size: 0.8rem; }
        .btn-claim { padding: 5px 10px; font-size: 0.7rem; min-width: auto; background: var(--gold); color: #000; }
        .btn-claim:disabled { background: #555; color: #888; cursor: default; box-shadow: none; transform: none; }

        /* Reroll/Skip UI */
        .meta-btn-row {
            display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;
        }
        .meta-btn {
            background: #222; border: 1px solid #555; color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 5px;
        }
        .meta-btn:hover { background: #333; }
        .meta-btn span { font-weight: bold; color: var(--gold); }
        .meta-btn:disabled { opacity: 0.5; cursor: default; }

        /* Void Mode Toggle */
        .mode-toggle {
            display: flex; align-items: center; gap: 10px; margin-bottom: 20px; cursor: pointer;
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid var(--border);
            justify-content: center;
        }
        .mode-toggle.active { border-color: var(--void); background: rgba(157, 0, 255, 0.1); }
        .mode-checkbox { width: 20px; height: 20px; accent-color: var(--void); }

        /* Weapon Select */
        #weapon-screen .card { width: 140px; min-height: 200px; }
        #weapon-screen .card-title { font-size: 1rem; }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <canvas id="gameCanvas"></canvas>

        <!-- Joystick UI -->
        <div id="joystick-zone" class="interactive"></div>
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
        <div id="dash-hint">SPACE / DOUBLE TAP : DASH</div>
        <div id="scroll-hint">MOUSE WHEEL : ZOOM</div>
        <div id="zoom-indicator">x1.0</div>

        <!-- HUD -->
        <div id="hud" class="ui-layer hidden">
            <div class="top-row">
                <!-- Stats and Controls -->
                <div style="display:flex; width:100%; justify-content:space-between; align-items: flex-start; margin-bottom: 5px;">
                    <div class="stat-box" style="width: fit-content;">
                        <div class="stat-text"><span style="color:var(--primary)">LV.<span id="level-display">1</span></span></div>
                        <div class="stat-text"><span style="color:#ccc">üíÄ <span id="kill-display">0</span></span></div>
                        <div class="stat-text"><span style="color:var(--gold)">ü™ô <span id="coin-display">0</span></span></div>
                    </div>
                    <div id="pause-btn" onclick="togglePause()">‚ùö‚ùö</div>
                </div>
                
                <!-- XP Bar -->
                <div class="bar-container" style="width: 100%; max-width: 600px; height: 8px; margin-bottom: 5px;">
                    <div id="xp-bar" class="bar-fill"></div>
                </div>

                <!-- HP Bar -->
                <div class="bar-container" style="width: 300px; height: 24px; border: 2px solid rgba(255,50,50,0.6); background: rgba(0,0,0,0.8);">
                    <div id="hp-bar" class="bar-fill"></div>
                    <div id="hp-text" style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; justify-content:center; align-items:center; font-size:0.8rem; font-weight:bold; text-shadow:0 1px 2px #000;">100 / 100</div>
                </div>
            </div>
            
            <div id="timer">00:00</div>
            <div id="event-hud">METEOR SHOWER</div>

            <div id="boss-hud">
                <div id="boss-name">‚ö†Ô∏è THE HEXAGON ‚ö†Ô∏è</div>
                <div id="boss-hp-container"><div id="boss-hp-fill"></div></div>
            </div>

            <div id="ult-btn" class="interactive disabled" onclick="useUltimate()">
                <div id="ult-icon">üí£Ô∏è</div>
                <div id="ult-label">ULTIMATE</div>
            </div>
        </div>

        <!-- Upgrade Screen -->
        <div id="upgrade-screen" class="ui-layer hidden interactive menu-screen">
            <h2 class="screen-title" style="font-size:2rem;">SYSTEM UPGRADE</h2>
            <div class="meta-btn-row">
                <button class="meta-btn" id="btn-reroll" onclick="doReroll()">üîÑ Reroll <span id="cnt-reroll">0</span></button>
                <button class="meta-btn" id="btn-skip" onclick="doSkip()">‚è≠Ô∏è Skip <span id="cnt-skip">0</span></button>
                <button class="meta-btn" id="btn-banish" onclick="toggleBanishMode()">üö´ Banish <span id="cnt-banish">0</span></button>
            </div>
            <p class="screen-subtitle" id="upgrade-subtitle">Í∞ïÌôî Î™®ÎìàÏùÑ ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§</p>
            <div class="card-container" id="upgrade-cards"></div>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="ui-layer hidden interactive menu-screen" style="display:flex; flex-direction:column;">
            <h1 class="screen-title">PAUSED</h1>
            <p class="screen-subtitle">ÏûëÏ†Ñ ÏùºÏãú Ï§ëÏßÄ</p>
            <div style="background:rgba(0,0,0,0.5); padding:15px; border-radius:10px; margin-bottom:20px; text-align:left; font-size:0.8rem; line-height:1.6; min-width:250px;">
                <strong>CURRENT STATS</strong><br>
                DMG Multi: <span id="pause-dmg">100%</span><br>
                Area Multi: <span id="pause-area">100%</span><br>
                Speed: <span id="pause-spd">100%</span><br>
                Crit Chance: <span id="pause-crit">0%</span><br>
                Coin Bonus: <span id="pause-greed">0%</span>
            </div>
            <div style="display:flex; gap:15px; flex-direction:column;">
                <button class="btn" onclick="togglePause()">Í≥ÑÏÜçÌïòÍ∏∞</button>
                <button class="btn btn-secondary" onclick="quitGame()">Í∑∏ÎßåÌïòÍ∏∞</button>
            </div>
        </div>

        <!-- Weapon Selection Screen -->
        <div id="weapon-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">LOADOUT</h1>
            <p class="screen-subtitle">Î¨¥ÏûëÏúÑ ÏãúÏûë Î¨¥Í∏∞ ÏÑ†ÌÉù</p>
            <div class="card-container" id="weapon-cards" style="justify-content:center;">
                <!-- Filled dynamically -->
            </div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="showStartScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Shop Screen -->
        <div id="shop-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="shop-currency">0</span></div>
            <h1 class="screen-title">LABORATORY</h1>
            <p class="screen-subtitle">Í∏∞Î≥∏ Îä•Î†•Ïπò ÏòÅÍµ¨ Í∞ïÌôî</p>
            <div class="list-layout" id="shop-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeShop()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Armory Screen -->
        <div id="armory-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="armory-currency">0</span></div>
            <h1 class="screen-title">ARMORY</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ Ïû•ÎπÑ ÏóÖÍ∑∏Î†àÏù¥Îìú</p>
            <div class="list-layout" id="armory-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArmory()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Class Screen -->
        <div id="class-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="class-currency">0</span></div>
            <h1 class="screen-title">BARRACKS</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ ÏßÅÏóÖ ÏÑ†ÌÉù Î∞è Ìï¥Í∏à</p>
            <div class="list-layout" id="class-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeClassScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Skill Screen (Ultimate) -->
        <div id="skill-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SKILLS</h1>
            <p class="screen-subtitle">Í∂ÅÍ∑πÍ∏∞ ÏÑ†ÌÉù</p>
            <div id="skill-container" style="width: 100%; max-width: 500px; text-align: left; max-height: 60vh; overflow-y: auto;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeSkillScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Achievements Screen -->
        <div id="achieve-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="achieve-currency">0</span></div>
            <h1 class="screen-title">ACHIEVEMENTS</h1>
            <p class="screen-subtitle">ÏûÑÎ¨¥ Îã¨ÏÑ± Î∞è Î≥¥ÏÉÅ</p>
            <div class="list-layout" id="achieve-container" style="display:flex; flex-direction:column; gap:10px;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeAchieveScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Gacha Screen -->
        <div id="gacha-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="gacha-currency">0</span></div>
            <h1 class="screen-title">SUPPLY DEPOT</h1>
            <p class="screen-subtitle">Î≥¥Í∏âÌíà Ìà¨Ìïò ÏöîÏ≤≠</p>
            
            <div id="gacha-result">
                <div class="gacha-icon" id="g-icon">üíé</div>
                <div class="gacha-name" id="g-name">???</div>
                <div class="gacha-desc" id="g-desc">...</div>
                <button class="btn" onclick="closeGachaResult()">ÌôïÏù∏</button>
            </div>
            
            <div id="gacha-buttons" style="display:flex; flex-direction:column; gap:15px;">
                <button id="gacha-roll-btn" class="btn" onclick="rollGacha()">
                    <div>Ïú†Î¨º ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">300 ü™ô</div>
                </button>
                <button id="skin-roll-btn" class="btn btn-accent" onclick="rollSkinGacha()">
                    <div>Ïä§ÌÇ® ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">1000 ü™ô</div>
                </button>
            </div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeGacha()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Artifact Dex Screen -->
        <div id="artifact-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">ARTIFACTS</h1>
            <p class="screen-subtitle">ÏàòÏßëÌïú Ïú†Î¨º ÎèÑÍ∞ê</p>
            <div class="card-container" id="artifact-container" style="justify-content: flex-start;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArtifactScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Wardrobe Screen -->
        <div id="wardrobe-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">WARDROBE</h1>
            <p class="screen-subtitle">Ïô∏Ìòï Î≥ÄÍ≤Ω</p>
            <div class="skin-grid" id="skin-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeWardrobe()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="ui-layer menu-screen interactive" style="display:flex;">
            <div class="currency-display" style="top:20px; right:20px;">ü™ô <span id="start-screen-gold">0</span></div>
            <h1 class="screen-title" style="font-size:3.5rem; margin-bottom:10px; color:var(--primary);">IFKO<br><span style="font-size:2.5rem; color:#fff;">SURVIVOR</span></h1>
            
            <button class="btn" style="width:220px; height:60px; font-size:1.3rem; margin-bottom:30px; box-shadow: 0 0 20px var(--primary);" onclick="openWeaponSelection()">MISSION START</button>
            
            <div class="menu-grid">
                <button class="btn btn-secondary" onclick="openClassScreen()">ÏßÅÏóÖÏÜå</button>
                <button class="btn btn-secondary" onclick="openSkillScreen()">Ïä§ÌÇ¨</button>
                <button class="btn btn-secondary" onclick="openArmory()">Î¨¥Í∏∞Í≥†</button>
                <button class="btn btn-secondary" onclick="openShop()">Ïó∞Íµ¨ÏÜå</button>
                <button class="btn btn-secondary" onclick="openGacha()">Î≥¥Í∏âÏÜå</button>
                <button class="btn btn-secondary" onclick="openAchieveScreen()">ÏóÖÏ†Å</button>
                <button class="btn btn-secondary" onclick="openWardrobe()">Ïò∑Ïû•</button>
                <button class="btn btn-secondary" onclick="openSettings()">ÏÑ§Ï†ï</button>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SETTINGS</h1>
            <p class="screen-subtitle">ÏãúÏä§ÌÖú ÏÑ§Ï†ï</p>
            
            <div class="mode-toggle" id="void-mode-toggle" onclick="toggleVoidMode()">
                <input type="checkbox" class="mode-checkbox" id="void-mode-cb">
                <span style="font-weight:bold; color:var(--void); text-shadow:0 0 5px var(--void);">VOID MODE (HARD)</span>
            </div>

            <div style="display:flex; flex-direction:column; gap:15px; width: 200px;">
                <button class="btn btn-danger" onclick="resetData()">Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî</button>
                <button class="btn btn-secondary" onclick="closeSettings()">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-layer hidden menu-screen interactive">
            <h1 class="screen-title" style="color:#ff3333; background:none;">MISSION FAILED</h1>
            <p id="final-score" style="font-size:1.5rem; margin-bottom:5px;">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 00:00</p>
            <p id="final-coins" style="font-size:1.2rem; color:var(--gold); margin-bottom:30px;">ÌöçÎìù: 0 ü™ô</p>
            <div style="display:flex; gap:15px;">
                <button class="btn" onclick="openWeaponSelection()">Ïû¨ÏãúÎèÑ</button>
                <button class="btn btn-secondary" onclick="showStartScreen()">Î©îÏù∏ÏúºÎ°ú</button>
            </div>
        </div>
    </div>

<script>
// --- Constants ---
const CANVAS_W = window.innerWidth;
const CANVAS_H = window.innerHeight;
let ZOOM = 0.75; 
const BOSS_SPAWN_TIME = 60; 
const BOSS_RESPAWN_DELAY = 60 * 60; 
const SHOP_BASE_COST = 30; 
const GACHA_COST = 300; 
const SKIN_COST = 1000; 

// --- Definitions ---
const CLASSES = [
    { id: 'soldier', name: 'ÏÜîÏ†Ä', desc: 'Í∑†Ìòï Ïû°Ìûå Ï†ÑÌà¨ ÏöîÏõê', stats: { hp: 0, dmg: 0, spd: 0, cd: 0 }, cost: 0, icon: 'ü™ñ' },
    { id: 'guardian', name: 'Í∞ÄÎîîÏñ∏', desc: 'Ï≤¥Î†• +50, Ïù¥ÎèôÏÜçÎèÑ -10%', stats: { hp: 50, dmg: 0, spd: -0.5, cd: 0 }, cost: 1000, icon: 'üõ°Ô∏è' },
    { id: 'assassin', name: 'Ïñ¥ÏåîÏã†', desc: 'Í≥µÍ≤©Î†• +30%, Ï≤¥Î†• -30', stats: { hp: -30, dmg: 0.3, spd: 1.0, cd: 0 }, cost: 2000, icon: 'üó°Ô∏è' },
    { id: 'mage', name: 'ÏïÑÌÅ¨Î©îÏù¥ÏßÄ', desc: 'Ïø®ÌÉÄÏûÑ -10%, Ï≤¥Î†• -20', stats: { hp: -20, dmg: 0.1, spd: 0, cd: 0.1 }, cost: 3000, icon: 'üîÆ' },
    { id: 'engineer', name: 'ÏóîÏßÄÎãàÏñ¥', desc: 'ÏßÄÏÜçÏãúÍ∞Ñ +20%, ÌÅ¨Í∏∞ +10%', stats: { hp: 10, dmg: 0, spd: 0, cd: 0 }, cost: 4000, icon: 'üîß' }
];

const ULTIMATES = [
    { id: 'nuclear', name: 'Îâ¥ÌÅ¥Î¶¨Ïñ¥', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥Ïùò Ï†ÅÏóêÍ≤å Í¥¥Î©∏Ï†ÅÏù∏ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.', icon: '‚ò¢Ô∏è', color: '#ff3300' },
    { id: 'chrono', name: 'ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨', desc: '5Ï¥à ÎèôÏïà ÏãúÍ∞ÑÏùÑ Î©àÏ∂îÍ≥† ÏûêÏã†ÏùÄ Í∞ÄÏÜçÌï©ÎãàÎã§.', icon: '‚è≥', color: '#00ccff' },
    { id: 'berserk', name: 'Î≤ÑÏÑúÏª§', desc: '10Ï¥à ÎèôÏïà Í≥µÍ≤©ÏÜçÎèÑÏôÄ Ïù¥ÎèôÏÜçÎèÑÍ∞Ä 200% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.', icon: 'ü©∏', color: '#ff0055' }
];

const SKINS = [
    { id: 'default', name: 'Í∏∞Î≥∏', icon: '‚è∫Ô∏è' },
    { id: 'neko', name: 'Ïù¥ÌîÑÎÉ•', icon: 'üê±' },
    { id: 'bot', name: 'Î°úÎ¥á', icon: 'ü§ñ' },
    { id: 'star', name: 'Ïä§ÌÉÄ', icon: '‚≠ê' },
    { id: 'demon', name: 'Îç∞Î™¨', icon: 'üòà' },
    { id: 'alien', name: 'Ïô∏Í≥ÑÏù∏', icon: 'üëΩ' },
    { id: 'ghost', name: 'Ïú†Î†π', icon: 'üëª' },
    { id: 'slime', name: 'Ïä¨ÎùºÏûÑ', icon: 'üü¢' },
    { id: 'pumpkin', name: 'ÌéåÌÇ®', icon: 'üéÉ' }
];

const ARTIFACTS = [
    { id: 'cube', name: 'Í≥†ÎåÄ ÌÅêÎ∏å', desc: 'Í≥µÍ≤©Î†• +10%', icon: 'üßä' },
    { id: 'feather', name: 'Î∞îÎûåÏùò ÍπÉÌÑ∏', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5%', icon: 'ü™∂' },
    { id: 'chip', name: 'AI Ïπ©ÏÖã', desc: 'Ïø®ÌÉÄÏûÑ Í∞êÏÜå -5%', icon: 'üíæ' },
    { id: 'magnet', name: 'Ï¥àÏ†ÑÎèÑ ÏûêÏÑù', desc: 'ÏûêÏÑù Î≤îÏúÑ +20%', icon: 'üß≤' },
    { id: 'fang', name: 'Ìù°ÌòàÏùò ÏÜ°Í≥≥Îãà', desc: 'Ï≤òÏπò Ïãú Ï≤¥Î†• ÌöåÎ≥µ +1', icon: 'üßõ' },
    { id: 'axe', name: 'Í¥ëÏ†ÑÏÇ¨Ïùò ÎèÑÎÅº', desc: 'Ï≤¥Î†•Ïù¥ ÎÇÆÏùÑÏàòÎ°ù Í∞ïÌï¥Ïßê', icon: 'ü™ì' },
    { id: 'watch', name: 'Ï†ïÏßÄÎêú ÏãúÍ≥Ñ', desc: 'Ï†Å Ïù¥ÎèôÏÜçÎèÑ -10%', icon: '‚è±Ô∏è' },
    { id: 'thorn', name: 'Í∞ÄÏãú Í∞ëÏò∑', desc: 'ÌîºÍ≤© Ïãú Î∞òÏÇ¨ ÌîºÌï¥', icon: 'üåµ' },
    { id: 'drink', name: 'ÏóêÎÑàÏßÄ ÎìúÎßÅÌÅ¨', desc: 'Í≥µÍ≤© ÏÜçÎèÑ +10%', icon: 'ü•§' },
    { id: 'scope', name: 'Ïä§ÎÇòÏù¥Ìçº Ïä§ÏΩîÌîÑ', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +10%', icon: 'üî≠' },
    { id: 'shield', name: 'Î≥¥Ìò∏Îßâ ÏÉùÏÑ±Í∏∞', desc: 'Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Î≥¥Ìò∏Îßâ ÏÉùÏÑ±', icon: 'üõ°Ô∏è' },
    { id: 'skull', name: 'Ìô©Í∏à ÎëêÍ∞úÍ≥®', desc: 'Ï†Å Ï≤¥Î†•/Í≤ΩÌóòÏπò/Í≥®Îìú +30%', icon: 'üíÄ' },
    { id: 'jet', name: 'Ï†úÌä∏ ÏóîÏßÑ', desc: 'ÎåÄÏãú Í±∞Î¶¨ Î∞è ÏÜçÎèÑ +20%', icon: 'üöÄ' },
    { id: 'medkit', name: 'Íµ¨Í∏â ÏÉÅÏûê', desc: 'ÌöåÎ≥µ ÏïÑÏù¥ÌÖú Ìö®Ïú® +50%', icon: 'üíä' },
    { id: 'uranium', name: 'Ïó¥Ìôî Ïö∞ÎùºÎäÑ', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ +20%', icon: '‚ò¢Ô∏è' },
    { id: 'nano', name: 'ÎÇòÎÖ∏ Î®∏Ïã†', desc: 'Ï¥àÎãπ Ï≤¥Î†• 0.5% ÌöåÎ≥µ', icon: 'ü¶†' }
];

const UPGRADES = [
    { id: 'blaster', name: 'Î∏îÎûòÏä§ÌÑ∞', desc: 'Í∏∞Î≥∏ ÏÇ¨Í≤© Î¨¥Í∏∞', type: 'WEAPON', icon: 'üî´' },
    { id: 'blade', name: 'Ïä§ÌéôÌä∏Îü¥ Î∏îÎ†àÏù¥Îìú', desc: 'Ï†ÑÎ∞© Î≤îÏúÑ Î≤†Í∏∞', type: 'WEAPON', icon: '‚öîÔ∏è' },
    { id: 'orbit', name: 'Ïä§ÌîºÎ¶ø Ïò§Î∏å', desc: 'Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî ÏòÅÌòº', type: 'WEAPON', icon: 'ü™ê' },
    { id: 'field', name: 'Ï†ÑÍ∏∞Ïû•', desc: 'Ï£ºÎ≥Ä ÏßÄÏÜç ÌîºÌï¥', type: 'WEAPON', icon: '‚ö°' },
    { id: 'tesla', name: 'ÌÖåÏä¨Îùº ÏΩîÏùº', desc: 'Ïó∞ÏáÑ Î≤àÍ∞ú Í≥µÍ≤©', type: 'WEAPON', icon: 'üå©Ô∏è' },
    { id: 'missile', name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', desc: 'Ï∂îÏ†Å Ìè≠Î∞ú ÎØ∏ÏÇ¨Ïùº', type: 'WEAPON', icon: 'üöÄ' },
    { id: 'gravity', name: 'Ï§ëÎ†• Î∂ïÍ¥¥', desc: 'Ï†ÅÏùÑ Î™®ÏúºÎäî Î∏îÎûôÌôÄ', type: 'WEAPON', icon: 'üåå' },
    { id: 'mines', name: 'ÏñëÏûê ÏßÄÎ¢∞', desc: 'ÏÑ§ÏπòÌòï ÏßÄÎ¢∞', type: 'WEAPON', icon: 'üí£' },
    { id: 'drone', name: 'ÏûêÏú® ÎìúÎ°†', desc: 'Ìò∏ÏúÑ ÎìúÎ°†', type: 'WEAPON', icon: 'üöÅ' },
    { id: 'plasma', name: 'ÌîåÎùºÏ¶àÎßà Ïâ¥Îìú', desc: 'ÌöåÏ†ÑÌïòÎäî Î∞©Ïñ¥Îßâ', type: 'WEAPON', icon: 'üõ°Ô∏è' },
    { id: 'ion', name: 'Ïù¥Ïò® Ï∫êÎÖº', desc: 'Í∂§ÎèÑ Ìè≠Í≤© Î†àÏù¥Ï†Ä', type: 'WEAPON', icon: 'üõ∞Ô∏è' },
    { id: 'frost', name: 'ÌîÑÎ°úÏä§Ìä∏ ÎÖ∏Î∞î', desc: 'Ï£ºÎ≥Ä Ï†Å ÎπôÍ≤∞', type: 'WEAPON', icon: '‚ùÑÔ∏è' },
    { id: 'boomerang', name: 'Î∂ÄÎ©îÎûë', desc: 'Ï†ÅÏùÑ ÏπòÍ≥† ÎêòÎèåÏïÑÏòµÎãàÎã§', type: 'WEAPON', icon: 'ü™É' },
    { id: 'flame', name: 'ÌôîÏóº Î∞©ÏÇ¨Í∏∞', desc: 'Ï†ÑÎ∞©Ïóê Î∂àÏùÑ ÎøúÏäµÎãàÎã§', type: 'WEAPON', icon: 'üî•' },
    { id: 'gauss', name: 'Í∞ÄÏö∞Ïä§ ÎùºÏù¥Ìîå', desc: 'Ï¥àÍ≥†ÏÜç Í¥ÄÌÜµ Ï†ÄÍ≤©', type: 'WEAPON', icon: 'üîã' },
    { id: 'spikedball', name: 'Ïä§ÌååÏù¥ÌÅ¨ Î≥º', desc: 'Ï£ºÎ≥ÄÏùÑ ÌäïÍ≤®Îã§ÎãàÎäî Ï≤†Ìá¥', type: 'WEAPON', icon: 'üß∂' },
    { id: 'crossbow', name: 'ÌÅ¨Î°úÏä§Î≥¥Ïö∞', desc: 'Í∞ïÎ†•Ìïú Îã®Î∞ú ÏÇ¨Í≤©', type: 'WEAPON', icon: 'üèπ' },
    { id: 'wand', name: 'ÎπÑÏ†Ñ ÏßÄÌå°Ïù¥', desc: 'Ï†ÅÏùÑ Ï∂îÏ†ÅÌïòÎäî ÎßàÎ≤ï ÎØ∏ÏÇ¨Ïùº', type: 'WEAPON', icon: 'ü™Ñ' },
    { id: 'saw', name: 'ÌöåÏ†Ñ ÌÜ±ÎÇ†', desc: 'Ï†ÑÎ∞©ÏùÑ Í∞ÄÎ•¥Îäî ÌÜ±ÎÇ† Î∞úÏÇ¨', type: 'WEAPON', icon: '‚öôÔ∏è' },
    { id: 'pulse', name: 'ÌéÑÏä§ ÎßÅ', desc: 'Ï£ºÎ≥Ä Ï†ÅÏùÑ Î∞ÄÏ≥êÎÇ¥Îäî Ï∂©Í≤©Ìåå', type: 'WEAPON', icon: '‚≠ï' },
    { id: 'hyperion', name: 'ÌïòÏù¥ÌéòÎ¶¨Ïò® Îπî', desc: 'ÌôîÎ©¥ ÎÅùÍπåÏßÄ ÎãøÎäî Í±∞ÎåÄ Í¥ëÏÑ†', type: 'WEAPON', icon: 'üå†' },
    { id: 'meteor', name: 'Î©îÌÖåÏò§ ÏßÄÌå°Ïù¥', desc: 'ÌïòÎäòÏóêÏÑú Ïö¥ÏÑùÏùÑ ÏÜåÌôòÌï©ÎãàÎã§', type: 'WEAPON', icon: '‚òÑÔ∏è' },
    { id: 'starfall', name: 'Ïä§ÌÉÄÌè¥', desc: 'Î≥ÑÎò•Î≥ÑÏùÑ Îñ®Ïñ¥Îú®Î†§ Í∏∞Ï†àÏãúÌÇµÎãàÎã§', type: 'WEAPON', icon: 'üí´' },
    { id: 'necro', name: 'ÎÑ§ÌÅ¨Î°ú ÏßÄÌå°Ïù¥', desc: 'ÏûêÌè≠ÌïòÎäî ÏòÅÌòºÏùÑ ÏÜåÌôòÌï©ÎãàÎã§', type: 'WEAPON', icon: 'üíÄ' },
    { id: 'poison', name: 'ÎßπÎèÖ ÏïàÍ∞ú', desc: 'Ï£ºÎ≥ÄÏóê ÎèÖÍµ¨Î¶ÑÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§', type: 'WEAPON', icon: 'ü§¢' },
    { id: 'singularity', name: 'ÌäπÏù¥Ï†ê', desc: '[ÌûàÎì†] Ï†ÅÏùÑ ÏÜåÎ©∏ÏãúÌÇ§Îäî Î∏îÎûôÌôÄ', type: 'HIDDEN', icon: '‚ö´', weight: 0.01 },
    { id: 'voidwalker', name: 'Î≥¥Ïù¥Îìú ÏõåÏª§', desc: '[ÌûàÎì†] Í≥µÌóàÏùò ÌãàÏùÑ ÏóΩÎãàÎã§', type: 'HIDDEN', icon: 'üßø', weight: 0.01 },
    
    // Stats
    { id: 'heal', name: 'Í∏¥Í∏â ÏàòÎ¶¨', desc: 'Ï≤¥Î†• 30% ÌöåÎ≥µ', type: 'STAT', icon: '‚ù§Ô∏è' },
    { id: 'giant', name: 'Í±∞ÎåÄÌôî', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ +15%', type: 'STAT', icon: 'üêò' },
    { id: 'multishot', name: 'Î©ÄÌã∞ÏÉ∑', desc: 'Ìà¨ÏÇ¨Ï≤¥ Í∞úÏàò +1 (ÏùºÎ∂Ä Î¨¥Í∏∞)', type: 'STAT', icon: 'üçí' },
    { id: 'sniper', name: 'Ïä§ÎÇòÏù¥Ìçº', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ +20%', type: 'STAT', icon: 'üéØ' },
    { id: 'knockback', name: 'Ï∂©Í≤©ÌÉÑ', desc: 'ÎÑâÎ∞± ÌååÏõå Ï¶ùÍ∞Ä', type: 'STAT', icon: 'ü•ä' },
    { id: 'armor', name: 'Ìã∞ÌÉÄÎäÑ Ïû•Í∞ë', desc: 'Î∞õÎäî ÌîºÌï¥ -2', type: 'STAT', icon: 'üõ°Ô∏è' },
    { id: 'area', name: 'Ï¶ùÌè≠Í∏∞', desc: 'Î≤îÏúÑ Í≥µÍ≤© Î∞òÍ≤Ω +15%', type: 'STAT', icon: 'üì°' },
    { id: 'duration', name: 'Í≥†Ìö®Ïú® Î∞∞ÌÑ∞Î¶¨', desc: 'Î¨¥Í∏∞ ÏßÄÏÜçÏãúÍ∞Ñ +15%', type: 'STAT', icon: 'üîã' },
    { id: 'pickup', name: 'ÏûêÍ∏∞Ïû•', desc: 'ÏïÑÏù¥ÌÖú ÌöçÎìù Î∞òÍ≤Ω +30%', type: 'STAT', icon: 'üß≤' },
    { id: 'dash_cd', name: 'Î∂ÄÏä§ÌÑ∞', desc: 'ÎåÄÏãú Ïø®ÌÉÄÏûÑ -10%', type: 'STAT', icon: 'üëü' },
    { id: 'greed', name: 'Ï±ÑÍµ¥Ïûê', desc: 'Í≥®Îìú ÌöçÎìù +20%', type: 'STAT', icon: 'üí∞' },
    { id: 'growth', name: 'ÏÑ±Ïû•', desc: 'ÏµúÎåÄÏ≤¥Î†• +5%', type: 'STAT', icon: 'üå≤' }
];

const EVOLUTIONS = [
    { weapon: 'blaster', passive: 'sniper', evolveTo: 'exterminator', name: 'ÏóëÏä§ÌÑ∞ÎØ∏ÎÑ§Ïù¥ÌÑ∞', desc: 'Î∏îÎûòÏä§ÌÑ∞ ÏßÑÌôî: Í≥†ÏÜç Í¥ÄÌÜµ Î†àÏù¥Ï†Ä', icon: 'üëπ' },
    { weapon: 'blade', passive: 'area', evolveTo: 'soulreaper', name: 'ÏòÅÌòº ÏàòÌôïÏûê', desc: 'Î∏îÎ†àÏù¥Îìú ÏßÑÌôî: 360ÎèÑ ÏòÅÌòº Î≤†Í∏∞', icon: 'üíÄ' },
    { weapon: 'orbit', passive: 'area', evolveTo: 'blackhole', name: 'Ïù¥Î≤§Ìä∏ Ìò∏ÎùºÏù¥Ï¶å', desc: 'ÏúÑÏÑ± ÏßÑÌôî: Ï†ÅÏùÑ Îπ®ÏïÑÎì§Ïù¥Îäî Í≥µÌóà', icon: '‚ö´' },
    { weapon: 'tesla', passive: 'multishot', evolveTo: 'thundergod', name: 'ÎáåÏã†', desc: 'ÌÖåÏä¨Îùº ÏßÑÌôî: ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌÉÄÍ≤©', icon: '‚ö°' },
    { weapon: 'missile', passive: 'giant', evolveTo: 'nuke', name: 'Ìåª Îß®', desc: 'ÎØ∏ÏÇ¨Ïùº ÏßÑÌôî: Ï†ÑÏà† ÌïµÎ¨¥Í∏∞', icon: '‚ò¢Ô∏è' },
    { weapon: 'ion', passive: 'duration', evolveTo: 'orbital_strike', name: 'Ïò§ÎπÑÌÉà Ïä§Ìä∏ÎùºÏù¥ÌÅ¨', desc: 'Ïù¥Ïò® Ï∫êÎÖº ÏßÑÌôî: ÌñâÏÑ± ÌååÍ¥¥ Î≥ëÍ∏∞', icon: 'üåå' },
    { weapon: 'frost', passive: 'armor', evolveTo: 'blizzard', name: 'Î∏îÎ¶¨ÏûêÎìú', desc: 'ÌîÑÎ°úÏä§Ìä∏ ÎÖ∏Î∞î ÏßÑÌôî: ÏòÅÍµ¨Ï†ÅÏù∏ ÎààÎ≥¥Îùº', icon: 'ü•∂' },
    { weapon: 'meteor', passive: 'giant', evolveTo: 'apocalypse', name: 'ÏïÑÌè¨ÏπºÎ¶ΩÏä§', desc: 'Î©îÌÖåÏò§ ÏßÑÌôî: ÌôîÎ©¥ Ï†ÑÏ≤¥ Í±∞ÎåÄ Ïö¥ÏÑùÏö∞', icon: 'üåã' },
    { weapon: 'starfall', passive: 'dash_cd', evolveTo: 'supernova', name: 'ÏäàÌçºÎÖ∏Î∞î', desc: 'Ïä§ÌÉÄÌè¥ ÏßÑÌôî: Ìè≠Î∞úÌïòÎ©∞ Î∏îÎûôÌôÄ ÏÉùÏÑ±', icon: '‚ú®' },
    { weapon: 'necro', passive: 'revive', evolveTo: 'lichking', name: 'Î¶¨Ïπò ÌÇπ', desc: 'ÎÑ§ÌÅ¨Î°ú ÏßÑÌôî: Ï£ΩÏùåÏùò Íµ∞ÎåÄ ÏÜåÌôò', icon: 'üßü' },
    { weapon: 'poison', passive: 'duration', evolveTo: 'venomstorm', name: 'Î≤†ÎÜà Ïä§ÌÜ∞', desc: 'ÎßπÎèÖ ÏßÑÌôî: ÏπòÎ™ÖÏ†ÅÏù∏ ÏÇ∞ÏÑ± Ìè≠Ìíç', icon: '‚ò£Ô∏è' }
];

const ACHIEVEMENTS = [
    { id: 'k100', name: 'Ï¥àÎ≥¥ ÏÇ¨ÎÉ•Íæº', desc: 'ÎàÑÏ†Å 100ÌÇ¨ Îã¨ÏÑ±', reward: 500, check: (s) => s.totalKills >= 100 },
    { id: 'k1000', name: 'Î≤†ÌÖåÎûë', desc: 'ÎàÑÏ†Å 1000ÌÇ¨ Îã¨ÏÑ±', reward: 1500, check: (s) => s.totalKills >= 1000 },
    { id: 'k5000', name: 'ÌïôÏÇ¥Ïûê', desc: 'ÎàÑÏ†Å 5000ÌÇ¨ Îã¨ÏÑ±', reward: 5000, check: (s) => s.totalKills >= 5000 },
    { id: 'c1000', name: 'ÏàòÏßëÍ∞Ä', desc: 'ÎàÑÏ†Å 1000ÏΩîÏù∏ ÌöçÎìù', reward: 500, check: (s) => s.totalCoins >= 1000 },
    { id: 'c10000', name: 'Î∂ÄÏûê', desc: 'ÎàÑÏ†Å 10000ÏΩîÏù∏ ÌöçÎìù', reward: 3000, check: (s) => s.totalCoins >= 10000 },
    { id: 't600', name: 'ÏÉùÏ°¥Ïûê', desc: 'ÏµúÎåÄ 10Î∂Ñ ÏÉùÏ°¥', reward: 2000, check: (s) => s.maxTime >= 600 }
];

const DEFAULT_DATA = {
    coins: 0,
    currentSkin: 'default',
    ownedSkins: ['default'],
    currentClass: 'soldier',
    ownedClasses: ['soldier'],
    currentUlt: 'nuclear',
    ownedUlts: ['nuclear'],
    upgrades: { 
        damage: 0, health: 0, speed: 0, greed: 0, 
        cooldown: 0, magnet: 0, crit: 0, regen: 0, 
        revive: 0, luck: 0, evasion: 0, xp: 0, duration: 0,
        armor: 0, knockback: 0, reroll: 0, skip: 0, banish: 0, growth: 0
    },
    equipment: { weapon: 0, armor: 0, boots: 0, helmet: 0, gloves: 0, ring: 0 },
    artifacts: {},
    stats: { totalKills: 0, totalTime: 0, totalCoins: 0, maxTime: 0 },
    achievements: [] 
};

let saveData = loadData();

function loadData() {
    const d = localStorage.getItem('ifko_evo_v18');
    if(!d) return JSON.parse(JSON.stringify(DEFAULT_DATA));
    try {
        const parsed = JSON.parse(d);
        const newData = JSON.parse(JSON.stringify(DEFAULT_DATA));
        for (let key in parsed) {
            if (typeof parsed[key] === 'object' && !Array.isArray(parsed[key])) {
                newData[key] = { ...newData[key], ...parsed[key] };
            } else {
                newData[key] = parsed[key];
            }
        }
        return newData;
    } catch(e) {
        return JSON.parse(JSON.stringify(DEFAULT_DATA));
    }
}

function save() {
    localStorage.setItem('ifko_evo_v18', JSON.stringify(saveData));
}

function resetData() {
    if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
        saveData = JSON.parse(JSON.stringify(DEFAULT_DATA));
        save();
        alert("Ï¥àÍ∏∞Ìôî ÏôÑÎ£å.");
        closeSettings();
        location.reload();
    }
}

// --- Game State ---
const state = {
    running: false, paused: false, gameOver: false,
    lastTime: 0, time: 0, score: 0, kills: 0, coins: 0, level: 1, xp: 0, nextLevelXp: 10,
    keys: { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false },
    pointer: { x: 0, y: 0, down: false, id: null },
    joystick: { active: false, originX: 0, originY: 0, dx: 0, dy: 0 },
    lastTap: 0,
    player: null, enemies: [], particles: [], items: [], projectiles: [], 
    boss: null, bossRespawnTimer: 0, bossLevel: 1,
    popups: [], shockwaves: [], gravityWells: [], mines: [], drones: [], voidZones: [], ionBeams: [], worms: [], spikeBalls: [], hyperBeams: [],
    minions: [], poisonClouds: [],
    event: { type: null, timer: 0 },
    stars: [],
    weapons: {},
    sessionStats: { 
        sizeMult: 1, projectileCount: 0, projectileSpeed: 1, 
        areaMult: 1, durationMult: 1, knockbackMult: 1, 
        dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1, growth: 0
    },
    meta: { reroll: 0, skip: 0, banish: 0, banishedItems: [] },
    isVoidMode: false,
    ult: { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 },
    facingRight: true
};

// --- Helper ---
function getNearestEnemy(x, y, range=1000) {
    let closest = null, min = range;
    for(const e of state.enemies) { const d = Math.hypot(e.x-x, e.y-y); if(d<min){min=d;closest=e;}}
    return closest;
}

// --- Classes ---

class Star {
    constructor() {
        this.reset();
        this.x = Math.random() * CANVAS_W;
        this.y = Math.random() * CANVAS_H;
    }
    reset() {
        this.z = Math.random() * 2 + 0.5; // Depth
        this.size = Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        this.x = CANVAS_W/2 + Math.cos(angle) * CANVAS_W;
        this.y = CANVAS_H/2 + Math.sin(angle) * CANVAS_H;
    }
    update(px, py) {
        this.x -= (px * 0.1) / this.z;
        this.y -= (py * 0.1) / this.z;
        if (this.x < 0) this.x += CANVAS_W; if (this.x > CANVAS_W) this.x -= CANVAS_W;
        if (this.y < 0) this.y += CANVAS_H; if (this.y > CANVAS_H) this.y -= CANVAS_H;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255,255,255,${0.3 + 0.5/this.z})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
}

class Player {
    constructor() {
        this.x = 0; this.y = 0;
        
        const job = CLASSES.find(c => c.id === saveData.currentClass) || CLASSES[0];
        
        // Artifact bonuses
        const artDmg = (saveData.artifacts.cube || 0) * 0.1;
        const artSpd = (saveData.artifacts.feather || 0) * 0.05;
        const artCd = (saveData.artifacts.chip || 0) * 0.05 + (saveData.artifacts.drink || 0) * 0.1;
        const artCrit = (saveData.artifacts.scope || 0) * 0.1;
        const artDash = (saveData.artifacts.jet || 0) * 0.2;
        const artRegen = (saveData.artifacts.nano || 0) * 0.5; // 0.5 hp/sec
        const artSize = (saveData.artifacts.uranium || 0) * 0.2;

        const shopDmg = saveData.upgrades.damage * 0.1;
        const shopHp = saveData.upgrades.health * 10;
        const shopSpd = saveData.upgrades.speed * 0.05;
        const shopCd = (saveData.upgrades.cooldown || 0) * 0.05;
        const shopCrit = (saveData.upgrades.crit || 0) * 0.05 + (saveData.upgrades.luck || 0) * 0.02;
        const shopRegen = (saveData.upgrades.regen || 0) * 1;
        const shopRevive = (saveData.upgrades.revive || 0);
        const shopEvasion = (saveData.upgrades.evasion || 0) * 0.05;
        const shopArmor = (saveData.upgrades.armor || 0);
        const shopKnockback = (saveData.upgrades.knockback || 0) * 0.2;
        const shopGrowth = (saveData.upgrades.growth || 0) * 0.05;
        
        if (job.id === 'engineer') { state.sessionStats.durationMult += 0.2; state.sessionStats.sizeMult += 0.1; }

        const equipDmg = saveData.equipment.weapon * 0.2; 
        const equipHp = saveData.equipment.armor * 20;    
        const equipSpd = saveData.equipment.boots * 0.05; 
        const equipCd = saveData.equipment.boots * 0.02;
        const equipCrit = saveData.equipment.helmet * 0.05; 
        const equipCdr = saveData.equipment.gloves * 0.02; 
        const equipGreed = saveData.equipment.ring * 0.1; 

        this.maxHp = (100 + job.stats.hp + shopHp + equipHp) * (1 + shopGrowth);
        this.hp = this.maxHp;
        // Increased base speed as requested
        this.baseSpeed = (5 + job.stats.spd + shopSpd + artSpd + equipSpd);
        this.speed = this.baseSpeed;
        this.dmgMult = 1 + job.stats.dmg + shopDmg + artDmg + equipDmg;
        this.cdReduc = Math.min(0.7, job.stats.cd + artCd + equipCd + shopCd + equipCdr); 
        this.critChance = shopCrit + artCrit + equipCrit;
        this.regenRate = shopRegen + artRegen;
        this.revives = shopRevive;
        this.evasion = shopEvasion;
        
        state.sessionStats.armor = shopArmor;
        state.sessionStats.knockbackMult = 1 + shopKnockback;
        state.sessionStats.sizeMult += artSize;
        state.sessionStats.dashCdMult *= (1 - artDash);
        state.sessionStats.greedMult += equipGreed;

        this.size = 20;
        this.invuln = 0;
        this.dashCd = 0; this.dashTime = 0; this.dashVec = {x:0, y:0};
        this.skin = saveData.currentSkin;
        
        this.shieldTimer = 0;
        this.shield = 0;
    }

    update() {
        if (this.regenRate > 0 && state.time % 60 === 0 && this.hp < this.maxHp) {
            this.hp = Math.min(this.hp + this.regenRate, this.maxHp);
            createPopup('+', this.x, this.y - 20, '#0f0');
        }

        // Shield Artifact
        if (saveData.artifacts.shield) {
            this.shieldTimer++;
            if (this.shieldTimer > 600) { // 10 sec
                this.shield = saveData.artifacts.shield * 20; // 20 Shield per level
                this.shieldTimer = 0;
                createPopup("SHIELD", this.x, this.y - 40, '#00ccff');
            }
        }

        let moveX = 0, moveY = 0;

        if (this.dashTime > 0) {
            // Dash logic fix: Scale speed with player speed
            const dashSpeed = this.speed * 3.5;
            moveX = this.dashVec.x * dashSpeed;
            moveY = this.dashVec.y * dashSpeed;
            
            this.x += moveX; this.y += moveY;
            this.invuln = 5; // Keep invuln while dashing
            this.dashTime--;
            
            if(this.dashTime % 3 === 0) state.particles.push(new Particle(this.x, this.y, '#00ffcc', 10, 10));
        } else {
            let dx = 0, dy = 0;
            if (state.joystick.active) { dx += state.joystick.dx; dy += state.joystick.dy; }
            
            if (state.keys.w || state.keys.ArrowUp) dy -= 1;
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1;
            if (state.keys.d || state.keys.ArrowRight) dx += 1;

            if (dx !== 0 || dy !== 0) { 
                const len = Math.sqrt(dx*dx + dy*dy); 
                if (len > 1) { dx /= len; dy /= len; } 
                else if (len > 0 && !state.joystick.active) { dx /= len; dy /= len; } 
                if(dx > 0) state.facingRight = true; else if (dx < 0) state.facingRight = false;
            }

            if (dx !== 0 || dy !== 0) { 
                moveX = dx * this.speed; moveY = dy * this.speed;
                this.x += moveX; this.y += moveY; 
            }
        }
        
        state.stars.forEach(s => s.update(moveX || 0, moveY || 0));

        if (this.dashCd > 0) this.dashCd--;
        if (this.invuln > 0) this.invuln--;
    }
    
    dash() {
        if (this.dashCd > 0) return;
        let dx = 0, dy = 0;
        
        // Input detection
        if (state.joystick.active) { 
            dx = state.joystick.dx; dy = state.joystick.dy; 
        } else if (state.keys.w || state.keys.a || state.keys.s || state.keys.d || state.keys.ArrowUp || state.keys.ArrowLeft || state.keys.ArrowDown || state.keys.ArrowRight) {
            if (state.keys.w || state.keys.ArrowUp) dy -= 1; 
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1; 
            if (state.keys.d || state.keys.ArrowRight) dx += 1;
            const len = Math.sqrt(dx*dx + dy*dy); 
            if (len > 0) { dx /= len; dy /= len; }
        } else {
            dx = state.facingRight ? 1 : -1;
            dy = 0;
        }
        if (dx === 0 && dy === 0) { dx = state.facingRight ? 1 : -1; }

        this.dashVec = {x: dx, y: dy};
        this.dashTime = 12; 
        this.dashCd = Math.floor(120 * (1 - this.cdReduc) * state.sessionStats.dashCdMult);
        this.invuln = 15; 
        createExplosion(this.x, this.y, '#ffffff', 8);
        createPopup("DASH", this.x, this.y - 30, '#00ffcc');
    }

    takeDamage(amt) {
        if (this.dashTime > 0 || this.invuln > 0) return;
        
        if (Math.random() < this.evasion) { createPopup("MISS", this.x, this.y - 30, '#aaa'); return; }

        if (this.shield > 0) {
            this.shield -= amt;
            createPopup("BLOCKED", this.x, this.y, '#00ccff');
            if(this.shield < 0) this.shield = 0;
            this.invuln = 20;
            return;
        }

        amt = Math.max(1, amt - state.sessionStats.armor);
        this.hp -= amt;
        this.invuln = 30;
        const thorns = saveData.artifacts.thorn || 0;
        if (thorns > 0) { state.enemies.forEach(e => { if(Math.hypot(e.x - this.x, e.y - this.y) < 100) e.takeDamage(amt * thorns * 0.5); }); }
        
        createExplosion(this.x, this.y, '#ff0000', 5);
        state.shockwaves.push(new Shockwave(this.x, this.y, 50, '#ff0000'));
        
        if (this.hp <= 0) {
            if (this.revives > 0) {
                this.revives--; this.hp = this.maxHp * 0.5; this.invuln = 120;
                createExplosion(this.x, this.y, '#fff', 50); createPopup("REVIVE!", this.x, this.y, '#fff');
                state.enemies.forEach(e => { const dx = e.x - this.x, dy = e.y - this.y; e.pushX = dx * 3; e.pushY = dy * 3; });
            } else endGame();
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if(this.dashCd > 0) {
            ctx.beginPath(); ctx.arc(0, 0, this.size + 8, 0, (Math.PI * 2) * (1 - this.dashCd/(120*(1-this.cdReduc)*state.sessionStats.dashCdMult)));
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
        }

        let color = state.isVoidMode ? '#bc13fe' : '#00ffcc';
        if (state.weapons.blaster && state.weapons.blaster.evolved) color = '#ff0099';
        if (this.invuln > 0 && Math.floor(Date.now()/50)%2===0) color = '#fff';
        if (state.ult.activeTime > 0) color = '#ff3300';
        
        if (this.shield > 0) {
            ctx.beginPath(); ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2); 
            ctx.strokeStyle = '#00ccff'; ctx.lineWidth = 2; ctx.stroke();
        }

        ctx.fillStyle = color; ctx.shadowBlur = 20; ctx.shadowColor = color;

        if (this.skin === 'neko') {
            ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-22, -25); ctx.lineTo(-5, -18); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(22, -25); ctx.lineTo(5, -18); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-7, -2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(7, -2, 4, 0, Math.PI*2); ctx.fill();
        } else if (this.skin === 'ghost') {
            ctx.globalAlpha = 0.6;
            ctx.beginPath(); ctx.arc(0, -5, this.size, Math.PI, 0); 
            ctx.lineTo(this.size, this.size); 
            ctx.lineTo(this.size/2, this.size-5); 
            ctx.lineTo(0, this.size); 
            ctx.lineTo(-this.size/2, this.size-5); 
            ctx.lineTo(-this.size, this.size); 
            ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-7, -5, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(7, -5, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        } else if (this.skin === 'slime') {
            ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00';
            const wiggle = Math.sin(state.time * 0.2) * 2;
            ctx.beginPath(); ctx.ellipse(0, 5, this.size + wiggle, this.size - wiggle, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5, 0, 3, 0, Math.PI*2); ctx.fill();
        } else if (this.skin === 'pumpkin') {
            ctx.fillStyle = '#ff6600'; ctx.shadowColor = '#ff6600';
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; 
            ctx.beginPath(); ctx.moveTo(-10, -5); ctx.lineTo(-5, -10); ctx.lineTo(0, -5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(5, -10); ctx.lineTo(0, -5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-10, 5); ctx.lineTo(0, 10); ctx.lineTo(10, 5); ctx.fill();
            ctx.fillStyle = '#00ff00'; ctx.fillRect(-2, -25, 4, 8);
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(-6, -4, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6, -4, 4, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class Enemy {
    constructor(type, x, y, isElite = false) {
        this.type = type; this.x = x; this.y = y; this.pushX = 0; this.pushY = 0; this.frozen = 0;
        this.shootTimer = 0; this.volatileTimer = 0; this.isElite = isElite;
        this.flashTime = 0;
        
        let scaler = 1 + (state.time / 180);
        if (state.isVoidMode) scaler *= 2; 

        if (saveData.artifacts.skull) {
             scaler *= 1.3;
        }

        if (type === 'SQUARE') { this.hp = 10*scaler; this.speed = 1.5; this.size = 15; this.color = '#ff3333'; this.dmg = 10; }
        else if (type === 'TRIANGLE') { this.hp = 5*scaler; this.speed = 2.5; this.size = 12; this.color = '#ffcc00'; this.dmg = 15; }
        else if (type === 'PENTAGON') { this.hp = 20*scaler; this.speed = 1.0; this.size = 20; this.color = '#33ff33'; this.dmg = 20; }
        else if (type === 'RHOMBUS') { this.hp = 15*scaler; this.speed = 4.0; this.size = 14; this.color = '#00ccff'; this.dmg = 15; }
        else if (type === 'OCTAGON') { this.hp = 80*scaler; this.speed = 0.8; this.size = 30; this.color = '#9900ff'; this.dmg = 30; }
        else if (type === 'SHOOTER') { this.hp = 15*scaler; this.speed = 1.2; this.size = 18; this.color = '#ff5500'; this.dmg = 15; }
        else if (type === 'VOLATILE') { this.hp = 8*scaler; this.speed = 3.5; this.size = 12; this.color = '#550000'; this.dmg = 50; }
        else if (type === 'SWARM') { this.hp = 2*scaler; this.speed = 3.0; this.size = 8; this.color = '#bc13fe'; this.dmg = 5; }
        else if (type === 'WORM_HEAD') { this.hp = 150*scaler; this.speed = 2.0; this.size = 20; this.color = '#8800ff'; this.dmg = 20; }
        else if (type === 'WORM_BODY') { this.hp = 500*scaler; this.speed = 2.0; this.size = 18; this.color = '#6600cc'; this.dmg = 10; }
        else if (type === 'TANK') { this.hp = 100*scaler; this.speed = 0.6; this.size = 35; this.color = '#444'; this.dmg = 30; }
        else if (type === 'DASHER') { this.hp = 25*scaler; this.speed = 1.5; this.size = 16; this.color = '#ff9900'; this.dmg = 20; this.dashMode = false; this.dashCool = 100; }
        else if (type === 'SPLITTER') { this.hp = 40*scaler; this.speed = 1.0; this.size = 22; this.color = '#00ff99'; this.dmg = 20; }
        else if (type === 'SPLIT_MINI') { this.hp = 15*scaler; this.speed = 2.0; this.size = 12; this.color = '#00ff99'; this.dmg = 10; }
        else if (type === 'SUMMONER') { this.hp = 50*scaler; this.speed = 0.7; this.size = 25; this.color = '#ff00ff'; this.dmg = 10; this.summonTimer = 0; }
        else if (type === 'MINION') { this.hp = 5*scaler; this.speed = 2.5; this.size = 8; this.color = '#ffaaaa'; this.dmg = 5; }
        else if (type === 'BAT') { this.hp = 5*scaler; this.speed = 3.5; this.size = 10; this.color = '#440000'; this.dmg = 10; }
        else if (type === 'SNIPER') { this.hp = 20*scaler; this.speed = 0.9; this.size = 16; this.color = '#ff0000'; this.dmg = 40; }
        else if (type === 'STALKER') { this.hp = 30*scaler; this.speed = 1.5; this.size = 18; this.color = '#333'; this.dmg = 25; this.visible = false; }
        else if (type === 'TITAN') { this.hp = 300*scaler; this.speed = 0.4; this.size = 45; this.color = '#222'; this.dmg = 60; }
        else if (type === 'MIMIC') { this.hp = 200*scaler; this.speed = 0; this.size = 20; this.color = '#ffd700'; this.dmg = 50; this.active = false; }
        else if (type === 'ABYSS_KNIGHT') { this.hp = 500*scaler; this.speed = 0.8; this.size = 35; this.color = '#110022'; this.dmg = 80; }
        
        if (state.isVoidMode) { this.dmg *= 1.5; this.speed *= 1.2; }
        if (this.isElite) {
            this.hp *= 5; this.size *= 1.5; this.dmg *= 2; 
        }
        
        if (saveData.artifacts.watch) this.speed *= 0.9;
        this.baseSpeed = this.speed;
        this.maxHp = this.hp;
    }
    update(player) {
        if(this.frozen > 0) { this.frozen--; return; }
        if(this.flashTime > 0) this.flashTime--;
        this.x += this.pushX; this.y += this.pushY; this.pushX *= 0.9; this.pushY *= 0.9;
        
        if (this.type === 'WORM_BODY') return; 

        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        
        if (this.type === 'SHOOTER') {
            if (dist > 300) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            else if (dist < 200) { this.x -= (dx / dist) * this.speed; this.y -= (dy / dist) * this.speed; }
            this.shootTimer++;
            if (this.shootTimer > 120) {
                this.shootTimer = 0;
                state.projectiles.push(new Projectile(this.x, this.y, (dx/dist)*5, (dy/dist)*5, 10 * (state.isVoidMode?1.5:1), '#ff3333', 100, 5, 'enemy_bullet'));
            }
        } else if (this.type === 'SNIPER') {
            if (dist > 500) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            else if (dist < 400) { this.x -= (dx / dist) * this.speed; this.y -= (dy / dist) * this.speed; }
            this.shootTimer++;
            if (this.shootTimer > 200) {
                this.shootTimer = 0;
                createPopup("SNIPE!", this.x, this.y - 20, "#ff0000");
                state.projectiles.push(new Projectile(this.x, this.y, (dx/dist)*15, (dy/dist)*15, 30 * (state.isVoidMode?1.5:1), '#ff0000', 100, 3, 'enemy_bullet'));
            }
        } else if (this.type === 'STALKER') {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
            this.visible = dist < 150;
        } else if (this.type === 'TITAN' || this.type === 'ABYSS_KNIGHT') {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
            this.pushX *= 0.5; this.pushY *= 0.5; // Resistant to knockback
        } else if (this.type === 'VOLATILE') {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
            if (dist < 80) {
                this.volatileTimer++;
                this.color = this.volatileTimer % 10 < 5 ? '#ff0000' : '#fff';
                if (this.volatileTimer > 30) {
                    createExplosion(this.x, this.y, '#ff0000', 20);
                    if (dist < 80) player.takeDamage(this.dmg);
                    removeEnemy(this);
                }
            } else { this.volatileTimer = 0; this.color = '#550000'; }
        } else if (this.type === 'DASHER') {
             if (this.dashMode) {
                 this.x += (dx / dist) * this.speed * 4; this.y += (dy / dist) * this.speed * 4;
                 this.dashCool--;
                 if (this.dashCool <= 0) { this.dashMode = false; this.dashCool = 100 + Math.random()*100; }
             } else {
                 this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
                 this.dashCool--;
                 if (this.dashCool <= 0 && dist < 300) { this.dashMode = true; this.dashCool = 40; createPopup("!", this.x, this.y - 20, "#ff0000"); }
             }
        } else if (this.type === 'BAT') { 
             // Zigzag movement
             const perpX = -dy/dist, perpY = dx/dist;
             const wobble = Math.sin(state.time * 0.2) * 2;
             this.x += (dx / dist) * this.speed + perpX * wobble;
             this.y += (dy / dist) * this.speed + perpY * wobble;
        } else if (this.type === 'SUMMONER') {
            if (dist < 400) { this.x -= (dx / dist) * this.speed; this.y -= (dy / dist) * this.speed; }
            else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            this.summonTimer++;
            if(this.summonTimer > 240) {
                this.summonTimer = 0;
                createPopup("SUMMON", this.x, this.y - 30, '#ff00ff');
                for(let i=0; i<3; i++) {
                    state.enemies.push(new Enemy('MINION', this.x + (Math.random()-0.5)*50, this.y + (Math.random()-0.5)*50));
                }
            }
        } else if (this.type === 'MIMIC') {
            if (!this.active && dist < 100) {
                this.active = true;
                this.speed = 4.0;
                createPopup("SURPRISE!", this.x, this.y - 30, '#fff');
            }
            if (this.active) {
                this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
            }
        } else if (this.type === 'WORM_HEAD') {
             const angle = Math.atan2(dy, dx);
             this.x += Math.cos(angle) * this.speed;
             this.y += Math.sin(angle) * this.speed;
        } else {
            if (dist > 0) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
        }
        
        if (dist < this.size + player.size) { 
            player.takeDamage(this.dmg); 
            if(this.type !== 'WORM_HEAD' && this.type !== 'TANK' && this.type !== 'TITAN' && this.type !== 'ABYSS_KNIGHT') { this.pushX = -(dx/dist)*10; this.pushY = -(dy/dist)*10; }
        }
    }
    takeDamage(amt, knockback = 0, sourceX = 0, sourceY = 0) {
        if(this.type === 'MIMIC' && !this.active) {
            this.active = true; this.speed = 4.0; createPopup("!", this.x, this.y-20, '#fff');
        }

        this.flashTime = 5;
        if(saveData.artifacts.axe) { const hpPct = state.player.hp / state.player.maxHp; if(hpPct < 0.5) amt *= 1.5; if(hpPct < 0.2) amt *= 2.0; }
        
        let isCrit = false;
        if (Math.random() < state.player.critChance) { amt *= 2; isCrit = true; }

        amt *= state.player.dmgMult; 
        
        if (knockback > 0 && sourceX && sourceY && this.type !== 'WORM_HEAD' && this.type !== 'WORM_BODY') {
            if (this.type === 'TANK' || this.type === 'TITAN' || this.type === 'ABYSS_KNIGHT') knockback *= 0.1;
            const dx = this.x - sourceX, dy = this.y - sourceY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const kbForce = knockback * state.sessionStats.knockbackMult;
            if (dist > 0) { this.pushX = (dx/dist) * kbForce; this.pushY = (dy/dist) * kbForce; }
        }

        this.hp -= amt; 
        createPopup(Math.round(amt) + (isCrit?'!':''), this.x, this.y - 10, isCrit ? '#f00' : '#fff', true);
        
        if (this.hp <= 0) { this.die(); return true; } return false;
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 8); 
        if(this.type === 'SPLITTER') {
            state.enemies.push(new Enemy('SPLIT_MINI', this.x + 10, this.y));
            state.enemies.push(new Enemy('SPLIT_MINI', this.x - 10, this.y));
        }

        if(saveData.artifacts.fang && Math.random() < 0.1) { state.player.hp = Math.min(state.player.hp + 1, state.player.maxHp); createPopup("+1", state.player.x, state.player.y, '#0f0'); }
        
        const rand = Math.random();
        const luck = saveData.upgrades.luck || 0;
        const isGoldRush = state.event.type === 'GOLDRUSH';

        if (this.isElite || this.type === 'MIMIC') {
            state.items.push(new Item(this.x, this.y, 0, 'CHEST'));
            createPopup("ELITE KILLED", this.x, this.y - 30, '#ffd700');
        } else if (this.type === 'TITAN' || this.type === 'ABYSS_KNIGHT') {
            state.items.push(new Item(this.x, this.y, 200, 'XP'));
        }

        if (rand < 0.005 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'BOMB'));
        else if (rand < 0.01 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'MAGNET'));
        else if (rand < 0.02 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'HEAL'));
        else {
             // Increased Gold Drop Chance (0.05 -> 0.1)
             if (isGoldRush || rand < (state.isVoidMode ? 0.2 : 0.1) * (1+luck*0.1)) {
                 let it = new Item(this.x, this.y, 10, 'XP');
                 it.isCoin = true; it.color = '#ffd700'; 
                 state.items.push(it);
             } else {
                 state.items.push(new Item(this.x, this.y, 5 * (state.isVoidMode?2:1), 'XP')); 
             }
        }
        
        if(this.wormId) {
            state.worms.forEach(w => { if(w.wormId === this.wormId && w !== this) w.hp = 0; });
        }

        state.kills++; saveData.stats.totalKills++;
    }
    draw(ctx) {
        if (this.type === 'STALKER' && !this.visible && this.flashTime <= 0) {
            ctx.globalAlpha = 0.1;
        } else {
            ctx.globalAlpha = 1.0;
        }

        if(this.flashTime > 0) {
            ctx.fillStyle = '#ffffff';
        } else {
            ctx.fillStyle = this.color;
        }
        
        ctx.shadowBlur = this.isElite ? 20 : 10; 
        ctx.shadowColor = this.isElite ? '#ffd700' : this.color; 
        ctx.beginPath();
        if (this.type === 'SQUARE') ctx.rect(this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        else if (this.type === 'TRIANGLE') { ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x + this.size, this.y + this.size); ctx.lineTo(this.x - this.size, this.y + this.size); }
        else if (this.type === 'SHOOTER' || this.type === 'SNIPER') { ctx.moveTo(this.x - this.size, this.y - this.size); ctx.lineTo(this.x + this.size, this.y); ctx.lineTo(this.x - this.size, this.y + this.size); }
        else if (this.type === 'BAT') { 
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x-this.size, this.y); ctx.lineTo(this.x-this.size*2, this.y-10); ctx.lineTo(this.x, this.y-5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x+this.size, this.y); ctx.lineTo(this.x+this.size*2, this.y-10); ctx.lineTo(this.x, this.y-5); ctx.fill();
        }
        else if (this.type === 'WORM_HEAD' || this.type === 'WORM_BODY') { ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); }
        else if (this.type === 'TANK' || this.type === 'TITAN' || this.type === 'ABYSS_KNIGHT') { ctx.rect(this.x - this.size, this.y - this.size*0.8, this.size*2, this.size*1.6); }
        else if (this.type === 'SUMMONER') { 
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI*2); ctx.stroke();
        }
        else if (this.type === 'MIMIC') {
            if (!this.active) {
                ctx.rect(this.x-15, this.y-12, 30, 24); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(this.x-15, this.y-2, 30, 2);
            } else {
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            }
        }
        else ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill(); 
        if(this.isElite) { ctx.strokeStyle='#ffd700'; ctx.lineWidth=2; ctx.stroke(); }
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1.0;
    }
}

class Boss extends Enemy {
    constructor(x, y) { 
        super('OCTAGON', x, y); 
        this.hp = 5000 * (1 + state.time/300) * state.bossLevel * (state.isVoidMode?2:1); 
        this.maxHp = this.hp; this.size = 60; this.speed = 1.2; this.color = '#bc13fe'; 
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 50); 
        const coins = state.isVoidMode ? 60 : 30;
        for(let i=0; i<coins; i++) { 
            let it = new Item(this.x + (Math.random()-0.5)*80, this.y + (Math.random()-0.5)*80, 200, 'XP'); // Boss drop XP buffed
            it.isCoin = true; it.val = 100; state.items.push(it); 
        } 
        state.boss = null; 
        state.bossRespawnTimer = BOSS_RESPAWN_DELAY; 
        state.bossLevel += 0.5;
        document.getElementById('boss-hud').classList.remove('active'); 
        createPopup("BOSS DEFEATED!", this.x, this.y, '#ffd700');
    }
}

class Item {
    constructor(x, y, val, type = 'XP') {
        this.x = x; this.y = y; this.val = val; this.size = 5; this.type = type; this.isCoin = false;
        if (type === 'HEAL') { this.color = '#ff0055'; this.size = 8; }
        else if (type === 'MAGNET') { this.color = '#0055ff'; this.size = 8; }
        else if (type === 'BOMB') { this.color = '#ffaa00'; this.size = 8; }
        else if (type === 'CHEST') { this.color = '#ffd700'; this.size = 12; }
        else { this.isCoin = false; this.color = '#33ccff'; }
    }
    update(player) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        let range = 100 + (saveData.artifacts.magnet || 0) * 20 + (saveData.upgrades.magnet || 0) * 30; 
        range *= state.sessionStats.pickupRangeMult;
        
        if (this.type === 'MAGNET') range = 150;
        if (dist < range) { this.x += (dx / dist) * 12; this.y += (dy / dist) * 12; }
        if (dist < player.size + this.size) {
            if (this.type === 'HEAL') { 
                const mult = saveData.artifacts.medkit ? 1.5 : 1;
                player.hp = Math.min(player.hp + 30 * mult, player.maxHp); createPopup("+" + (30*mult) + " HP", this.x, this.y, '#f00'); 
            }
            else if (this.type === 'MAGNET') { state.items.forEach(i => { if(i.type === 'XP' || i.isCoin) { i.x = player.x; i.y = player.y; } }); createPopup("MAGNET!", this.x, this.y, '#00f'); }
            else if (this.type === 'BOMB') { state.enemies.forEach(e => { if(!(e instanceof Boss)) e.die(); else e.takeDamage(500); }); createExplosion(player.x, player.y, '#fff', 50); createPopup("BOOM!", this.x, this.y, '#fa0'); }
            else if (this.type === 'CHEST') {
                 addXp(200); state.coins += 500; saveData.stats.totalCoins += 500; 
                 createPopup("CHEST! +500ü™ô", this.x, this.y, '#ffd700');
                 createExplosion(this.x, this.y, '#ffd700', 30);
            }
            else if (this.isCoin) { 
                // Boosted Base Gold to 20
                const gain = Math.floor(20 * (1 + saveData.upgrades.greed * 0.1) * state.sessionStats.greedMult * (saveData.artifacts.skull ? 1.3 : 1));
                state.coins += gain; saveData.stats.totalCoins += gain; 
                createPopup(`+${gain}ü™ô`, this.x, this.y, '#ffd700');
            } else { 
                addXp(this.val); 
            }
            return true;
        } return false;
    }
    draw(ctx) { 
        ctx.fillStyle = this.color; ctx.beginPath(); 
        if(this.type === 'HEAL') { ctx.rect(this.x-3, this.y-8, 6, 16); ctx.rect(this.x-8, this.y-3, 16, 6); }
        else if(this.type === 'BOMB') { ctx.arc(this.x, this.y, 8, 0, Math.PI*2); }
        else if(this.type === 'MAGNET') { ctx.arc(this.x, this.y, 8, Math.PI, 0); ctx.lineTo(this.x+8, this.y+8); ctx.lineTo(this.x+4, this.y+8); ctx.lineTo(this.x+4, this.y); ctx.lineTo(this.x-4, this.y); ctx.lineTo(this.x-4, this.y+8); ctx.lineTo(this.x-8, this.y+8); }
        else if(this.type === 'CHEST') { 
            ctx.rect(this.x-10, this.y-8, 20, 16); ctx.fill(); 
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x-10, this.y-2, 20, 2); ctx.fillRect(this.x-2, this.y-8, 4, 16);
        }
        else if(this.isCoin) ctx.arc(this.x, this.y, 6, 0, Math.PI*2); else ctx.rect(this.x-3, this.y-3, 6, 6); 
        ctx.fill(); 
    }
}

class Projectile {
    constructor(x, y, vx, vy, dmg, color, duration, size=4, type='bullet', knockback=2) { 
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.dmg = dmg; this.color = color; 
        this.duration = duration * (1 + (saveData.upgrades.duration || 0) * 0.1) * state.sessionStats.durationMult; 
        this.size = size * state.sessionStats.sizeMult * state.sessionStats.areaMult; 
        this.type = type; 
        this.hitList = []; this.knockback = knockback;
        this.angle = Math.atan2(vy, vx);
        this.returning = false;
        
        if (type === 'magic_missile' || type === 'spirit') {
            this.homing = true;
        }
    }
    update() { 
        if (this.type === 'boomerang') {
            if (!this.returning) {
                this.x += this.vx; this.y += this.vy;
                this.duration--;
                if(this.duration < 0) this.returning = true;
            } else {
                const dx = state.player.x - this.x, dy = state.player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const speed = 15 * state.sessionStats.projectileSpeed;
                this.x += (dx/dist) * speed; this.y += (dy/dist) * speed;
                this.angle += 0.3;
                if(dist < 20) return true; 
            }
            return false;
        }

        if (this.type === 'magic_missile' || this.type === 'spirit') {
            let closest = getNearestEnemy(this.x, this.y, 400);
            if (closest) {
                const angle = Math.atan2(closest.y - this.y, closest.x - this.x);
                const speed = (this.type==='spirit' ? 8 : 12) * state.sessionStats.projectileSpeed;
                this.vx += Math.cos(angle) * 1;
                this.vy += Math.sin(angle) * 1;
                const currentSpeed = Math.hypot(this.vx, this.vy);
                this.vx = (this.vx/currentSpeed)*speed;
                this.vy = (this.vy/currentSpeed)*speed;
            }
            if(this.type === 'spirit') state.particles.push(new Particle(this.x, this.y, '#ffffff', 0, 5, 2));
            else state.particles.push(new Particle(this.x, this.y, '#aa00ff', 0, 5, 2));
        }

        if (this.type === 'saw') {
            if (this.duration > 100) { 
                this.x += this.vx; this.y += this.vy;
            } else { 
                this.angle += 0.5;
            }
        } else {
            this.x += this.vx; this.y += this.vy; 
        }

        this.duration--; 
        if(this.type === 'missile' || this.type === 'nuke') {
            state.particles.push(new Particle(this.x, this.y, '#555', 0, 10, 3));
        }
        return this.duration <= 0; 
    }
    draw(ctx) { 
        ctx.fillStyle = this.color; 
        ctx.shadowBlur = 15; ctx.shadowColor = this.color; 

        if (this.type === 'slash') {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'laser') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.beginPath(); ctx.rect(-15, -this.size/2, 30, this.size); ctx.fill();
            ctx.restore();
        } else if (this.type === 'arrow') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 5); ctx.lineTo(-10, -5); ctx.fill();
            ctx.restore();
        } else if (this.type === 'boomerang') {
             ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
             ctx.beginPath(); ctx.rect(-10, -3, 20, 6); ctx.fill();
             ctx.beginPath(); ctx.rect(-3, -10, 6, 20); ctx.fill();
             ctx.restore();
        } else if (this.type === 'saw') {
             ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle || 0);
             ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.strokeStyle='#ccc'; ctx.stroke();
             for(let i=0; i<8; i++) {
                 ctx.rotate(Math.PI/4);
                 ctx.beginPath(); ctx.moveTo(0, this.size); ctx.lineTo(5, this.size+5); ctx.lineTo(-5, this.size+5); ctx.fill();
             }
             ctx.restore();
        } else if (this.type === 'magic_missile' || this.type === 'spirit') {
             ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'bullet' || this.type === 'enemy_bullet') {
             ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'missile' || this.type === 'nuke') {
             ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
             ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill();
             ctx.restore();
        } else if (this.type === 'star') {
             ctx.beginPath();
             const spikes = 5, outer = this.size, inner = this.size/2;
             let rot = Math.PI/2 * 3, cx = this.x, cy = this.y, step = Math.PI/spikes;
             ctx.moveTo(cx, cy-outer);
             for(let i=0; i<spikes; i++) {
                 ctx.lineTo(cx+Math.cos(rot)*outer, cy+Math.sin(rot)*outer); rot+=step;
                 ctx.lineTo(cx+Math.cos(rot)*inner, cy+Math.sin(rot)*inner); rot+=step;
             }
             ctx.lineTo(cx, cy-outer); ctx.fill();
        } else {
             ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); 
        }
        ctx.shadowBlur = 0; 
    }
}

class Mine {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; 
        this.radius = radius * state.sessionStats.areaMult; 
        this.active = false; this.timer = 60;
    }
    update() {
        if(this.timer > 0) this.timer--; else this.active = true;
        if (this.active) {
            for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < e.size + 15) { this.explode(); return true; } }
        }
        return false;
    }
    explode() {
        createExplosion(this.x, this.y, '#ff4400', 10, 5);
        for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) { if(e.takeDamage(this.dmg, 5, this.x, this.y)) removeEnemy(e); } }
    }
    draw(ctx) {
        ctx.fillStyle = this.active ? ((state.time % 20 < 10) ? '#ff0000' : '#550000') : '#555';
        ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
        if(this.active) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,50,0,0.2)'; ctx.stroke(); }
    }
}

class GasCloud {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; 
        this.radius = radius * state.sessionStats.areaMult; 
        this.life = 300 * state.sessionStats.durationMult;
    }
    update() {
        this.life--;
        if(this.life % 30 === 0) {
            for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) { e.takeDamage(this.dmg); } }
        }
        return this.life <= 0;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(0, 255, 100, ${this.life/300 * 0.4})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        // Smoke particles
        if(state.time % 10 === 0) {
             const angle = Math.random() * Math.PI * 2;
             const r = Math.random() * this.radius;
             state.particles.push(new Particle(this.x + Math.cos(angle)*r, this.y + Math.sin(angle)*r, '#00ff00', 1, 30, 4));
        }
    }
}

class IonBeam {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; this.radius = radius;
        this.timer = 60; this.fired = false;
    }
    update() {
        this.timer--;
        if (this.timer === 0) {
            this.fired = true;
            createExplosion(this.x, this.y, '#00ffff', 20, 10);
            state.shockwaves.push(new Shockwave(this.x, this.y, this.radius * 2, '#00ffff'));
            state.enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) e.takeDamage(this.dmg);
            });
        }
        return this.timer < -20; 
    }
    draw(ctx) {
        if (!this.fired) {
            ctx.strokeStyle = `rgba(0, 255, 255, ${(60-this.timer)/60})`;
            ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (this.timer/60), 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = `rgba(0, 255, 255, 0.2)`; ctx.fill();
            ctx.strokeStyle = 'rgba(0,255,255,0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x, this.y - 1000); ctx.stroke();
        } else {
            const fade = (20 + this.timer) / 20;
            ctx.fillStyle = `rgba(200, 255, 255, ${fade})`;
            ctx.fillRect(this.x - this.radius, this.y - 1000, this.radius*2, 1000 + this.radius);
            ctx.fillStyle = `rgba(255, 255, 255, ${fade})`;
            ctx.fillRect(this.x - this.radius/2, this.y - 1000, this.radius, 1000 + this.radius);
        }
    }
}

class Meteor {
    constructor(x, y, dmg, radius, isGiant = false) {
        this.targetX = x; this.targetY = y; this.dmg = dmg; 
        this.radius = radius; this.isGiant = isGiant;
        this.x = x + 100; this.y = y - 500;
        this.progress = 0;
    }
    update() {
        this.progress += 0.05;
        this.x += (this.targetX - this.x) * 0.1;
        this.y += (this.targetY - this.y) * 0.1;
        if (this.progress >= 1 || Math.abs(this.y - this.targetY) < 10) {
            createExplosion(this.targetX, this.targetY, '#ff4400', 30, 10);
            state.shockwaves.push(new Shockwave(this.targetX, this.targetY, this.radius, '#ff4400'));
            state.enemies.forEach(e => {
                if(Math.hypot(e.x - this.targetX, e.y - this.targetY) < this.radius) {
                    e.takeDamage(this.dmg, 20, this.targetX, this.targetY);
                }
            });
            return true; 
        }
        return false;
    }
    draw(ctx) {
        ctx.fillStyle = '#ff4400';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.isGiant ? 40 : 15, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x+20, this.y-100); ctx.lineTo(this.x-20, this.y-100); ctx.fill();
        
        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        ctx.beginPath(); ctx.arc(this.targetX, this.targetY, this.radius, 0, Math.PI*2); ctx.fill();
    }
}

class HyperionBeam {
    constructor(x, y, angle, dmg) {
        this.x = x; this.y = y; this.angle = angle; this.dmg = dmg;
        this.timer = 30; this.width = 100;
    }
    update() {
        this.timer--;
        if(this.timer % 5 === 0) {
            const range = 2000;
            state.enemies.forEach(e => {
                const dx = e.x - this.x;
                const dy = e.y - this.y;
                const dist = Math.hypot(dx, dy);
                const ang = Math.atan2(dy, dx);
                let diff = ang - this.angle;
                while(diff > Math.PI) diff -= Math.PI*2; while(diff < -Math.PI) diff += Math.PI*2;
                
                if (Math.abs(diff) < 0.2 && dist < range) {
                    if(e.takeDamage(this.dmg)) removeEnemy(e);
                    createExplosion(e.x, e.y, '#fff', 2);
                }
            });
        }
        return this.timer <= 0;
    }
    draw(ctx) {
        const fade = this.timer / 30;
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = `rgba(255, 255, 255, ${fade})`;
        ctx.fillRect(0, -this.width/2 * fade, 2000, this.width * fade);
        ctx.fillStyle = `rgba(255, 200, 100, ${fade*0.5})`;
        ctx.fillRect(0, -this.width * fade, 2000, this.width * 2 * fade);
        ctx.restore();
    }
}

class SpikeBall {
    constructor(player) {
        this.player = player;
        this.x = player.x + 50; this.y = player.y;
        this.vx = 10; this.vy = 10;
        this.radius = 15;
    }
    update(speedMult, areaMult) {
        const speed = 10 * speedMult;
        this.x += this.vx; this.y += this.vy;
        
        const boxSize = 150 * areaMult;
        
        if (this.x > this.player.x + boxSize) { this.x = this.player.x + boxSize; this.vx = -Math.abs(this.vx); }
        if (this.x < this.player.x - boxSize) { this.x = this.player.x - boxSize; this.vx = Math.abs(this.vx); }
        if (this.y > this.player.y + boxSize) { this.y = this.player.y + boxSize; this.vy = -Math.abs(this.vy); }
        if (this.y < this.player.y - boxSize) { this.y = this.player.y - boxSize; this.vy = Math.abs(this.vy); }
        
        const currentSpeed = Math.hypot(this.vx, this.vy);
        if (currentSpeed > 0) {
            this.vx = (this.vx / currentSpeed) * speed;
            this.vy = (this.vy / currentSpeed) * speed;
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#888';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        for(let i=0; i<8; i++) {
            const a = state.time * 0.1 + (i * Math.PI / 4);
            const sx = this.x + Math.cos(a) * (this.radius + 5);
            const sy = this.y + Math.sin(a) * (this.radius + 5);
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(sx, sy); ctx.strokeStyle='#fff'; ctx.stroke();
        }
    }
}

class Drone {
    constructor(player, offset) { this.player = player; this.offset = offset; this.x = player.x; this.y = player.y; }
    update() {
        const t = state.time * 0.05; const targetX = this.player.x + Math.cos(t + this.offset) * 50; const targetY = this.player.y + Math.sin(t + this.offset) * 50;
        this.x += (targetX - this.x) * 0.1; this.y += (targetY - this.y) * 0.1;
    }
    draw(ctx) { ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#00ffff'; }
}

class VoidZone {
    constructor(x, y) { this.x = x; this.y = y; this.life = 300 * state.sessionStats.durationMult; this.r = 0; this.maxR = 150 * state.sessionStats.areaMult; }
    update() {
        if(this.r < this.maxR) this.r += 2; this.life--;
        if(this.life % 20 === 0) {
             for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.r) if(e.takeDamage(10)) removeEnemy(e); }
        }
        return this.life <= 0;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(157, 0, 255, ${this.life/300 * 0.3})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#9d00ff'; ctx.lineWidth = 2; ctx.stroke();
    }
}

class Singularity {
    constructor(x, y) { this.x = x; this.y = y; this.life = 180; this.r = 10; }
    update() {
        this.life--;
        this.r += 0.5;
        for(const e of state.enemies) {
            const dx = this.x - e.x, dy = this.y - e.y, d = Math.hypot(dx, dy);
            if(d < 300 && d > 10) {
                e.x += (dx/d) * 5; e.y += (dy/d) * 5;
            }
        }
        if (this.life <= 0) {
            createExplosion(this.x, this.y, '#000', 50, 20);
            createExplosion(this.x, this.y, '#fff', 50, 10);
            state.shockwaves.push(new Shockwave(this.x, this.y, 400, '#000'));
            for(const e of state.enemies) {
                if(Math.hypot(e.x - this.x, e.y - this.y) < 300) {
                    e.takeDamage(9999);
                    removeEnemy(e);
                }
            }
            return true;
        }
        return false;
    }
    draw(ctx) {
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r * 1.5, 0, Math.PI*2); 
        ctx.strokeStyle = `rgba(255,255,255,${Math.random()})`; ctx.stroke();
    }
}

class Particle {
    constructor(x, y, color, speed, life, size=0) { 
        this.x = x; this.y = y; this.color = color; const angle = Math.random() * Math.PI * 2; 
        this.vx = Math.cos(angle) * speed * Math.random(); this.vy = Math.sin(angle) * speed * Math.random(); 
        this.life = life; this.maxLife = life; this.size = size > 0 ? size : Math.random() * 3 + 1; 
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; this.vx *= 0.95; this.vy *= 0.95; return this.life <= 0; }
    draw(ctx) { ctx.fillStyle = this.color; ctx.globalAlpha = this.life / this.maxLife; ctx.beginPath(); ctx.rect(this.x, this.y, this.size, this.size); ctx.fill(); ctx.globalAlpha = 1; }
}

class PopupText {
    constructor(text, x, y, color, physics=false) { 
        this.text = text; this.x = x; this.y = y; this.color = color; this.life = 40; 
        this.vx = physics ? (Math.random()-0.5)*2 : 0;
        this.vy = -1 - (physics ? Math.random() : 0);
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy *= 0.9; this.life--; return this.life <= 0; }
    draw(ctx) { 
        ctx.fillStyle = this.color; ctx.font = "bold 16px 'Exo 2'"; 
        ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y); 
    }
}

class Shockwave {
    constructor(x, y, maxR, color) { this.x = x; this.y = y; this.r = 10; this.maxR = maxR; this.color = color; this.alpha = 1; }
    update() { this.r += 40; this.alpha -= 0.02; return this.alpha <= 0; }
    draw(ctx) { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.strokeStyle = this.color; ctx.lineWidth = 15; ctx.globalAlpha = this.alpha; ctx.stroke(); ctx.restore(); }
}

function createPopup(text, x, y, color, physics=false) { state.popups.push(new PopupText(text, x, y, color, physics)); }
function createExplosion(x, y, color, count, size=0) { for(let i=0; i<count; i++) state.particles.push(new Particle(x, y, color, 8, 40, size)); }

// --- Logic ---
function updateWeapons() {
    const p = state.player, w = state.weapons; let cdReduc = 1 - p.cdReduc;
    const sizeMult = state.sessionStats.sizeMult;
    const projSpeedMult = state.sessionStats.projectileSpeed;
    const extraProj = state.sessionStats.projectileCount;
    const areaMult = state.sessionStats.areaMult;

    // Blaster
    if (w.blaster && w.blaster.level > 0) {
        if (w.blaster.cd <= 0) {
            let closest = getNearestEnemy(p.x, p.y, w.blaster.evolved ? 700 : 450);
            if (closest) {
                const angle = Math.atan2(closest.y - p.y, closest.x - p.x);
                const shotCount = 1 + extraProj + (w.blaster.evolved ? 2 : 0);
                for(let i=0; i<shotCount; i++) {
                    const spread = shotCount > 1 ? (i - (shotCount-1)/2) * (w.blaster.evolved ? 0.05 : 0.2) : 0;
                    if (w.blaster.evolved) { 
                        state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle + spread)*25*projSpeedMult, Math.sin(angle + spread)*25*projSpeedMult, 90, '#ff0055', 60, 6, 'laser', 4)); 
                    } else { 
                        state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle + spread)*15*projSpeedMult, Math.sin(angle + spread)*15*projSpeedMult, 45+(w.blaster.level*8), '#00ffcc', 40, 5, 'laser', 2)); 
                    }
                }
                w.blaster.cd = w.blaster.evolved ? 4 : Math.max(12, (40-(w.blaster.level*4))*cdReduc);
            }
        } else w.blaster.cd--;
    }

    // Spectral Blade (Auto Aimed)
    if (w.blade && w.blade.level > 0) {
        if (w.blade.cd <= 0) {
             const range = 180 * sizeMult * areaMult;
             let closest = getNearestEnemy(p.x, p.y, range * 1.5);
             const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
             const arc = Math.PI / 1.5;
             
             createExplosion(p.x + Math.cos(angle)*50, p.y, '#ffffff', 5);
             
             const slashProj = new Projectile(p.x, p.y, Math.cos(angle)*5, Math.sin(angle)*5, 0, w.blade.evolved ? '#ff0033' : '#ffffff', 8, 5, 'slash');
             slashProj.draw = (ctx) => {
                 ctx.save(); ctx.translate(p.x, p.y);
                 ctx.rotate(angle);
                 ctx.beginPath(); 
                 ctx.arc(0, 0, range, -arc/2, arc/2); 
                 ctx.strokeStyle = w.blade.evolved ? '#ff0033' : '#fff'; 
                 ctx.lineWidth = w.blade.evolved ? 8 : 4; 
                 ctx.stroke();
                 ctx.fillStyle = w.blade.evolved ? 'rgba(255,0,50,0.3)' : 'rgba(255,255,255,0.2)'; 
                 ctx.fill();
                 ctx.restore();
             };
             state.projectiles.push(slashProj);

             const dmg = (65 + w.blade.level * 15);
             for(const e of state.enemies) {
                 const dx = e.x - p.x; const dy = e.y - p.y;
                 const dist = Math.sqrt(dx*dx + dy*dy);
                 if (dist < range) {
                     const ang = Math.atan2(dy, dx);
                     let diff = ang - angle;
                     while(diff > Math.PI) diff -= Math.PI*2; while(diff < -Math.PI) diff += Math.PI*2;
                     if(Math.abs(diff) < arc/2) {
                         if(e.takeDamage(dmg, 20, p.x, p.y)) removeEnemy(e);
                     }
                 }
             }
             w.blade.cd = Math.max(20, (60 - w.blade.level * 5) * cdReduc);
        } else w.blade.cd--;
    }

    // Orbit
    if (w.orbit && w.orbit.level > 0) {
        w.orbit.angle += (w.orbit.evolved ? 0.1 : 0.05); 
        const count = w.orbit.level + (saveData.artifacts.cube ? 1 : 0) + extraProj + (w.orbit.evolved ? 2 : 0);
        for(let i=0; i<count; i++) {
            const theta = w.orbit.angle + (Math.PI*2*i/count); 
            const dist = w.orbit.evolved ? 140 : 80;
            const ox = p.x + Math.cos(theta)*dist*sizeMult, oy = p.y + Math.sin(theta)*dist*sizeMult;
            
            if(state.time % 2 === 0) state.particles.push(new Particle(ox, oy, w.orbit.evolved ? '#330066' : '#33ccff', 0, 10, 4));

            if (w.orbit.evolved) {
                 createExplosion(ox, oy, '#000', 1, 3);
                 for(const e of state.enemies) {
                    if(Math.hypot(e.x - ox, e.y - oy) < 50 * sizeMult * areaMult) {
                        e.takeDamage(5); e.pushX = (ox - e.x)*0.2; e.pushY = (oy - e.y)*0.2; 
                        if(e.hp <= 0) removeEnemy(e);
                    }
                }
            } else {
                state.particles.push(new Particle(ox, oy, '#fff', 1, 2, 5 * sizeMult));
                for(const e of state.enemies) if(Math.hypot(e.x - ox, e.y - oy) < 20 * sizeMult && e.takeDamage(20)) removeEnemy(e);
            }
        }
    }

    if (w.field && w.field.level > 0) {
        if (w.field.cd <= 0) {
            createExplosion(p.x, p.y, 'rgba(0,255,100,0.2)', 5, 10*sizeMult);
            const range = (w.field.radius + (w.field.level*10)) * sizeMult * areaMult;
            for(const e of state.enemies) if(Math.hypot(e.x - p.x, e.y - p.y) < range && e.takeDamage(8+w.field.level*2)) removeEnemy(e);
            w.field.cd = 30 * cdReduc;
        } else w.field.cd--;
    }

    if (w.tesla && w.tesla.level > 0) { 
        if (w.tesla.cd <= 0) { 
            if (w.tesla.evolved) {
                createPopup("THUNDER!", p.x, p.y-50, '#ffaa00');
                for(let i=0; i<10; i++) {
                    if(state.enemies.length > 0) {
                        const target = state.enemies[Math.floor(Math.random()*state.enemies.length)];
                        createLightning(p.x, p.y-500, target.x, target.y, '#ffaa00', 3);
                        createExplosion(target.x, target.y, '#ffaa00', 10);
                        target.takeDamage(150);
                        if(target.hp<=0) removeEnemy(target);
                    }
                }
                w.tesla.cd = 90 * cdReduc;
            } else {
                let target = getNearestEnemy(p.x, p.y, 250);
                if(target) { 
                    fireTesla(target, 3+w.tesla.level+extraProj, 35+w.tesla.level*8); 
                    w.tesla.cd = (120-(w.tesla.level*5)) * cdReduc; 
                } 
            }
        } else w.tesla.cd--; 
    }
    
    if (w.missile && w.missile.level > 0) { 
        if (w.missile.cd <= 0) { 
            const count = 1 + Math.floor(extraProj/2) + (w.missile.evolved ? 1 : 0);
            for(let i=0; i<count; i++) {
                const dmg = w.missile.evolved ? 450 : 70+w.missile.level*15;
                const area = w.missile.evolved ? 200 : 60;
                const col = w.missile.evolved ? '#00ff00' : '#ffaa00';
                const type = w.missile.evolved ? 'nuke' : 'missile';
                const proj = new Projectile(p.x, p.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, dmg, col, 150, w.missile.evolved?20:10, type);
                proj.homing = true; 
                proj.update = function() {
                    this.x += this.vx; this.y += this.vy; this.duration--; 
                    this.angle = Math.atan2(this.vy, this.vx);
                    state.particles.push(new Particle(this.x, this.y, '#555', 0, 10, 3)); 
                    let closest = getNearestEnemy(this.x, this.y, 400);
                    if(closest) {
                        const tAngle = Math.atan2(closest.y - this.y, closest.x - this.x);
                        this.vx += Math.cos(tAngle) * 0.5; this.vy += Math.sin(tAngle) * 0.5;
                        const s = Math.hypot(this.vx, this.vy);
                        if(s > 10) { this.vx = (this.vx/s)*10; this.vy = (this.vy/s)*10; }
                    }
                    return this.duration <= 0;
                };
                proj.onHit = () => { 
                    createExplosion(proj.x, proj.y, col, 30); 
                    state.shockwaves.push(new Shockwave(proj.x, proj.y, area, col));
                    state.enemies.forEach(e => { if(Math.hypot(e.x-proj.x, e.y-proj.y)<area) e.takeDamage(dmg); }); 
                };
                state.projectiles.push(proj); 
            }
            w.missile.cd = (80 - w.missile.level*5) * cdReduc; 
        } else w.missile.cd--; 
    }

    if (w.gravity && w.gravity.level > 0) { if(w.gravity.cd <= 0) { spawnGravityWell(p.x, p.y, w.gravity.level); w.gravity.cd = (300 - w.gravity.level*10) * cdReduc; } else w.gravity.cd--; }

    if (w.mines && w.mines.level > 0) {
        if (w.mines.cd <= 0) {
            state.mines.push(new Mine(p.x, p.y, 150 + w.mines.level*30, 100 * sizeMult));
            w.mines.cd = Math.max(30, (120 - w.mines.level * 10) * cdReduc);
        } else w.mines.cd--;
    }

    if (w.drone && w.drone.level > 0) {
        if (state.drones.length < 1 + extraProj) {
            state.drones = [];
            for(let i=0; i < 1 + extraProj; i++) state.drones.push(new Drone(p, i));
        }
        if (w.drone.cd <= 0) {
            state.drones.forEach(d => {
                let closest = getNearestEnemy(d.x, d.y, 350);
                if(closest) {
                    const ang = Math.atan2(closest.y - d.y, closest.x - d.x);
                    createExplosion(d.x, d.y, '#00ffff', 3);
                    state.projectiles.push(new Projectile(d.x, d.y, Math.cos(ang)*15, Math.sin(ang)*15, 25+w.drone.level*8, '#00ffff', 40, 3, 'laser'));
                }
            });
            w.drone.cd = Math.max(8, (35 - w.drone.level*3) * cdReduc);
        } else w.drone.cd--;
    }

    if (w.plasma && w.plasma.level > 0) {
        w.plasma.angle += 0.05;
        const radius = 60 * sizeMult * areaMult;
        for(const e of state.enemies) {
            if (Math.hypot(e.x - p.x, e.y - p.y) < radius + e.size) { e.takeDamage(4 + w.plasma.level * 1.5, 8, p.x, p.y); }
        }
    }
    
    if (w.ion && w.ion.level > 0) {
        if (w.ion.cd <= 0) {
            const range = (100 + w.ion.level * 20) * sizeMult * areaMult;
            const dmg = 350 + w.ion.level * 80;
            state.ionBeams.push(new IonBeam(p.x + (Math.random()-0.5)*400, p.y + (Math.random()-0.5)*400, dmg, range));
            w.ion.cd = Math.max(60, (240 - w.ion.level * 10) * cdReduc);
        } else w.ion.cd--;
    }

    if (w.frost && w.frost.level > 0) {
        if (w.frost.cd <= 0) {
            const range = (150 + w.frost.level * 20) * sizeMult * areaMult;
            const dmg = 30 + w.frost.level * 10;
            state.shockwaves.push(new Shockwave(p.x, p.y, range, '#00ccff'));
            createExplosion(p.x, p.y, '#00ccff', 20);
            for(const e of state.enemies) { if(Math.hypot(e.x - p.x, e.y - p.y) < range) { e.takeDamage(dmg); e.frozen = w.frost.evolved ? 180 : 60; } }
            w.frost.cd = w.frost.evolved ? 60 * cdReduc : Math.max(120, (300 - w.frost.level * 20) * cdReduc);
        } else w.frost.cd--;
    }

    if (w.voidwalker && w.voidwalker.level > 0) {
        if (w.voidwalker.cd <= 0) {
            state.voidZones.push(new VoidZone(p.x + (Math.random()-0.5)*400, p.y + (Math.random()-0.5)*400));
            w.voidwalker.cd = 60 * cdReduc;
        } else w.voidwalker.cd--;
    }

    // Boomerang (Buffed)
    if (w.boomerang && w.boomerang.level > 0) {
        if (w.boomerang.cd <= 0) {
            const count = 1 + extraProj;
            let closest = getNearestEnemy(p.x, p.y, 400);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            for(let i=0; i<count; i++) {
                const a = angle + (i - (count-1)/2)*0.3;
                state.projectiles.push(new Projectile(p.x, p.y, Math.cos(a)*12*projSpeedMult, Math.sin(a)*12*projSpeedMult, 50+w.boomerang.level*10, '#aa55ff', 40, 6, 'boomerang'));
            }
            w.boomerang.cd = Math.max(20, (60 - w.boomerang.level * 5) * cdReduc);
        } else w.boomerang.cd--;
    }

    // Flamethrower (Auto Aimed)
    if (w.flame && w.flame.level > 0) {
        if (w.flame.cd <= 0) {
            let closest = getNearestEnemy(p.x, p.y, 400);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            const count = 3 + w.flame.level;
            for(let i=0; i<count; i++) {
                const spread = (Math.random()-0.5) * 0.5;
                const speed = (5 + Math.random()*5) * projSpeedMult;
                const proj = new Projectile(p.x, p.y, Math.cos(angle+spread)*speed, Math.sin(angle+spread)*speed, 8+w.flame.level*2, '#ff5500', 30, 4, 'bullet');
                proj.pierce = true;
                state.projectiles.push(proj);
            }
            w.flame.cd = 5; 
        } else w.flame.cd--;
    }

    // Gauss Rifle
    if (w.gauss && w.gauss.level > 0) {
        if (w.gauss.cd <= 0) {
            let closest = getNearestEnemy(p.x, p.y, 600);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            const range = 1000;
            const endX = p.x + Math.cos(angle)*range, endY = p.y + Math.sin(angle)*range;
            
            const beam = new Projectile(p.x, p.y, 0, 0, 0, '#00ff00', 10, 2, 'laser');
            beam.draw = (ctx) => {
                ctx.strokeStyle = `rgba(0,255,100,${beam.duration/10})`; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(endX, endY); ctx.stroke();
            };
            state.projectiles.push(beam);

            state.enemies.forEach(e => {
                const A = p.x - e.x, B = p.y - e.y, C = endX - p.x, D = endY - p.y;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -dot / len_sq;
                let xx, yy;
                if (param < 0) { xx = p.x; yy = p.y; }
                else if (param > 1) { xx = endX; yy = endY; }
                else { xx = p.x + param * C; yy = p.y + param * D; }
                const dx = e.x - xx, dy = e.y - yy;
                if ((dx * dx + dy * dy) < (e.size + 10) * (e.size + 10)) {
                    e.takeDamage(100 + w.gauss.level * 30);
                    createExplosion(e.x, e.y, '#00ff00', 5);
                }
            });
            w.gauss.cd = Math.max(30, (90 - w.gauss.level*5) * cdReduc);
        } else w.gauss.cd--;
    }

    // Spike Ball
    if (w.spikedball && w.spikedball.level > 0) {
        if (state.spikeBalls.length < 1 + extraProj) {
            state.spikeBalls = [];
            for(let i=0; i<1+extraProj; i++) state.spikeBalls.push(new SpikeBall(p));
        }
        const dmg = 30 + w.spikedball.level * 8;
        state.spikeBalls.forEach(ball => {
            ball.update(projSpeedMult, areaMult);
            state.enemies.forEach(e => {
                if (Math.hypot(e.x - ball.x, e.y - ball.y) < ball.radius + e.size) {
                    if(state.time % 10 === 0) e.takeDamage(dmg, 10, ball.x, ball.y);
                }
            });
        });
    }

    // Crossbow
    if (w.crossbow && w.crossbow.level > 0) {
        if (w.crossbow.cd <= 0) {
            let closest = getNearestEnemy(p.x, p.y, 500);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            const count = 1 + extraProj;
            for(let i=0; i<count; i++) {
                const spread = (i - (count-1)/2) * 0.1;
                state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle+spread)*20*projSpeedMult, Math.sin(angle+spread)*20*projSpeedMult, 150+w.crossbow.level*25, '#ffff00', 50, 4, 'arrow'));
            }
            w.crossbow.cd = Math.max(30, (80 - w.crossbow.level*5) * cdReduc);
        } else w.crossbow.cd--;
    }

    // Arcane Wand
    if (w.wand && w.wand.level > 0) {
        if (w.wand.cd <= 0) {
            const count = 2 + w.wand.level + extraProj;
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    if(state.running) state.projectiles.push(new Projectile(p.x, p.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, 35+w.wand.level*8, '#aa00ff', 60, 4, 'magic_missile'));
                }, i * 100);
            }
            w.wand.cd = Math.max(40, (100 - w.wand.level*5) * cdReduc);
        } else w.wand.cd--;
    }

    // Sawblade (Auto Aimed)
    if (w.saw && w.saw.level > 0) {
        if (w.saw.cd <= 0) {
            const count = 1 + extraProj;
            let closest = getNearestEnemy(p.x, p.y, 500);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            for(let i=0; i<count; i++) {
                const a = angle + (i - (count-1)/2)*0.3;
                state.projectiles.push(new Projectile(p.x, p.y, Math.cos(a)*10, Math.sin(a)*10, 25+w.saw.level*5, '#cccccc', 150, 12, 'saw'));
            }
            w.saw.cd = Math.max(30, (90 - w.saw.level*5) * cdReduc);
        } else w.saw.cd--;
    }
    
    // Pulse Ring
    if (w.pulse && w.pulse.level > 0) {
        if (w.pulse.cd <= 0) {
            const range = (100 + w.pulse.level * 25) * areaMult;
            state.shockwaves.push(new Shockwave(p.x, p.y, range, '#ff00aa'));
            state.enemies.forEach(e => {
                if(Math.hypot(e.x - p.x, e.y - p.y) < range) {
                    e.takeDamage(40 + w.pulse.level * 15, 30, p.x, p.y); 
                }
            });
            w.pulse.cd = Math.max(40, (100 - w.pulse.level * 5) * cdReduc);
        } else w.pulse.cd--;
    }

    // Hyperion Beam (Auto Aimed)
    if (w.hyperion && w.hyperion.level > 0) {
        if (w.hyperion.cd <= 0) {
            let closest = getNearestEnemy(p.x, p.y, 800);
            const angle = closest ? Math.atan2(closest.y - p.y, closest.x - p.x) : (state.facingRight ? 0 : Math.PI);
            const dmg = 100 + w.hyperion.level * 30;
            state.hyperBeams.push(new HyperionBeam(p.x, p.y, angle, dmg));
            w.hyperion.cd = Math.max(120, (300 - w.hyperion.level * 20) * cdReduc);
        } else w.hyperion.cd--;
    }
    
    // Meteor Wand
    if (w.meteor && w.meteor.level > 0) {
        if (w.meteor.cd <= 0) {
            const count = (w.meteor.evolved ? 5 : 1) + Math.floor(extraProj/2);
            for(let i=0; i<count; i++) {
                const offsetX = (Math.random()-0.5) * (w.meteor.evolved ? 800 : 400);
                const offsetY = (Math.random()-0.5) * (w.meteor.evolved ? 800 : 400);
                setTimeout(() => {
                    if(state.running) state.projectiles.push(new Meteor(p.x + offsetX, p.y + offsetY, 100 + w.meteor.level*30, 80 * areaMult, w.meteor.evolved));
                }, i * 100);
            }
            w.meteor.cd = Math.max(50, (150 - w.meteor.level*10) * cdReduc);
        } else w.meteor.cd--;
    }

    // Starfall
    if (w.starfall && w.starfall.level > 0) {
        if (w.starfall.cd <= 0) {
             const count = (w.starfall.evolved ? 3 : 1) + extraProj;
             for(let i=0; i<count; i++) {
                 const angle = Math.random() * Math.PI * 2;
                 const dist = 100 + Math.random() * 300;
                 const tx = p.x + Math.cos(angle)*dist;
                 const ty = p.y + Math.sin(angle)*dist;
                 
                 const star = new Projectile(tx, ty - 500, 0, 15, 50 + w.starfall.level * 15, '#ffff00', 60, 10, 'star');
                 star.targetY = ty;
                 star.update = function() {
                     this.y += this.vy;
                     if(this.y >= this.targetY) {
                         createExplosion(this.x, this.y, '#ffff00', 10);
                         if (w.starfall.evolved) {
                             state.gravityWells.push({x: this.x, y: this.y, life: 60, range: 100, dmg: 5}); // Mini black hole
                         }
                         state.enemies.forEach(e => {
                             if(Math.hypot(e.x - this.x, e.y - this.y) < 60) {
                                 e.takeDamage(this.dmg, 0, this.x, this.y);
                                 e.frozen = 60;
                             }
                         });
                         return true;
                     }
                     return false;
                 };
                 state.projectiles.push(star);
             }
             w.starfall.cd = Math.max(30, (100 - w.starfall.level * 5) * cdReduc);
        } else w.starfall.cd--;
    }
    
    // Necro Staff
    if (w.necro && w.necro.level > 0) {
        if (w.necro.cd <= 0) {
            const count = (w.necro.evolved ? 2 : 1) + extraProj;
            for(let i=0; i<count; i++) {
                const spirit = new Projectile(p.x, p.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, 80 + w.necro.level * 20, '#ffffff', 300, 6, 'spirit');
                spirit.onHit = () => { createExplosion(spirit.x, spirit.y, '#ffffff', 10); };
                state.projectiles.push(spirit);
            }
            w.necro.cd = Math.max(60, (180 - w.necro.level * 10) * cdReduc);
        } else w.necro.cd--;
    }
    
    // Toxic Mist
    if (w.poison && w.poison.level > 0) {
        if (w.poison.cd <= 0) {
            const count = w.poison.evolved ? 3 : 1;
            for(let i=0; i<count; i++) {
                const offsetX = (Math.random()-0.5) * 100;
                const offsetY = (Math.random()-0.5) * 100;
                state.poisonClouds.push(new GasCloud(p.x + offsetX, p.y + offsetY, 5 + w.poison.level * 2, 80));
            }
            w.poison.cd = Math.max(60, (200 - w.poison.level * 15) * cdReduc);
        } else w.poison.cd--;
    }
    
    // Singularity
    if (w.singularity && w.singularity.level > 0) {
        if (w.singularity.cd <= 0) {
            state.voidZones.push(new Singularity(p.x + (Math.random()-0.5)*300, p.y + (Math.random()-0.5)*300));
            w.singularity.cd = 300 * cdReduc; 
        } else w.singularity.cd--;
    }

    // Ultimate
    if (!state.ult.ready) { 
        state.ult.cd++; 
        if (state.ult.cd >= state.ult.maxCd) { 
            state.ult.ready = true; 
            document.getElementById('ult-btn').classList.remove('disabled'); 
            const curUlt = ULTIMATES.find(u => u.id === saveData.currentUlt);
            document.getElementById('ult-btn').innerHTML = `<div id="ult-icon">${curUlt.icon}</div><div id="ult-label">ULTIMATE</div>`; 
            document.getElementById('ult-btn').style.borderColor = curUlt.color;
        } else { 
            document.getElementById('ult-btn').innerHTML = `<div style="font-size:0.8rem">${Math.floor((state.ult.cd/state.ult.maxCd)*100)}%</div>`; 
        } 
    }
    
    if (state.ult.activeTime > 0) {
        state.ult.activeTime--;
        if (saveData.currentUlt === 'berserk') {
             if(state.ult.activeTime % 5 === 0) createExplosion(p.x, p.y, '#ff0000', 1);
        }
        if (state.ult.activeTime <= 0) {
            if(saveData.currentUlt === 'berserk') { p.speed = p.baseSpeed; p.dmgMult /= 3; }
            if(saveData.currentUlt === 'chrono') { state.enemies.forEach(e => e.frozen = 0); p.speed = p.baseSpeed; }
        }
    }
}

function fireTesla(target, bounces, dmg) {
    let curr = target, visited = [target];
    createExplosion(target.x, target.y, '#00ffff', 5);
    createLightning(state.player.x, state.player.y, target.x, target.y, '#00ffff', 2);
    
    for(let i=0; i<bounces; i++) {
        if(curr.takeDamage(dmg)) removeEnemy(curr);
        let next = null, minD = 200;
        for(const e of state.enemies) { if (!visited.includes(e)) { const d = Math.hypot(e.x - curr.x, e.y - curr.y); if(d < minD) { minD = d; next = e; } } }
        if(next) { createLightning(curr.x, curr.y, next.x, next.y, '#00ffff', 2); curr = next; visited.push(next); createExplosion(next.x, next.y, '#00ffff', 5); } else break;
    }
}
function createLightning(x1, y1, x2, y2, color='#88ccff', width=1) { 
    const d = Math.hypot(x2-x1, y2-y1);
    const steps = d / 15;
    const ang = Math.atan2(y2-y1, x2-x1);
    for(let i=1; i<=steps; i++) {
        const t = i/steps;
        const jitter = (Math.random()-0.5) * 20;
        const tx = x1 + (x2-x1)*t + Math.cos(ang + Math.PI/2)*jitter;
        const ty = y1 + (y2-y1)*t + Math.sin(ang + Math.PI/2)*jitter;
        state.particles.push(new Particle(tx, ty, color, 0, 10, width*2)); 
    }
}

function spawnGravityWell(x, y, level) { state.gravityWells.push({x, y, life: 180, range: 150+level*20*state.sessionStats.sizeMult * state.sessionStats.areaMult, dmg: level}); }

function spawnWorm(x, y) {
    const wormId = Date.now() + Math.random();
    const head = new Enemy('WORM_HEAD', x, y, true); // Head is elite-like
    head.wormId = wormId;
    state.enemies.push(head);
    state.worms.push(head);
    
    let prev = head;
    for(let i=0; i<8; i++) {
        const body = new Enemy('WORM_BODY', x, y);
        body.wormId = wormId;
        state.enemies.push(body);
        state.worms.push(body);
        // Link
        body.update = function(player) {
            const dx = prev.x - this.x;
            const dy = prev.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 20) {
                const angle = Math.atan2(dy, dx);
                this.x = prev.x - Math.cos(angle) * 20;
                this.y = prev.y - Math.sin(angle) * 20;
            }
            if(Math.hypot(player.x - this.x, player.y - this.y) < this.size + player.size) player.takeDamage(10);
        };
        prev = body;
    }
}

function useUltimate() { 
    if (!state.ult.ready) return; 
    state.ult.ready = false; state.ult.cd = 0; 
    document.getElementById('ult-btn').classList.add('disabled'); 
    
    const u = saveData.currentUlt;
    
    if (u === 'nuclear') {
        createExplosion(state.player.x, state.player.y, '#ffd700', 100, 10); 
        createExplosion(state.player.x, state.player.y, '#ff00ff', 50, 5);
        state.shockwaves.push(new Shockwave(state.player.x, state.player.y, 1500, '#ffd700'));
        document.body.style.filter = 'invert(1)'; setTimeout(() => document.body.style.filter = 'none', 100); 
        for(let i=state.enemies.length-1; i>=0; i--) { 
            const e = state.enemies[i]; 
            if (e instanceof Boss) e.takeDamage(1000); 
            else { createExplosion(e.x, e.y, e.color, 5); state.enemies.splice(i, 1); state.kills++; } 
        } 
    } else if (u === 'chrono') {
        state.ult.activeTime = 300; // 5 sec
        state.shockwaves.push(new Shockwave(state.player.x, state.player.y, 1500, '#00ccff'));
        createPopup("TIME STOP!", state.player.x, state.player.y - 50, '#00ccff');
        state.enemies.forEach(e => e.frozen = 300);
        state.player.speed *= 2;
    } else if (u === 'berserk') {
        state.ult.activeTime = 600; // 10 sec
        state.player.speed *= 2;
        state.player.dmgMult *= 3;
        createPopup("BERSERK MODE!", state.player.x, state.player.y - 50, '#ff0055');
    }
}

// Events Logic
function updateEvents() {
    if (state.event.type) {
        state.event.timer--;
        if (state.event.timer <= 0) {
            state.event.type = null;
            document.getElementById('event-hud').style.display = 'none';
        }
    } else {
        if (state.time > 600 && Math.random() < 0.0005) {
             triggerEvent('GOLDRUSH');
        }
    }
}

function triggerEvent(type) {
    state.event.type = type;
    state.event.timer = 600; 
    const hud = document.getElementById('event-hud');
    hud.style.display = 'block';
    hud.innerText = type === 'METEOR' ? '‚ö†Ô∏è METEOR SHOWER ‚ö†Ô∏è' : 'üí∞ GOLD RUSH üí∞';
    hud.style.color = type === 'METEOR' ? '#ff3333' : '#ffd700';
    createPopup("EVENT START!", state.player.x, state.player.y - 100, '#fff');
}

const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();
window.addEventListener('wheel', (e) => {
    let target = e.target;
    while(target && target !== document.body) {
        if (target.classList && (target.classList.contains('card-container') || target.classList.contains('list-layout') || target.classList.contains('skin-grid') || target.id === 'skill-container')) {
            return; 
        }
        target = target.parentNode;
    }

    e.preventDefault();
    ZOOM += e.deltaY * -0.001;
    ZOOM = Math.max(0.3, Math.min(2.0, ZOOM));
    const indicator = document.getElementById('zoom-indicator');
    indicator.innerText = `x${ZOOM.toFixed(1)}`;
    indicator.style.opacity = 1;
    clearTimeout(window.zoomTimer);
    window.zoomTimer = setTimeout(() => indicator.style.opacity = 0, 1000);
}, { passive: false });

function toggleVoidMode() {
    const cb = document.getElementById('void-mode-cb');
    if(!cb) return; 
    setTimeout(() => {
        const active = cb.checked;
        state.isVoidMode = active;
        document.getElementById('void-mode-toggle').classList.toggle('active', active);
        if(active) document.body.classList.add('void-mode'); else document.body.classList.remove('void-mode');
    }, 10);
}

function openWeaponSelection() {
    document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
    document.getElementById('weapon-screen').classList.remove('hidden');
    
    const container = document.getElementById('weapon-cards');
    container.innerHTML = '';
    
    const pool = UPGRADES.filter(u => u.type === 'WEAPON' && u.id !== 'voidwalker' && u.id !== 'singularity');
    const selected = [];
    while(selected.length < 3 && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        selected.push(pool[idx]);
        pool.splice(idx, 1);
    }
    
    selected.forEach(w => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<div class="card-icon">${w.icon}</div><div class="card-title">${w.name}</div><div class="card-desc">${w.desc}</div><div class="card-type">WEAPON</div>`;
        card.onclick = () => selectStartWeapon(w.id);
        container.appendChild(card);
    });
}

function selectStartWeapon(weaponId) {
    state.startWeapon = weaponId;
    startGame();
}

function startGame() {
    document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
    document.getElementById('hud').classList.remove('hidden'); document.getElementById('joystick-zone').classList.remove('hidden');
    state.running = true; state.paused = false; state.gameOver = false; state.time = 0; state.score = 0; state.kills = 0; state.coins = 0; state.level = 1; state.xp = 0; state.nextLevelXp = 10;
    
    state.isVoidMode = document.getElementById('void-mode-cb').checked;
    if(state.isVoidMode) document.body.classList.add('void-mode'); else document.body.classList.remove('void-mode');

    // Reset State
    state.weapons = {};
    UPGRADES.forEach(u => {
        if(u.type === 'WEAPON' || u.type === 'HIDDEN') {
            state.weapons[u.id] = { level: 0, cd: 0, maxCd: 60, evolved: false };
        }
    });
    
    if(state.startWeapon && state.weapons[state.startWeapon]) {
        state.weapons[state.startWeapon].level = 1;
    } else {
        state.weapons.blaster.level = 1; 
    }

    state.sessionStats = { 
        sizeMult: 1, projectileCount: 0, projectileSpeed: 1, 
        areaMult: 1, durationMult: 1, knockbackMult: 1, 
        dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1, growth: 0
    };

    state.meta = { 
        reroll: saveData.upgrades.reroll || 0,
        skip: saveData.upgrades.skip || 0,
        banish: saveData.upgrades.banish || 0,
        banishedItems: []
    };

    state.ult = { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 };
    state.player = new Player(); 
    state.enemies = []; state.items = []; state.particles = []; state.projectiles = []; 
    state.popups = []; state.shockwaves = []; state.gravityWells = []; state.mines = []; state.drones = []; state.voidZones = []; state.ionBeams = []; state.worms = []; state.spikeBalls = []; state.hyperBeams = [];
    state.minions = []; state.poisonClouds = [];
    state.boss = null; state.bossLevel = 1;
    state.keys = { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
    
    state.stars = [];
    for(let i=0; i<100; i++) state.stars.push(new Star());

    updateHUD(); requestAnimationFrame(loop);
}

function loop() {
    if (!state.running) return;
    if (!state.paused) {
        // Reduced spawn rate: every 80 frames (1.3s) instead of 60, cap at 200
        if (state.time % 80 === 0 && state.enemies.length < 200) spawnEnemy();
        
        if (state.time === BOSS_SPAWN_TIME * 60 && !state.boss) spawnBoss();
        if (state.bossRespawnTimer > 0) {
            state.bossRespawnTimer--;
            if (state.bossRespawnTimer <= 0 && !state.boss) {
                spawnBoss();
                createPopup("WARNING!", state.player.x, state.player.y - 50, '#ff00ff');
            }
        }
        
        updateEvents();

        state.player.update();
        state.drones.forEach(d => d.update());
        for (let i = state.enemies.length - 1; i >= 0; i--) state.enemies[i].update(state.player);
        for (let i = state.projectiles.length - 1; i >= 0; i--) { 
            const p = state.projectiles[i]; 
            if(p.update()) { state.projectiles.splice(i, 1); continue; } 
            let hit = false;
            if (p.color === '#ff3333' && p.type === 'enemy_bullet') {
                if (Math.hypot(state.player.x - p.x, state.player.y - p.y) < state.player.size + p.size) {
                    state.player.takeDamage(p.dmg);
                    createExplosion(p.x, p.y, p.color, 3);
                    state.projectiles.splice(i, 1);
                    continue;
                }
            } else if (p.type !== 'enemy_bullet') {
                for (const e of state.enemies) { 
                    if (p.pierce && p.hitList.includes(e)) continue; 
                    if (Math.hypot(e.x - p.x, e.y - p.y) < e.size + p.size) { 
                        if(e.takeDamage(p.dmg, p.knockback, p.x, p.y)) removeEnemy(e); 
                        hit = true; 
                        if(p.onHit) p.onHit();
                        createExplosion(p.x, p.y, p.color, 3); 
                        if (!p.pierce) break; else p.hitList.push(e); 
                    } 
                } 
                if (hit && !p.pierce) state.projectiles.splice(i, 1); 
            }
        }
        for (let i = state.mines.length - 1; i >= 0; i--) { if(state.mines[i].update()) state.mines.splice(i, 1); }
        for (let i = state.voidZones.length - 1; i >= 0; i--) { if(state.voidZones[i].update()) state.voidZones.splice(i, 1); }
        for (let i = state.ionBeams.length - 1; i >= 0; i--) { if(state.ionBeams[i].update()) state.ionBeams.splice(i, 1); }
        for (let i = state.hyperBeams.length - 1; i >= 0; i--) { if(state.hyperBeams[i].update()) state.hyperBeams.splice(i, 1); }
        for (let i = state.poisonClouds.length - 1; i >= 0; i--) { if(state.poisonClouds[i].update()) state.poisonClouds.splice(i, 1); }
        
        updateWeapons(); 
        
        for(let i=state.gravityWells.length-1; i>=0; i--) {
            const g = state.gravityWells[i]; g.life--;
            for(const e of state.enemies) { const dx = g.x - e.x, dy = g.y - e.y, d = Math.hypot(dx, dy); if(d < g.range && d > 10) { e.x += (dx/d)*2; e.y += (dy/d)*2; if(g.life%10===0 && e.takeDamage(g.dmg)) removeEnemy(e); } }
            if(g.life%5===0) state.particles.push(new Particle(g.x, g.y, '#6600cc', 2, 10)); if(g.life <= 0) state.gravityWells.splice(i, 1);
        }

        for (let i = state.items.length - 1; i >= 0; i--) if (state.items[i].update(state.player)) state.items.splice(i, 1);
        for (let i = state.particles.length - 1; i >= 0; i--) if (state.particles[i].update()) state.particles.splice(i, 1);
        for (let i = state.popups.length - 1; i >= 0; i--) if (state.popups[i].update()) state.popups.splice(i, 1);
        for (let i = state.shockwaves.length - 1; i >= 0; i--) if (state.shockwaves[i].update()) state.shockwaves.splice(i, 1);
        state.time++; if (state.time % 60 === 0) updateHUD();
    }
    render(); requestAnimationFrame(loop);
}

function render() {
    ctx.fillStyle = state.isVoidMode ? '#1a0524' : '#050508'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Abyss Visual Change
    if(state.time > 1200) {
        ctx.fillStyle = `rgba(30, 0, 0, 0.2)`; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    state.stars.forEach(s => s.draw(ctx));

    if(!state.player) return;

    ctx.save(); const cx = canvas.width / 2, cy = canvas.height / 2; 
    
    if (state.shockwaves.length > 0) {
        const shake = Math.random() * 10 - 5;
        ctx.translate(shake, shake);
    }

    ctx.translate(cx, cy); ctx.scale(ZOOM, ZOOM); ctx.translate(-state.player.x, -state.player.y);
    
    // Grid
    ctx.strokeStyle = state.isVoidMode ? 'rgba(100, 0, 150, 0.2)' : 'rgba(50, 0, 100, 0.2)'; 
    ctx.lineWidth = 2; const gridSize = 100; const offX = Math.floor(state.player.x / gridSize) * gridSize, offY = Math.floor(state.player.y / gridSize) * gridSize;
    ctx.beginPath(); for (let x = offX - 1000/ZOOM; x < offX + 1000/ZOOM; x += gridSize) { ctx.moveTo(x, offY - 1000/ZOOM); ctx.lineTo(x, offY + 1000/ZOOM); } for (let y = offY - 1000/ZOOM; y < offY + 1000/ZOOM; y += gridSize) { ctx.moveTo(offX - 1000/ZOOM, y); ctx.lineTo(offX + 1000/ZOOM, y); } ctx.stroke();
    
    state.poisonClouds.forEach(c => c.draw(ctx));
    state.mines.forEach(m => m.draw(ctx));
    state.voidZones.forEach(z => z.draw(ctx));
    state.ionBeams.forEach(b => b.draw(ctx));
    state.hyperBeams.forEach(b => b.draw(ctx));
    state.items.forEach(i => i.draw(ctx)); 
    state.gravityWells.forEach(g => { ctx.beginPath(); ctx.arc(g.x, g.y, g.range, 0, Math.PI*2); ctx.strokeStyle='#6600cc'; ctx.stroke(); });
    state.enemies.forEach(e => e.draw(ctx)); 
    state.player.draw(ctx); 
    state.drones.forEach(d => d.draw(ctx));
    state.spikeBalls.forEach(b => b.draw(ctx));
    state.projectiles.forEach(p => p.draw(ctx)); 
    
    // Plasma Shield Rendering (Overlay)
    const w = state.weapons.plasma;
    if (w && w.level > 0) {
        const radius = 60 * state.sessionStats.sizeMult * state.sessionStats.areaMult;
        ctx.save();
        ctx.translate(state.player.x, state.player.y);
        ctx.rotate(w.angle);
        ctx.beginPath(); 
        ctx.arc(0, 0, radius, 0, Math.PI*2);
        ctx.strokeStyle = w.evolved ? 'rgba(255, 0, 255, 0.5)' : 'rgba(0, 255, 200, 0.5)';
        ctx.lineWidth = 4;
        ctx.stroke();
        
        const count = 1 + Math.floor(w.level / 3) + state.sessionStats.projectileCount;
        for(let i=0; i<count; i++) {
             const a = (Math.PI*2 * i / count);
             const sx = Math.cos(a) * radius;
             const sy = Math.sin(a) * radius;
             ctx.fillStyle = w.evolved ? '#ff00ff' : '#00ffcc';
             ctx.beginPath(); ctx.arc(sx, sy, 8, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }

    state.particles.forEach(p => p.draw(ctx)); 
    state.popups.forEach(p => p.draw(ctx)); 
    state.shockwaves.forEach(s => s.draw(ctx));
    
    ctx.restore();
}

function spawnEnemy() {
    const angle = Math.random() * Math.PI * 2, dist = 800 / ZOOM, x = state.player.x + Math.cos(angle) * dist, y = state.player.y + Math.sin(angle) * dist;
    let type = 'SQUARE'; const t = state.time / 60;
    const rand = Math.random();

    if (t > 120 && Math.random() < 0.02) { spawnWorm(x, y); return; }

    const isElite = Math.random() < 0.005; // 0.5% chance for elite

    // Late Game Abyss Mobs
    if (t > 20 && rand < 0.01) type = 'ABYSS_KNIGHT';

    if (t > 180 && rand < 0.05) type = 'SNIPER';
    else if (t > 180 && rand < 0.05) type = 'STALKER';
    else if (t > 180 && rand < 0.02) type = 'TITAN';
    else if (t > 180 && rand < 0.1) type = 'OCTAGON'; 
    else if (t > 120 && rand < 0.15) type = 'TANK';
    else if (t > 120 && rand < 0.2) type = 'RHOMBUS'; 
    else if (t > 90 && rand < 0.1) type = 'SHOOTER';
    else if (t > 60 && rand < 0.05) type = 'DASHER';
    else if (t > 60 && rand < 0.05) type = 'BAT';
    else if (t > 60 && rand < 0.05) type = 'SPLITTER';
    else if (t > 60 && rand < 0.1) type = 'VOLATILE';
    else if (t > 90 && rand < 0.05) type = 'SUMMONER';
    else if (t > 60 && rand < 0.05) type = 'MIMIC';
    else if (t > 60 && rand < 0.3) type = 'PENTAGON'; 
    else if (t > 30 && rand < 0.4) type = 'TRIANGLE';

    if (t > 90 && Math.random() < 0.05) for(let i=0; i<10; i++) state.enemies.push(new Enemy('SWARM', x + Math.random()*50, y + Math.random()*50, false)); 
    else state.enemies.push(new Enemy(type, x, y, isElite));
}
function spawnBoss() { 
    const angle = Math.random() * Math.PI * 2, dist = 600, x = state.player.x + Math.cos(angle) * dist, y = state.player.y + Math.sin(angle) * dist; 
    state.boss = new Boss(x, y); state.enemies.push(state.boss); 
    document.getElementById('boss-hud').classList.add('active'); 
}
function removeEnemy(e) { const idx = state.enemies.indexOf(e); if (idx > -1) state.enemies.splice(idx, 1); if (e instanceof Boss) { e.die(); } }
function addXp(amt) { 
    const xpBoost = 1 + ((saveData.upgrades.xp || 0) * 0.1);
    state.xp += amt * xpBoost; 
    if (state.xp >= state.nextLevelXp) { 
        state.xp -= state.nextLevelXp; 
        state.level++; 
        // Increased scaling logic: 1.4 multiplier + 50 flat
        state.nextLevelXp = Math.floor(state.nextLevelXp * 1.4 + 50); 
        showUpgradeScreen(); 
    } 
    updateHUD(); 
}
function updateHUD() {
    document.getElementById('xp-bar').style.width = `${(state.xp / state.nextLevelXp) * 100}%`; 
    
    const hpPct = Math.max(0, Math.min(100, (state.player.hp / state.player.maxHp) * 100));
    document.getElementById('hp-bar').style.width = `${hpPct}%`;
    document.getElementById('hp-text').innerText = `${Math.ceil(Math.max(0, state.player.hp))} / ${Math.ceil(state.player.maxHp)}`;

    document.getElementById('level-display').innerText = state.level; document.getElementById('kill-display').innerText = state.kills; document.getElementById('coin-display').innerText = state.coins;
    
    // Update Gold on Start Screen as well
    const startGold = document.getElementById('start-screen-gold');
    if(startGold) startGold.innerText = saveData.coins;

    const m = Math.floor(state.time / 3600), s = Math.floor((state.time % 3600) / 60); document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    if(state.boss) document.getElementById('boss-hp-fill').style.width = `${(state.boss.hp / state.boss.maxHp) * 100}%`;
}

// System Upgrade Logic (with Reroll/Skip/Banish)
let isBanishMode = false;

function showUpgradeScreen() {
    state.paused = true; const container = document.getElementById('upgrade-cards'); container.innerHTML = '';
    document.getElementById('upgrade-screen').classList.remove('hidden'); document.getElementById('joystick-zone').classList.add('hidden');
    isBanishMode = false; updateMetaButtons();
    
    // Check evolutions
    let hasEvolution = false;
    for (const evo of EVOLUTIONS) {
        if (state.weapons[evo.weapon] && !state.weapons[evo.weapon].evolved && state.weapons[evo.weapon].level >= 5) {
            if (Math.random() < 0.4) {
                const card = document.createElement('div'); card.className = 'card evolution'; 
                card.innerHTML = `<div class="card-icon">${evo.icon}</div><div class="card-title">${evo.name}</div><div class="card-desc">${evo.desc}</div><div class="card-type">EVOLUTION</div>`; 
                card.onclick = () => selectUpgrade(evo.evolveTo); container.appendChild(card); 
                hasEvolution = true;
                break; 
            }
        }
    }
    if (hasEvolution) return;

    let choices = [];
    const pool = UPGRADES.filter(u => !state.meta.banishedItems.includes(u.id));
    const hiddenChance = (saveData.upgrades.luck || 0) * 0.05 + 0.01;
    
    for(let i=0; i<3; i++) {
        let u;
        if (state.level >= 15 && Math.random() < hiddenChance) { u = pool.find(x => x.type === 'HIDDEN'); }
        if (!u) {
            const commonPool = pool.filter(x => x.type !== 'HIDDEN');
            if(commonPool.length > 0) u = commonPool[Math.floor(Math.random() * commonPool.length)];
        }
        
        if (u) {
            choices.push(u);
            const card = document.createElement('div'); 
            card.className = u.type === 'HIDDEN' ? 'card hidden-tier' : 'card';
            
            let lvlInfo = '';
            if(u.type === 'WEAPON' || u.type === 'HIDDEN') lvlInfo = `(Lv.${state.weapons[u.id]?.level || 0})`;

            card.innerHTML = `<div class="card-icon">${u.icon}</div><div class="card-title">${u.name}</div><div class="card-desc">${u.desc} ${lvlInfo}</div><div class="card-type">${u.type}</div>`;
            card.onclick = () => {
                if(isBanishMode) {
                    if(state.meta.banish > 0) {
                        state.meta.banish--;
                        state.meta.banishedItems.push(u.id);
                        toggleBanishMode(); 
                        showUpgradeScreen(); 
                    }
                } else {
                    selectUpgrade(u.id);
                }
            };
            container.appendChild(card);
        }
    }
}

function updateMetaButtons() {
    document.getElementById('cnt-reroll').innerText = state.meta.reroll;
    document.getElementById('cnt-skip').innerText = state.meta.skip;
    document.getElementById('cnt-banish').innerText = state.meta.banish;
    
    document.getElementById('btn-reroll').disabled = state.meta.reroll <= 0;
    document.getElementById('btn-skip').disabled = state.meta.skip <= 0;
    document.getElementById('btn-banish').disabled = state.meta.banish <= 0;
    
    const sub = document.getElementById('upgrade-subtitle');
    if(isBanishMode) { sub.innerText = "Ï†úÏô∏Ìï† Ìï≠Î™©ÏùÑ ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§ (Ïù¥Î≤à Í≤åÏûÑ Îì±Ïû• X)"; sub.style.color = '#ff3333'; }
    else { sub.innerText = "Í∞ïÌôî Î™®ÎìàÏùÑ ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§"; sub.style.color = '#888'; }
}

function doReroll() {
    if(state.meta.reroll > 0) { state.meta.reroll--; showUpgradeScreen(); }
}
function doSkip() {
    if(state.meta.skip > 0) { 
        state.meta.skip--; 
        state.xp += state.nextLevelXp * 0.2; 
        document.getElementById('upgrade-screen').classList.add('hidden'); document.getElementById('joystick-zone').classList.remove('hidden'); state.paused = false;
    }
}
function toggleBanishMode() {
    isBanishMode = !isBanishMode;
    updateMetaButtons();
}

function selectUpgrade(id) {
    if (id === 'heal') state.player.hp = Math.min(state.player.hp + state.player.maxHp * 0.5, state.player.maxHp);
    else if (id === 'giant') state.sessionStats.sizeMult += 0.15;
    else if (id === 'multishot') state.sessionStats.projectileCount += 1;
    else if (id === 'sniper') state.sessionStats.projectileSpeed += 0.2;
    else if (id === 'area') state.sessionStats.areaMult += 0.15;
    else if (id === 'duration') state.sessionStats.durationMult += 0.15;
    else if (id === 'knockback') state.sessionStats.knockbackMult += 0.2;
    else if (id === 'armor') state.sessionStats.armor += 1;
    else if (id === 'dash_cd') state.sessionStats.dashCdMult *= 0.9;
    else if (id === 'pickup') state.sessionStats.pickupRangeMult += 0.3;
    else if (id === 'greed') state.sessionStats.greedMult += 0.2;
    else if (id === 'growth') { state.sessionStats.growth += 0.05; state.player.maxHp *= 1.05; state.player.hp += 10; }
    
    else if (id === 'exterminator') { state.weapons.blaster.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'blackhole') { state.weapons.orbit.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'thundergod') { state.weapons.tesla.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'nuke') { state.weapons.missile.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'soulreaper') { state.weapons.blade.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'orbital_strike') { state.weapons.ion.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'blizzard') { state.weapons.frost.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#00ccff'); }
    else if (id === 'apocalypse') { state.weapons.meteor.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff4400'); }
    else if (id === 'supernova') { state.weapons.starfall.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ffff00'); }
    else if (id === 'lichking') { state.weapons.necro.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ffffff'); }
    else if (id === 'venomstorm') { state.weapons.poison.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#00ff00'); }
    
    else if (state.weapons[id]) state.weapons[id].level++;
    
    document.getElementById('upgrade-screen').classList.add('hidden'); document.getElementById('joystick-zone').classList.remove('hidden'); state.paused = false;
}

function togglePause() { 
    if (!state.running) return; state.paused = !state.paused; 
    if (state.paused) { 
        document.getElementById('pause-screen').classList.remove('hidden'); document.getElementById('joystick-zone').classList.add('hidden'); 
        document.getElementById('pause-dmg').innerText = Math.round(state.player.dmgMult * 100) + '%';
        document.getElementById('pause-area').innerText = Math.round(state.sessionStats.areaMult * 100) + '%';
        document.getElementById('pause-spd').innerText = Math.round(state.player.speed * 100 / 3) + '%';
        document.getElementById('pause-crit').innerText = Math.round(state.player.critChance * 100) + '%';
        document.getElementById('pause-greed').innerText = '+' + Math.round((state.sessionStats.greedMult - 1 + saveData.upgrades.greed*0.2) * 100) + '%';
    } else { 
        document.getElementById('pause-screen').classList.add('hidden'); document.getElementById('joystick-zone').classList.remove('hidden'); 
    } 
}
function quitGame() { saveData.coins += Math.floor(state.coins); save(); state.running = false; showStartScreen(); }
function showStartScreen() { 
    document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden')); 
    document.getElementById('start-screen').classList.remove('hidden'); 
    document.getElementById('joystick-zone').classList.add('hidden');
    
    // Update Gold Display on Start Screen
    const startGold = document.getElementById('start-screen-gold');
    if(startGold) startGold.innerText = saveData.coins;
}
function endGame() { 
    state.running = false; document.getElementById('hud').classList.add('hidden'); document.getElementById('joystick-zone').classList.add('hidden'); document.getElementById('game-over-screen').classList.remove('hidden'); 
    const duration = state.time; saveData.stats.maxTime = Math.max(saveData.stats.maxTime, duration/60);
    saveData.coins += state.coins; save();
    const m = Math.floor(state.time / 3600), s = Math.floor((state.time % 3600) / 60); 
    document.getElementById('final-score').innerText = `ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${m}:${s}`; 
    document.getElementById('final-coins').innerText = `ÌöçÎìù: ${state.coins} ü™ô`; 
}
function restartGame() { openWeaponSelection(); }

// Menus
function openArmory() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('armory-screen').classList.remove('hidden'); renderArmory(); }
function closeArmory() { document.getElementById('armory-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderArmory() {
    document.getElementById('armory-currency').innerText = saveData.coins; const container = document.getElementById('armory-container'); container.innerHTML = '';
    const gears = [
        { id: 'weapon', name: 'ÌîåÎùºÏ¶àÎßà ÎùºÏù¥Ìîå', desc: 'Í≥µÍ≤©Î†• +20%', icon: 'üî´' }, 
        { id: 'armor', name: 'ÎÇòÎÖ∏ ÏäàÌä∏', desc: 'ÏµúÎåÄ Ï≤¥Î†• +20', icon: 'üõ°Ô∏è' }, 
        { id: 'boots', name: 'Ï†úÌä∏ Î∂ÄÏ∏†', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5% / Ïø®ÌÉÄÏûÑ -2%', icon: 'ü•æ' },
        { id: 'helmet', name: 'Ï†ÑÏà† Ìó¨Î©ß', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%', icon: '‚õëÔ∏è' },
        { id: 'gloves', name: 'ÌååÏõå Ïû•Í∞ë', desc: 'Ïø®ÌÉÄÏûÑ Í∞êÏÜå +2%', icon: 'ü•ä' },
        { id: 'ring', name: 'Í≥†ÎåÄ Î∞òÏßÄ', desc: 'Í≥®Îìú ÌöçÎìù +10%', icon: 'üíç' }
    ];
    gears.forEach(g => { const lvl = saveData.equipment[g.id] || 0; const cost = 25 * (lvl + 1); const div = document.createElement('div'); div.className = 'shop-item'; div.innerHTML = `<h3 style="font-size:1.5rem">${g.icon}</h3><h3>${g.name} (Lv.${lvl})</h3><p>${g.desc}</p><button class="btn" style="font-size:0.85rem;" onclick="upgradeEquipment('${g.id}', ${cost})">${cost} ü™ô</button>`; container.appendChild(div); });
}
function upgradeEquipment(id, cost) { if(saveData.coins >= cost) { saveData.coins -= cost; if(!saveData.equipment[id]) saveData.equipment[id]=0; saveData.equipment[id]++; save(); renderArmory(); } else alert('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'); }

function openWardrobe() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('wardrobe-screen').classList.remove('hidden'); renderWardrobe(); }
function closeWardrobe() { document.getElementById('wardrobe-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderWardrobe() {
    const c = document.getElementById('skin-container'); c.innerHTML = '';
    SKINS.forEach(s => {
        const owned = saveData.ownedSkins.includes(s.id); const d = document.createElement('div'); d.className = 'skin-item' + (saveData.currentSkin === s.id ? ' selected' : '') + (!owned ? ' locked' : '');
        d.innerHTML = `<div class="skin-preview">${s.icon}</div><div class="skin-name">${s.name}</div>${!owned?'<div class="lock-icon">üîí</div>':''}`;
        if(owned) d.onclick = () => selectSkin(s.id); c.appendChild(d);
    });
}
function selectSkin(id) { saveData.currentSkin = id; save(); renderWardrobe(); }

function openArtifactScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('artifact-screen').classList.remove('hidden'); renderArtifacts(); }
function closeArtifactScreen() { document.getElementById('artifact-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderArtifacts() {
    const container = document.getElementById('artifact-container'); container.innerHTML = '';
    ARTIFACTS.forEach(art => {
        const lvl = saveData.artifacts[art.id] || 0;
        const owned = lvl > 0;
        const card = document.createElement('div'); card.className = owned ? 'card' : 'card locked';
        if (owned) {
            card.innerHTML = `<div class="card-icon">${art.icon}</div><div class="card-title">${art.name}</div><div class="card-desc">${art.desc}</div><div class="card-type">LV.${lvl}</div>`;
        } else {
            card.innerHTML = `<div class="card-icon">‚ùì</div><div class="card-title">???</div><div class="card-desc">Ïû†ÍπÄ</div><div class="card-type">LOCKED</div>`;
        }
        container.appendChild(card);
    });
}

function openAchieveScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('achieve-screen').classList.remove('hidden'); renderAchievements(); }
function closeAchieveScreen() { document.getElementById('achieve-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderAchievements() {
    document.getElementById('achieve-currency').innerText = saveData.coins; 
    const container = document.getElementById('achieve-container'); container.innerHTML = '';
    ACHIEVEMENTS.forEach(ach => {
        const completed = ach.check(saveData.stats);
        const claimed = saveData.achievements.includes(ach.id);
        const item = document.createElement('div');
        item.className = 'achieve-item' + (completed ? ' completed' : '');
        let btnHtml = '';
        if (completed) {
            if (claimed) btnHtml = `<button class="btn btn-claim" disabled>ÏôÑÎ£åÎê®</button>`;
            else btnHtml = `<button class="btn btn-claim" onclick="claimAchievement('${ach.id}')">Î≥¥ÏÉÅ Î∞õÍ∏∞</button>`;
        } else { btnHtml = `<button class="btn btn-claim" disabled>ÏßÑÌñâ Ï§ë</button>`; }
        item.innerHTML = `<div class="achieve-info"><div class="achieve-title">${ach.name}</div><div class="achieve-desc">${ach.desc}</div><div class="achieve-reward">üèÜ ${ach.reward} ü™ô</div></div>${btnHtml}`;
        container.appendChild(item);
    });
}
function claimAchievement(id) {
    const ach = ACHIEVEMENTS.find(a => a.id === id);
    if (ach && !saveData.achievements.includes(id)) {
        saveData.coins += ach.reward; saveData.achievements.push(id); save(); renderAchievements(); alert(`${ach.reward} ÏΩîÏù∏ÏùÑ ÌöçÎìùÌñàÏäµÎãàÎã§!`);
    }
}

function openShop() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('shop-screen').classList.remove('hidden'); renderShop(); }
function closeShop() { document.getElementById('shop-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderShop() {
    document.getElementById('shop-currency').innerText = saveData.coins; const container = document.getElementById('shop-container'); container.innerHTML = '';
    const items = [
        { id: 'damage', name: 'Í∏∞Ï¥à Í≥µÍ≤©Ìïô', desc: 'Í≥µÍ≤©Î†• +10%' }, { id: 'health', name: 'Ï≤¥Î†• Îã®Î†®', desc: 'ÏµúÎåÄ Ï≤¥Î†• +10' }, { id: 'speed', name: 'Í∏∞ÎèôÏÑ± ÌõàÎ†®', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5%' }, { id: 'greed', name: 'ÌÉêÏöïÏùò ÏãúÏÑ†', desc: 'Í≥®Îìú ÌöçÎìùÎüâ +10%' },
        { id: 'cooldown', name: 'Îπ†Î•∏ Ïû•Ï†Ñ', desc: 'Ïø®ÌÉÄÏûÑ -5%' }, { id: 'crit', name: 'ÏπòÎ™ÖÌÉÄ Ïó∞Îßà', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%' }, { id: 'luck', name: 'ÌñâÏö¥', desc: 'Ï¢ãÏùÄ ÏïÑÏù¥ÌÖú ÌôïÎ•† Ï¶ùÍ∞Ä' }, { id: 'evasion', name: 'ÌöåÌîºÏà†', desc: 'ÌöåÌîºÏú® +5%' },
        { id: 'xp', name: 'ÌïôÏäµ Îä•Î†•', desc: 'Í≤ΩÌóòÏπò ÌöçÎìù +10%' }, { id: 'duration', name: 'ÏßÄÏÜçÏÑ±', desc: 'Ìö®Í≥º ÏßÄÏÜçÏãúÍ∞Ñ +10%' }, { id: 'regen', name: 'ÏûêÏó∞ ÏπòÏú†', desc: '3Ï¥àÎßàÎã§ Ï≤¥Î†• 1 ÌöåÎ≥µ' }, { id: 'revive', name: 'Î∂àÍµ¥Ïùò ÏùòÏßÄ', desc: 'ÏÇ¨Îßù Ïãú 1Ìöå Î∂ÄÌôú' },
        { id: 'armor', name: 'Ìã∞ÌÉÄÎäÑ ÏΩîÌåÖ', desc: 'ÌîºÌï¥ Í∞êÏÜå +1' }, { id: 'knockback', name: 'Ï∂©Í≤© Ï¶ùÌè≠Í∏∞', desc: 'ÎÑâÎ∞± +20%' },
        { id: 'reroll', name: 'Î¶¨Î°§ Î™®Îìà', desc: 'ÏãúÏûë Ïãú Î¶¨Î°§ +1Ìöå' }, { id: 'skip', name: 'Ïä§ÌÇµ Î™®Îìà', desc: 'ÏãúÏûë Ïãú Ïä§ÌÇµ +1Ìöå' }, { id: 'banish', name: 'Î∞∞ÎãàÏãú Î™®Îìà', desc: 'ÏãúÏûë Ïãú Î∞∞ÎãàÏãú +1Ìöå' },
        { id: 'growth', name: 'ÏÑ±Ïû•Ìåê', desc: 'Î†àÎ≤®ÏóÖ Ïãú Ï≤¥Î†•/ÏµúÎåÄÏ≤¥Î†• Ï¶ùÍ∞Ä' }, { id: 'magnet', name: 'ÏûêÎ†• ÏΩîÏùº', desc: 'ÌöçÎìù Î∞òÍ≤Ω ÏòÅÍµ¨ Ï¶ùÍ∞Ä' }
    ];
    items.forEach(item => { 
        const lvl = saveData.upgrades[item.id] || 0; 
        const cost = SHOP_BASE_COST * (lvl + 1) * (['revive','reroll','skip','banish'].includes(item.id) ? 10 : 1); 
        const div = document.createElement('div'); div.className = 'shop-item'; 
        div.innerHTML = `<h3>${item.name} (Lv.${lvl})</h3><p>${item.desc}</p><button class="btn" style="font-size:0.85rem;" onclick="buyUpgrade('${item.id}', ${cost})">${cost} ü™ô</button>`; 
        container.appendChild(div); 
    });
}
function buyUpgrade(id, cost) { if (saveData.coins >= cost) { saveData.coins -= cost; saveData.upgrades[id] = (saveData.upgrades[id] || 0) + 1; save(); renderShop(); } else alert('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'); }

function openGacha() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('gacha-screen').classList.remove('hidden'); document.getElementById('gacha-currency').innerText = saveData.coins; document.getElementById('gacha-result').style.display = 'none'; document.getElementById('gacha-buttons').style.display = 'flex'; }
function closeGacha() { document.getElementById('gacha-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function rollGacha() { if(saveData.coins < GACHA_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; } saveData.coins -= GACHA_COST; document.getElementById('gacha-currency').innerText = saveData.coins; const art = ARTIFACTS[Math.floor(Math.random() * ARTIFACTS.length)]; if (!saveData.artifacts[art.id]) saveData.artifacts[art.id] = 0; saveData.artifacts[art.id]++; save(); showGachaResult(art.icon, art.name, `${art.desc}\n(ÌòÑÏû¨ Lv.${saveData.artifacts[art.id]})`); }
function rollSkinGacha() { if(saveData.coins < SKIN_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; } saveData.coins -= SKIN_COST; document.getElementById('gacha-currency').innerText = saveData.coins; const skin = SKINS[Math.floor(Math.random() * SKINS.length)]; if (saveData.ownedSkins.includes(skin.id)) { const refund = Math.floor(SKIN_COST * 0.5); saveData.coins += refund; showGachaResult(skin.icon, skin.name, `Ïù¥ÎØ∏ Î≥¥Ïú†Ï§ëÏûÖÎãàÎã§!\n${refund}ü™ô ÌôòÍ∏âÎê®.`); } else { saveData.ownedSkins.push(skin.id); showGachaResult(skin.icon, skin.name, "ÏÉàÎ°úÏö¥ Ïä§ÌÇ® ÌöçÎìù!"); } save(); }
function showGachaResult(icon, name, desc) { document.getElementById('gacha-buttons').style.display = 'none'; const res = document.getElementById('gacha-result'); res.style.display = 'flex'; document.getElementById('g-icon').innerText = icon; document.getElementById('g-name').innerText = name; document.getElementById('g-desc').innerText = desc; }
function closeGachaResult() { document.getElementById('gacha-result').style.display = 'none'; document.getElementById('gacha-buttons').style.display = 'flex'; }
function openSettings() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('settings-screen').classList.remove('hidden'); }
function closeSettings() { document.getElementById('settings-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function openClassScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('class-screen').classList.remove('hidden'); renderClasses(); }
function closeClassScreen() { document.getElementById('class-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderClasses() {
    document.getElementById('class-currency').innerText = saveData.coins; const container = document.getElementById('class-container'); container.innerHTML = '';
    CLASSES.forEach(cls => {
        const owned = saveData.ownedClasses.includes(cls.id); const selected = saveData.currentClass === cls.id;
        const div = document.createElement('div'); div.className = 'shop-item' + (selected ? ' selected' : '');
        let btnHtml = selected ? `<button class="btn btn-secondary" disabled>Ïû•Ï∞© Ï§ë</button>` : owned ? `<button class="btn" onclick="selectClass('${cls.id}')">ÏÑ†ÌÉù</button>` : `<button class="btn btn-accent" onclick="buyClass('${cls.id}', ${cls.cost})">${cls.cost} ü™ô</button>`;
        div.innerHTML = `<h3 style="font-size:1.5rem">${cls.icon}</h3><h3>${cls.name}</h3><p>${cls.desc}</p><div style="margin-bottom:10px; display:flex; gap:5px; flex-wrap:wrap; justify-content:center;">${cls.stats.hp!==0?`<span class="class-badge">HP ${cls.stats.hp>0?'+':''}${cls.stats.hp}</span>`:''}${cls.stats.dmg!==0?`<span class="class-badge">DMG ${cls.stats.dmg*100}%</span>`:''}${cls.stats.spd!==0?`<span class="class-badge">SPD ${cls.stats.spd}</span>`:''}${cls.stats.cd!==0?`<span class="class-badge">CDR ${cls.stats.cd*100}%</span>`:''}</div><div class="selected-check">‚úÖ</div>${btnHtml}`;
        container.appendChild(div);
    });
}
function selectClass(id) { saveData.currentClass = id; save(); renderClasses(); }
function buyClass(id, cost) { if(saveData.coins >= cost) { saveData.coins -= cost; saveData.ownedClasses.push(id); saveData.currentClass = id; save(); renderClasses(); } else alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); }

function openSkillScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('skill-screen').classList.remove('hidden'); renderSkills(); }
function closeSkillScreen() { document.getElementById('skill-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderSkills() {
    const container = document.getElementById('skill-container'); container.innerHTML = '';
    if(!saveData.ownedUlts) saveData.ownedUlts = ['nuclear'];
    if(!saveData.currentUlt) saveData.currentUlt = 'nuclear';
    
    ULTIMATES.forEach(ult => {
        const owned = saveData.ownedUlts.includes(ult.id);
        const selected = saveData.currentUlt === ult.id;
        const div = document.createElement('div'); 
        div.className = 'ult-card' + (selected ? ' selected' : '');
        div.onclick = () => { saveData.currentUlt = ult.id; save(); renderSkills(); };
        div.innerHTML = `<div class="ult-icon-l">${ult.icon}</div><div style="flex:1"><div style="font-weight:bold; font-size:1.1rem; color:${ult.color}">${ult.name}</div><div style="font-size:0.8rem; color:#aaa;">${ult.desc}</div></div>${selected ? '<div style="color:#0f0; font-weight:bold;">EQUIPPED</div>' : ''}`;
        container.appendChild(div);
    });
}

// Input Handling
const joyZone = document.getElementById('joystick-zone'), joyBase = document.getElementById('joystick-base'), joyKnob = document.getElementById('joystick-knob');
joyZone.addEventListener('pointerdown', e => {
    e.preventDefault(); state.pointer.down = true; state.pointer.id = e.pointerId; state.pointer.x = e.clientX; state.pointer.y = e.clientY;
    state.joystick.active = true; state.joystick.originX = e.clientX; state.joystick.originY = e.clientY;
    joyBase.style.display = 'block'; joyKnob.style.display = 'block';
    joyBase.style.left = e.clientX + 'px'; joyBase.style.top = e.clientY + 'px'; joyKnob.style.left = e.clientX + 'px'; joyKnob.style.top = e.clientY + 'px';
    const now = Date.now(); if (now - state.lastTap < 300) { if (state.player) state.player.dash(); } state.lastTap = now;
});
window.addEventListener('pointermove', e => {
    if (!state.pointer.down || e.pointerId !== state.pointer.id) return; e.preventDefault();
    const maxDist = 60, dx = e.clientX - state.joystick.originX, dy = e.clientY - state.joystick.originY, dist = Math.sqrt(dx*dx + dy*dy);
    let kx = dx, ky = dy; if (dist > maxDist) { kx = (dx / dist) * maxDist; ky = (dy / dist) * maxDist; }
    joyKnob.style.left = (state.joystick.originX + kx) + 'px'; joyKnob.style.top = (state.joystick.originY + ky) + 'px';
    state.joystick.dx = kx / maxDist; state.joystick.dy = ky / maxDist;
});
window.addEventListener('pointerup', e => { if (e.pointerId !== state.pointer.id) return; e.preventDefault(); state.pointer.down = false; state.joystick.active = false; state.joystick.dx = 0; state.joystick.dy = 0; joyBase.style.display = 'none'; joyKnob.style.display = 'none'; });
window.addEventListener('keydown', e => { 
    if(e.code === 'Space') state.player?.dash(); 
    if(e.key.toLowerCase() === 'w') state.keys.w = true; if(e.key.toLowerCase() === 'a') state.keys.a = true; if(e.key.toLowerCase() === 's') state.keys.s = true; if(e.key.toLowerCase() === 'd') state.keys.d = true; 
    if(e.key === 'ArrowUp') state.keys.ArrowUp = true; if(e.key === 'ArrowLeft') state.keys.ArrowLeft = true; if(e.key === 'ArrowDown') state.keys.ArrowDown = true; if(e.key === 'ArrowRight') state.keys.ArrowRight = true;
    if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { 
    if(e.key.toLowerCase() === 'w') state.keys.w = false; if(e.key.toLowerCase() === 'a') state.keys.a = false; if(e.key.toLowerCase() === 's') state.keys.s = false; if(e.key.toLowerCase() === 'd') state.keys.d = false; 
    if(e.key === 'ArrowUp') state.keys.ArrowUp = false; if(e.key === 'ArrowLeft') state.keys.ArrowLeft = false; if(e.key === 'ArrowDown') state.keys.ArrowDown = false; if(e.key === 'ArrowRight') state.keys.ArrowRight = false;
});

// Call showStartScreen to update gold
showStartScreen();
</script>
</body>
</html>