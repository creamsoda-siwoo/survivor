<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IFKO SURVIVOR</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåå</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Exo+2:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ffcc;
            --primary-dark: #00cc99;
            --accent: #ff0099;
            --accent-dark: #cc0077;
            --gold: #ffd700;
            --void: #9d00ff;
            --bg: #050508;
            --glass: rgba(20, 20, 30, 0.9);
            --border: rgba(255, 255, 255, 0.15);
            --font: 'Noto Sans KR', 'Exo 2', sans-serif;
        }

        body.void-mode {
            --primary: #bc13fe;
            --primary-dark: #8a0bbd;
            --bg: #1a0524;
        }

        /* Mobile Scroll Fix: Only disable touch action on body/canvas, allow it elsewhere */
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        
        body {
            margin: 0; padding: 0; background-color: #000; color: white;
            font-family: var(--font); overflow: hidden;
            display: flex; justify-content: center; align-items: center; height: 100vh;
            touch-action: none; /* Prevent bounce on body */
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            background: var(--bg); overflow: hidden; transition: background 0.5s;
        }

        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; touch-action: none; }

        /* Effects */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 15; opacity: 0.3;
        }
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 16;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; z-index: 20;
        }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }

        /* HUD */
        #hud { padding: 15px; justify-content: space-between; height: 100%; z-index: 30; }
        .top-row { 
            display: flex; flex-direction: column; align-items: center; width: 100%; pointer-events: none; 
        }
        
        .stat-box {
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid var(--border); backdrop-filter: blur(4px);
            display: flex; align-items: center; gap: 15px;
            pointer-events: auto;
        }
        .stat-text { font-size: 0.9rem; font-weight: 700; display: flex; gap: 10px; align-items: center; }
        
        .bar-container {
            background: rgba(0,0,0,0.5); border-radius: 5px;
            overflow: hidden; position: relative;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .bar-fill { height: 100%; transition: width 0.2s ease-out; border-radius: 5px; }
        #hp-bar { background: linear-gradient(90deg, #ff3333, #ff6666); width: 100%; box-shadow: 0 0 8px rgba(255,51,51,0.5); }
        #xp-bar { background: linear-gradient(90deg, #00ccff, #33ffff); width: 0%; box-shadow: 0 0 8px rgba(51,255,255,0.5); }

        #timer {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 1.8rem; font-weight: 900; color: #fff;
            text-shadow: 0 0 15px rgba(0,0,0,0.8); letter-spacing: 2px; font-family: 'Exo 2';
        }

        #pause-btn {
            width: 45px; height: 45px; background: var(--glass);
            border: 1px solid var(--border); border-radius: 12px;
            color: white; font-size: 1.2rem; display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #pause-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.1); }

        /* Ultimate Button */
        #ult-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 90px; height: 90px; border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.8);
            background: radial-gradient(circle, #ff0099, #550033);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 0 30px rgba(255,0,153,0.8);
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #ult-btn.ready {
            animation: pulse-ult 1.5s infinite;
            border-color: #fff;
            box-shadow: 0 0 40px #ff0099;
        }
        @keyframes pulse-ult {
            0% { transform: scale(1); box-shadow: 0 0 20px rgba(255,0,153,0.6); }
            50% { transform: scale(1.1); box-shadow: 0 0 50px rgba(255,0,153,1); }
            100% { transform: scale(1); box-shadow: 0 0 20px rgba(255,0,153,0.6); }
        }
        #ult-btn:active { transform: scale(0.95); }
        #ult-btn.disabled { filter: grayscale(1) brightness(0.4); box-shadow: none; border-color: #333; cursor: not-allowed; animation: none; }
        #ult-icon { font-size: 2.2rem; }
        #ult-label { font-size: 0.7rem; font-weight: bold; margin-top: -2px; }

        /* Boss HUD */
        #boss-hud {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 500px; opacity: 0; transition: opacity 0.5s;
            display: flex; flex-direction: column; align-items: center;
        }
        #boss-hud.active { opacity: 1; }
        #boss-name { color: #bc13fe; font-weight: 900; font-size: 1rem; margin-bottom: 5px; letter-spacing: 3px; text-shadow: 0 0 10px #bc13fe; }
        #boss-hp-container { width: 100%; height: 20px; background: rgba(0,0,0,0.8); border: 2px solid #4a0b63; border-radius: 4px; overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #9d00ff, #bc13fe); box-shadow: 0 0 10px #9d00ff; }

        /* Event HUD */
        #event-hud {
            position: absolute; top: 150px; width: 100%; text-align: center;
            font-size: 1.5rem; font-weight: 900; color: #ffd700;
            text-shadow: 0 0 10px #ff3300; display: none; z-index: 35;
            animation: pulse 1s infinite;
        }

        /* Common Menu Styles */
        .menu-screen {
            background: rgba(8, 8, 12, 0.98);
            justify-content: center; align-items: center; text-align: center;
            backdrop-filter: blur(10px); z-index: 50;
            touch-action: auto; /* Allow touch in menus */
        }
        
        .screen-title {
            font-size: 2.5rem; margin: 0 0 5px 0;
            background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; color: transparent;
            font-family: 'Exo 2'; font-style: italic; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        .screen-subtitle { color: #888; margin-bottom: 25px; font-size: 0.9rem; letter-spacing: 1px; }

        /* Buttons */
        .btn {
            padding: 12px 24px; font-size: 1rem;
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            border: none; border-radius: 8px;
            color: #000; font-family: var(--font); font-weight: 900;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            position: relative; overflow: hidden;
            min-width: 140px;
        }
        .btn::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent); pointer-events: none;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 255, 204, 0.5); filter: brightness(1.1); }
        .btn:active { transform: translateY(1px); box-shadow: 0 2px 10px rgba(0, 255, 204, 0.3); }

        .btn-secondary {
            background: linear-gradient(135deg, #333, #444); color: #ccc;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn-secondary:hover { box-shadow: 0 6px 15px rgba(0,0,0,0.7); color: #fff; }
        
        .btn-danger {
            background: linear-gradient(135deg, #990033, #ff3333); color: white;
            box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent-dark), var(--accent)); color: white;
            box-shadow: 0 4px 15px rgba(255, 0, 153, 0.3);
        }
        .btn-accent:hover { box-shadow: 0 6px 20px rgba(255, 0, 153, 0.5); }

        .btn-small { padding: 5px 10px; font-size: 0.8rem; min-width: auto; }

        /* Menu Grid */
        .menu-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;
            max-width: 500px; width: 100%; margin-bottom: 20px;
        }
        .menu-grid .btn { width: 100%; padding: 10px; font-size: 0.9rem; }

        /* Upgrade Cards */
        .card-container {
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
            padding: 20px; max-height: 70vh; overflow-y: auto; width: 100%;
            touch-action: pan-y; -webkit-overflow-scrolling: touch;
        }
        /* Custom scrollbar for webkit */
        .card-container::-webkit-scrollbar, .list-layout::-webkit-scrollbar { width: 8px; }
        .card-container::-webkit-scrollbar-track, .list-layout::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        .card-container::-webkit-scrollbar-thumb, .list-layout::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        
        .card {
            width: 160px; min-height: 250px;
            background: linear-gradient(160deg, rgba(25,25,35,0.9), rgba(10,10,15,0.95));
            border: 1px solid var(--border); border-radius: 12px;
            padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--primary); box-shadow: 0 10px 25px rgba(0, 255, 204, 0.2); }
        .card:active { transform: scale(0.98); }
        
        .card-icon { font-size: 3rem; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.1)); }
        .card-title { font-size: 1.1rem; font-weight: 700; color: var(--primary); margin-bottom: 8px; line-height: 1.2; }
        .card-desc { font-size: 0.8rem; color: #aaa; line-height: 1.4; margin-bottom: 10px; flex-grow: 1; }
        .card-type { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; width: 100%; }
        
        .card.evolution { border-color: var(--accent); background: linear-gradient(160deg, #2a0a1a, #1a050d); animation: pulse 2s infinite; }
        .card.evolution .card-title { color: var(--accent); }
        .card.evolution:hover { box-shadow: 0 10px 30px rgba(255, 0, 153, 0.5); }

        .card.hidden-tier { border-color: var(--void); background: linear-gradient(160deg, #120024, #05000a); }
        .card.hidden-tier .card-title { color: var(--void); text-shadow: 0 0 5px var(--void); }

        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } 50% { box-shadow: 0 0 25px rgba(255,0,153,0.6); } 100% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } }

        .card.locked { opacity: 0.7; filter: grayscale(1); border-style: dashed; }

        /* Lists */
        .list-layout {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px; width: 100%; max-width: 900px; padding: 10px;
            max-height: 65vh; overflow-y: auto; 
            touch-action: pan-y; -webkit-overflow-scrolling: touch;
        }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid var(--border);
            border-radius: 10px; padding: 12px; display: flex; flex-direction: column; align-items: center;
            transition: 0.2s; position: relative;
        }
        .shop-item:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.3); }
        .shop-item h3 { margin: 5px 0; color: #fff; font-size: 0.95rem; }
        .shop-item p { margin: 0 0 10px 0; color: #888; font-size: 0.8rem; text-align: center; line-height: 1.3; }
        
        .currency-display {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.3rem; color: var(--gold); font-weight: 900;
            display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.6);
            padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,215,0,0.3);
        }

        /* Skin Grid */
        .skin-grid { 
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 700px; 
            overflow-y: auto; max-height: 60vh;
            touch-action: pan-y; -webkit-overflow-scrolling: touch;
        }
        .skin-item {
            width: 100px; height: 140px; border: 2px solid #444; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; background: rgba(20,20,20,0.8); position: relative;
        }
        .skin-item.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(0,255,204,0.3); background: rgba(0,255,204,0.05); }
        .skin-item.locked { opacity: 0.6; border-color: #222; cursor: not-allowed; }
        .skin-preview { font-size: 3rem; margin-bottom: 10px; }
        .skin-name { font-size: 0.85rem; color: #ddd; font-weight: bold; }
        .lock-icon { position: absolute; top: 8px; right: 8px; font-size: 1rem; color: #777; }

        /* Gacha */
        #gacha-result {
            width: 300px; padding: 30px; border: 1px solid var(--gold);
            background: radial-gradient(circle at center, #222, #050505);
            border-radius: 20px; display: none; flex-direction: column; align-items: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2); animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .gacha-icon { font-size: 6rem; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(255,255,255,0.5)); }

        /* Joystick */
        #joystick-zone { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; touch-action: none; }
        #joystick-base {
            position: absolute; width: 120px; height: 120px;
            border: 2px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #joystick-knob {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(255,255,255,0.5);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #dash-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.8rem; pointer-events: none; letter-spacing: 1px;
            text-shadow: 0 1px 2px #000;
        }
        #scroll-hint {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 0.7rem; pointer-events: none; letter-spacing: 1px;
        }
        #zoom-indicator {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 10px;
            font-size: 0.8rem; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        /* Class & Ultimate Selection */
        .class-badge { font-size: 0.7rem; background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; margin-top: 5px; }
        .selected-check { position: absolute; top: 10px; right: 10px; color: var(--primary); font-size: 1.2rem; display: none; }
        .shop-item.selected { border-color: var(--primary); background: rgba(0, 255, 204, 0.05); }
        .shop-item.selected .selected-check { display: block; }
        
        .ult-card {
            width: 100%; border: 1px solid #444; border-radius: 10px; background: rgba(0,0,0,0.5);
            padding: 15px; margin-bottom: 10px; cursor: pointer; display:flex; align-items:center; gap: 15px; transition: 0.2s;
        }
        .ult-card:hover { border-color: #666; background: rgba(255,255,255,0.05); }
        .ult-card.selected { border-color: var(--accent); background: rgba(255,0,153,0.1); }
        .ult-icon-l { font-size: 2.5rem; }

        /* Achievement Item */
        .achieve-item {
            background: rgba(0,0,0,0.5); border: 1px solid #444; border-radius: 8px;
            padding: 10px; display: flex; align-items: center; justify-content: space-between;
            width: 100%; opacity: 0.6;
        }
        .achieve-item.completed { border-color: var(--gold); background: rgba(255,215,0,0.1); opacity: 1; }
        .achieve-info { text-align: left; }
        .achieve-title { font-weight: bold; font-size: 0.9rem; color: #fff; }
        .achieve-desc { font-size: 0.75rem; color: #aaa; }
        .achieve-reward { font-weight: bold; color: var(--gold); font-size: 0.8rem; }
        .btn-claim { padding: 5px 10px; font-size: 0.7rem; min-width: auto; background: var(--gold); color: #000; }
        .btn-claim:disabled { background: #555; color: #888; cursor: default; box-shadow: none; transform: none; }

        /* Reroll/Skip UI */
        .meta-btn-row {
            display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;
        }
        .meta-btn {
            background: #222; border: 1px solid #555; color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 5px;
        }
        .meta-btn:hover { background: #333; }
        .meta-btn span { font-weight: bold; color: var(--gold); }
        .meta-btn:disabled { opacity: 0.5; cursor: default; }

        /* Void Mode Toggle */
        .mode-toggle {
            display: flex; align-items: center; gap: 10px; margin-bottom: 20px; cursor: pointer;
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px; border: 1px solid var(--border);
            justify-content: center;
        }
        .mode-toggle.active { border-color: var(--void); background: rgba(157, 0, 255, 0.1); }
        .mode-checkbox { width: 20px; height: 20px; accent-color: var(--void); }

        /* Weapon Select */
        #weapon-screen .card { width: 140px; min-height: 200px; }
        #weapon-screen .card-title { font-size: 1rem; }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <canvas id="gameCanvas"></canvas>

        <!-- Joystick UI -->
        <div id="joystick-zone" class="interactive"></div>
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
        <div id="dash-hint">SPACE / DOUBLE TAP : DASH</div>
        <div id="scroll-hint">MOUSE WHEEL : ZOOM</div>
        <div id="zoom-indicator">x1.0</div>

        <!-- HUD -->
        <div id="hud" class="ui-layer hidden">
            <div class="top-row">
                <!-- Stats and Controls -->
                <div style="display:flex; width:100%; justify-content:space-between; align-items: flex-start; margin-bottom: 5px;">
                    <div class="stat-box" style="width: fit-content;">
                        <div class="stat-text"><span style="color:var(--primary)">LV.<span id="level-display">1</span></span></div>
                        <div class="stat-text"><span style="color:#ccc">üíÄ <span id="kill-display">0</span></span></div>
                        <div class="stat-text"><span style="color:var(--gold)">ü™ô <span id="coin-display">0</span></span></div>
                    </div>
                    <div id="pause-btn" onclick="togglePause()">‚ùö‚ùö</div>
                </div>
                
                <!-- XP Bar -->
                <div class="bar-container" style="width: 100%; max-width: 600px; height: 8px; margin-bottom: 5px;">
                    <div id="xp-bar" class="bar-fill"></div>
                </div>

                <!-- HP Bar -->
                <div class="bar-container" style="width: 300px; height: 24px; border: 2px solid rgba(255,50,50,0.6); background: rgba(0,0,0,0.8);">
                    <div id="hp-bar" class="bar-fill"></div>
                    <div id="hp-text" style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; justify-content:center; align-items:center; font-size:0.8rem; font-weight:bold; text-shadow:0 1px 2px #000;">100 / 100</div>
                </div>
            </div>
            
            <div id="timer">00:00</div>
            <div id="event-hud">METEOR SHOWER</div>

            <div id="boss-hud">
                <div id="boss-name">‚ö†Ô∏è THE HEXAGON ‚ö†Ô∏è</div>
                <div id="boss-hp-container"><div id="boss-hp-fill"></div></div>
            </div>

            <div id="ult-btn" class="interactive disabled" onclick="useUltimate()">
                <div id="ult-icon">üí£Ô∏è</div>
                <div id="ult-label">ULTIMATE</div>
            </div>
        </div>

        <!-- Upgrade Screen -->
        <div id="upgrade-screen" class="ui-layer hidden interactive menu-screen">
            <h2 class="screen-title" style="font-size:2rem;">SYSTEM UPGRADE</h2>
            <div class="meta-btn-row">
                <button class="meta-btn" id="btn-reroll" onclick="doReroll()">üîÑ Reroll <span id="cnt-reroll">0</span></button>
                <button class="meta-btn" id="btn-skip" onclick="doSkip()">‚è≠Ô∏è Skip <span id="cnt-skip">0</span></button>
                <button class="meta-btn" id="btn-banish" onclick="toggleBanishMode()">üö´ Banish <span id="cnt-banish">0</span></button>
            </div>
            <p class="screen-subtitle" id="upgrade-subtitle">Í∞ïÌôî Î™®ÎìàÏùÑ ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§</p>
            <div class="card-container" id="upgrade-cards"></div>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="ui-layer hidden interactive menu-screen" style="display:flex; flex-direction:column;">
            <h1 class="screen-title">PAUSED</h1>
            <p class="screen-subtitle">ÏûëÏ†Ñ ÏùºÏãú Ï§ëÏßÄ</p>
            <div style="background:rgba(0,0,0,0.5); padding:15px; border-radius:10px; margin-bottom:20px; text-align:left; font-size:0.8rem; line-height:1.6; min-width:250px;">
                <strong>CURRENT STATS</strong><br>
                DMG Multi: <span id="pause-dmg">100%</span><br>
                Area Multi: <span id="pause-area">100%</span><br>
                Speed: <span id="pause-spd">100%</span><br>
                Crit Chance: <span id="pause-crit">0%</span><br>
                Coin Bonus: <span id="pause-greed">0%</span>
            </div>
            <div style="display:flex; gap:15px; flex-direction:column;">
                <button class="btn" onclick="togglePause()">Í≥ÑÏÜçÌïòÍ∏∞</button>
                <button class="btn btn-secondary" onclick="quitGame()">Í∑∏ÎßåÌïòÍ∏∞</button>
            </div>
        </div>

        <!-- Weapon Selection Screen -->
        <div id="weapon-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">LOADOUT</h1>
            <p class="screen-subtitle">Î¨¥ÏûëÏúÑ ÏãúÏûë Î¨¥Í∏∞ ÏÑ†ÌÉù</p>
            <div class="card-container" id="weapon-cards" style="justify-content:center;">
                <!-- Filled dynamically -->
            </div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="showStartScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Shop Screen -->
        <div id="shop-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="shop-currency">0</span></div>
            <h1 class="screen-title">LABORATORY</h1>
            <p class="screen-subtitle">Í∏∞Î≥∏ Îä•Î†•Ïπò ÏòÅÍµ¨ Í∞ïÌôî</p>
            <div class="list-layout" id="shop-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeShop()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Armory Screen -->
        <div id="armory-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="armory-currency">0</span></div>
            <h1 class="screen-title">ARMORY</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ Ïû•ÎπÑ ÏóÖÍ∑∏Î†àÏù¥Îìú</p>
            <div class="card-container" id="armory-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArmory()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Class Screen -->
        <div id="class-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="class-currency">0</span></div>
            <h1 class="screen-title">BARRACKS</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ ÏßÅÏóÖ ÏÑ†ÌÉù Î∞è Ìï¥Í∏à</p>
            <div class="list-layout" id="class-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeClassScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Skill Screen (Ultimate) -->
        <div id="skill-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SKILLS</h1>
            <p class="screen-subtitle">Í∂ÅÍ∑πÍ∏∞ ÏÑ†ÌÉù</p>
            <div id="skill-container" style="width: 100%; max-width: 500px; text-align: left;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeSkillScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Achievements Screen -->
        <div id="achieve-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="achieve-currency">0</span></div>
            <h1 class="screen-title">ACHIEVEMENTS</h1>
            <p class="screen-subtitle">ÏûÑÎ¨¥ Îã¨ÏÑ± Î∞è Î≥¥ÏÉÅ</p>
            <div class="list-layout" id="achieve-container" style="display:flex; flex-direction:column; gap:10px;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeAchieveScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Gacha Screen -->
        <div id="gacha-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="gacha-currency">0</span></div>
            <h1 class="screen-title">SUPPLY DEPOT</h1>
            <p class="screen-subtitle">Î≥¥Í∏âÌíà Ìà¨Ìïò ÏöîÏ≤≠</p>
            
            <div id="gacha-result">
                <div class="gacha-icon" id="g-icon">üíé</div>
                <div class="gacha-name" id="g-name">???</div>
                <div class="gacha-desc" id="g-desc">...</div>
                <button class="btn" onclick="closeGachaResult()">ÌôïÏù∏</button>
            </div>
            
            <div id="gacha-buttons" style="display:flex; flex-direction:column; gap:15px;">
                <button id="gacha-roll-btn" class="btn" onclick="rollGacha()">
                    <div>Ïú†Î¨º ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">300 ü™ô</div>
                </button>
                <button id="skin-roll-btn" class="btn btn-accent" onclick="rollSkinGacha()">
                    <div>Ïä§ÌÇ® ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">1000 ü™ô</div>
                </button>
            </div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeGacha()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Artifact Dex Screen -->
        <div id="artifact-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">ARTIFACTS</h1>
            <p class="screen-subtitle">ÏàòÏßëÌïú Ïú†Î¨º ÎèÑÍ∞ê</p>
            <div class="card-container" id="artifact-container" style="justify-content: flex-start;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArtifactScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Wardrobe Screen -->
        <div id="wardrobe-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">WARDROBE</h1>
            <p class="screen-subtitle">Ïô∏Ìòï Î≥ÄÍ≤Ω</p>
            <div class="skin-grid" id="skin-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeWardrobe()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="ui-layer menu-screen interactive" style="display:flex;">
            <!-- Added Currency Display here -->
            <div class="currency-display">ü™ô <span id="start-currency">0</span></div>
            
            <h1 class="screen-title" style="font-size:3.5rem; margin-bottom:10px; color:var(--primary);">IFKO<br><span style="font-size:2.5rem; color:#fff;">SURVIVOR</span></h1>
            
            <button class="btn" style="width:220px; height:60px; font-size:1.3rem; margin-bottom:30px; box-shadow: 0 0 20px var(--primary);" onclick="openWeaponSelection()">MISSION START</button>
            
            <div class="menu-grid">
                <button class="btn btn-secondary" onclick="openClassScreen()">ÏßÅÏóÖÏÜå</button>
                <button class="btn btn-secondary" onclick="openSkillScreen()">Ïä§ÌÇ¨</button>
                <button class="btn btn-secondary" onclick="openArmory()">Î¨¥Í∏∞Í≥†</button>
                <button class="btn btn-secondary" onclick="openShop()">Ïó∞Íµ¨ÏÜå</button>
                <button class="btn btn-secondary" onclick="openGacha()">Î≥¥Í∏âÏÜå</button>
                <button class="btn btn-secondary" onclick="openAchieveScreen()">ÏóÖÏ†Å</button>
                <button class="btn btn-secondary" onclick="openWardrobe()">Ïò∑Ïû•</button>
                <button class="btn btn-secondary" onclick="openSettings()">ÏÑ§Ï†ï</button>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SETTINGS</h1>
            <p class="screen-subtitle">ÏãúÏä§ÌÖú ÏÑ§Ï†ï</p>
            
            <div class="mode-toggle" id="void-mode-toggle" onclick="toggleVoidMode()">
                <input type="checkbox" class="mode-checkbox" id="void-mode-cb">
                <span style="font-weight:bold; color:var(--void); text-shadow:0 0 5px var(--void);">VOID MODE (HARD)</span>
            </div>

            <div style="display:flex; flex-direction:column; gap:15px; width: 200px;">
                <button class="btn btn-danger" onclick="resetData()">Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî</button>
                <button class="btn btn-secondary" onclick="closeSettings()">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-layer hidden menu-screen interactive">
            <h1 class="screen-title" style="color:#ff3333; background:none;">MISSION FAILED</h1>
            <p id="final-score" style="font-size:1.5rem; margin-bottom:5px;">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 00:00</p>
            <p id="final-coins" style="font-size:1.2rem; color:var(--gold); margin-bottom:30px;">ÌöçÎìù: 0 ü™ô</p>
            <div style="display:flex; gap:15px;">
                <button class="btn" onclick="openWeaponSelection()">Ïû¨ÏãúÎèÑ</button>
                <button class="btn btn-secondary" onclick="showStartScreen()">Î©îÏù∏ÏúºÎ°ú</button>
            </div>
        </div>
    </div>

<script>
// --- Constants ---
const CANVAS_W = window.innerWidth;
const CANVAS_H = window.innerHeight;
let ZOOM = 0.75; 
const BOSS_SPAWN_TIME = 60; 
const BOSS_RESPAWN_DELAY = 60 * 60; 
const SHOP_BASE_COST = 50;
const GACHA_COST = 300;
const SKIN_COST = 1000;

// --- Definitions ---
const CLASSES = [
    { id: 'soldier', name: 'ÏÜîÏ†Ä', desc: 'Í∑†Ìòï Ïû°Ìûå Ï†ÑÌà¨ ÏöîÏõê', stats: { hp: 0, dmg: 0, spd: 0, cd: 0 }, cost: 0, icon: 'ü™ñ' },
    { id: 'guardian', name: 'Í∞ÄÎîîÏñ∏', desc: 'Ï≤¥Î†• +50, Ïù¥ÎèôÏÜçÎèÑ -10%', stats: { hp: 50, dmg: 0, spd: -0.5, cd: 0 }, cost: 1000, icon: 'üõ°Ô∏è' },
    { id: 'assassin', name: 'Ïñ¥ÏåîÏã†', desc: 'Í≥µÍ≤©Î†• +30%, Ï≤¥Î†• -30', stats: { hp: -30, dmg: 0.3, spd: 1.0, cd: 0 }, cost: 2000, icon: 'üó°Ô∏è' },
    { id: 'mage', name: 'ÏïÑÌÅ¨Î©îÏù¥ÏßÄ', desc: 'Ïø®ÌÉÄÏûÑ -10%, Ï≤¥Î†• -20', stats: { hp: -20, dmg: 0.1, spd: 0, cd: 0.1 }, cost: 3000, icon: 'üîÆ' },
    { id: 'engineer', name: 'ÏóîÏßÄÎãàÏñ¥', desc: 'ÏßÄÏÜçÏãúÍ∞Ñ +20%, ÌÅ¨Í∏∞ +10%', stats: { hp: 10, dmg: 0, spd: 0, cd: 0 }, cost: 4000, icon: 'üîß' }
];

const ULTIMATES = [
    { id: 'nuclear', name: 'Îâ¥ÌÅ¥Î¶¨Ïñ¥', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥Ïùò Ï†ÅÏóêÍ≤å Í¥¥Î©∏Ï†ÅÏù∏ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.', icon: '‚ò¢Ô∏è', color: '#ff3300' },
    { id: 'chrono', name: 'ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨', desc: '5Ï¥à ÎèôÏïà ÏãúÍ∞ÑÏùÑ Î©àÏ∂îÍ≥† ÏûêÏã†ÏùÄ Í∞ÄÏÜçÌï©ÎãàÎã§.', icon: '‚è≥', color: '#00ccff' },
    { id: 'berserk', name: 'Î≤ÑÏÑúÏª§', desc: '10Ï¥à ÎèôÏïà Í≥µÍ≤©ÏÜçÎèÑÏôÄ Ïù¥ÎèôÏÜçÎèÑÍ∞Ä 200% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.', icon: 'ü©∏', color: '#ff0055' }
];

const SKINS = [
    { id: 'default', name: 'Í∏∞Î≥∏', icon: '‚è∫Ô∏è' },
    { id: 'neko', name: 'Ïù¥ÌîÑÎÉ•', icon: 'üê±' },
    { id: 'bot', name: 'Î°úÎ¥á', icon: 'ü§ñ' },
    { id: 'star', name: 'Ïä§ÌÉÄ', icon: '‚≠ê' },
    { id: 'demon', name: 'Îç∞Î™¨', icon: 'üòà' },
    { id: 'alien', name: 'Ïô∏Í≥ÑÏù∏', icon: 'üëΩ' }
];

const ARTIFACTS = [
    { id: 'cube', name: 'Í≥†ÎåÄ ÌÅêÎ∏å', desc: 'Í≥µÍ≤©Î†• +10%', icon: 'üßä' },
    { id: 'feather', name: 'Î∞îÎûåÏùò ÍπÉÌÑ∏', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5%', icon: 'ü™∂' },
    { id: 'chip', name: 'AI Ïπ©ÏÖã', desc: 'Ïø®ÌÉÄÏûÑ Í∞êÏÜå -5%', icon: 'üíæ' },
    { id: 'magnet', name: 'Ï¥àÏ†ÑÎèÑ ÏûêÏÑù', desc: 'ÏûêÏÑù Î≤îÏúÑ +20%', icon: 'üß≤' },
    { id: 'fang', name: 'Ìù°ÌòàÏùò ÏÜ°Í≥≥Îãà', desc: 'Ï≤òÏπò Ïãú Ï≤¥Î†• ÌöåÎ≥µ +1', icon: 'üßõ' },
    { id: 'axe', name: 'Í¥ëÏ†ÑÏÇ¨Ïùò ÎèÑÎÅº', desc: 'Ï≤¥Î†•Ïù¥ ÎÇÆÏùÑÏàòÎ°ù Í∞ïÌï¥Ïßê', icon: 'ü™ì' },
    { id: 'watch', name: 'Ï†ïÏßÄÎêú ÏãúÍ≥Ñ', desc: 'Ï†Å Ïù¥ÎèôÏÜçÎèÑ -10%', icon: '‚è±Ô∏è' },
    { id: 'thorn', name: 'Í∞ÄÏãú Í∞ëÏò∑', desc: 'ÌîºÍ≤© Ïãú Î∞òÏÇ¨ ÌîºÌï¥', icon: 'üåµ' },
    // New Artifacts
    { id: 'drink', name: 'ÏóêÎÑàÏßÄ ÎìúÎßÅÌÅ¨', desc: 'Í≥µÍ≤© ÏÜçÎèÑ +10%', icon: 'ü•§' },
    { id: 'scope', name: 'Ïä§ÎÇòÏù¥Ìçº Ïä§ÏΩîÌîÑ', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +10%', icon: 'üî≠' },
    { id: 'shield', name: 'Î≥¥Ìò∏Îßâ ÏÉùÏÑ±Í∏∞', desc: 'Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Î≥¥Ìò∏Îßâ ÏÉùÏÑ±', icon: 'üõ°Ô∏è' },
    { id: 'skull', name: 'Ìô©Í∏à ÎëêÍ∞úÍ≥®', desc: 'Ï†Å Ï≤¥Î†•/Í≤ΩÌóòÏπò/Í≥®Îìú +30%', icon: 'üíÄ' },
    { id: 'jet', name: 'Ï†úÌä∏ ÏóîÏßÑ', desc: 'ÎåÄÏãú Í±∞Î¶¨ Î∞è ÏÜçÎèÑ +20%', icon: 'üöÄ' },
    { id: 'medkit', name: 'Íµ¨Í∏â ÏÉÅÏûê', desc: 'ÌöåÎ≥µ ÏïÑÏù¥ÌÖú Ìö®Ïú® +50%', icon: 'üíä' },
    { id: 'uranium', name: 'Ïó¥Ìôî Ïö∞ÎùºÎäÑ', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ +20%', icon: '‚ò¢Ô∏è' },
    { id: 'nano', name: 'ÎÇòÎÖ∏ Î®∏Ïã†', desc: 'Ï¥àÎãπ Ï≤¥Î†• 0.5% ÌöåÎ≥µ', icon: 'ü¶†' }
];

const UPGRADES = [
    { id: 'blaster', name: 'Î∏îÎûòÏä§ÌÑ∞', desc: 'Í∏∞Î≥∏ ÏÇ¨Í≤© Î¨¥Í∏∞', type: 'WEAPON', icon: 'üî´' },
    { id: 'blade', name: 'Ïä§ÌéôÌä∏Îü¥ Î∏îÎ†àÏù¥Îìú', desc: 'Ï†ÑÎ∞© Î≤îÏúÑ Î≤†Í∏∞', type: 'WEAPON', icon: '‚öîÔ∏è' },
    { id: 'orbit', name: 'Ïä§ÌîºÎ¶ø Ïò§Î∏å', desc: 'Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî ÏòÅÌòº', type: 'WEAPON', icon: 'ü™ê' },
    { id: 'field', name: 'Ï†ÑÍ∏∞Ïû•', desc: 'Ï£ºÎ≥Ä ÏßÄÏÜç ÌîºÌï¥', type: 'WEAPON', icon: '‚ö°' },
    { id: 'tesla', name: 'ÌÖåÏä¨Îùº ÏΩîÏùº', desc: 'Ïó∞ÏáÑ Î≤àÍ∞ú Í≥µÍ≤©', type: 'WEAPON', icon: 'üå©Ô∏è' },
    { id: 'missile', name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', desc: 'Ï∂îÏ†Å Ìè≠Î∞ú ÎØ∏ÏÇ¨Ïùº', type: 'WEAPON', icon: 'üöÄ' },
    { id: 'gravity', name: 'Ï§ëÎ†• Î∂ïÍ¥¥', desc: 'Ï†ÅÏùÑ Î™®ÏúºÎäî Î∏îÎûôÌôÄ', type: 'WEAPON', icon: 'üåå' },
    { id: 'mines', name: 'ÏñëÏûê ÏßÄÎ¢∞', desc: 'ÏÑ§ÏπòÌòï ÏßÄÎ¢∞', type: 'WEAPON', icon: 'üí£' },
    { id: 'drone', name: 'ÏûêÏú® ÎìúÎ°†', desc: 'Ìò∏ÏúÑ ÎìúÎ°†', type: 'WEAPON', icon: 'üöÅ' },
    { id: 'plasma', name: 'ÌîåÎùºÏ¶àÎßà Ïâ¥Îìú', desc: 'ÌöåÏ†ÑÌïòÎäî Î∞©Ïñ¥Îßâ', type: 'WEAPON', icon: 'üõ°Ô∏è' },
    { id: 'ion', name: 'Ïù¥Ïò® Ï∫êÎÖº', desc: 'Í∂§ÎèÑ Ìè≠Í≤© Î†àÏù¥Ï†Ä', type: 'WEAPON', icon: 'üõ∞Ô∏è' },
    { id: 'frost', name: 'ÌîÑÎ°úÏä§Ìä∏ ÎÖ∏Î∞î', desc: 'Ï£ºÎ≥Ä Ï†Å ÎπôÍ≤∞', type: 'WEAPON', icon: '‚ùÑÔ∏è' },
    // New Weapons
    { id: 'boomerang', name: 'Î∂ÄÎ©îÎûë', desc: 'Ï†ÅÏùÑ ÏπòÍ≥† ÎêòÎèåÏïÑÏòµÎãàÎã§', type: 'WEAPON', icon: 'ü™É' },
    { id: 'flame', name: 'ÌôîÏóº Î∞©ÏÇ¨Í∏∞', desc: 'Ï†ÑÎ∞©Ïóê Î∂àÏùÑ ÎøúÏäµÎãàÎã§', type: 'WEAPON', icon: 'üî•' },
    { id: 'gauss', name: 'Í∞ÄÏö∞Ïä§ ÎùºÏù¥Ìîå', desc: 'Ï¥àÍ≥†ÏÜç Í¥ÄÌÜµ Ï†ÄÍ≤©', type: 'WEAPON', icon: 'üîã' },
    { id: 'spikedball', name: 'Ïä§ÌååÏù¥ÌÅ¨ Î≥º', desc: 'Ï£ºÎ≥ÄÏùÑ ÌäïÍ≤®Îã§ÎãàÎäî Ï≤†Ìá¥', type: 'WEAPON', icon: 'üß∂' },
    { id: 'crossbow', name: 'ÌÅ¨Î°úÏä§Î≥¥Ïö∞', desc: 'Í∞ïÎ†•Ìïú Îã®Î∞ú ÏÇ¨Í≤©', type: 'WEAPON', icon: 'üèπ' },
    
    // Hidden
    { id: 'singularity', name: 'ÌäπÏù¥Ï†ê', desc: '[ÌûàÎì†] Ï†ÅÏùÑ ÏÜåÎ©∏ÏãúÌÇ§Îäî Î∏îÎûôÌôÄ', type: 'HIDDEN', icon: '‚ö´', weight: 0.01 },
    { id: 'voidwalker', name: 'Î≥¥Ïù¥Îìú ÏõåÏª§', desc: '[ÌûàÎì†] Í≥µÌóàÏùò ÌãàÏùÑ ÏóΩÎãàÎã§', type: 'HIDDEN', icon: 'üßø', weight: 0.01 },
    
    // Stats
    { id: 'heal', name: 'Í∏¥Í∏â ÏàòÎ¶¨', desc: 'Ï≤¥Î†• 30% ÌöåÎ≥µ', type: 'STAT', icon: '‚ù§Ô∏è' },
    { id: 'giant', name: 'Í±∞ÎåÄÌôî', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ +15%', type: 'STAT', icon: 'üêò' },
    { id: 'multishot', name: 'Î©ÄÌã∞ÏÉ∑', desc: 'Ìà¨ÏÇ¨Ï≤¥ Í∞úÏàò +1 (ÏùºÎ∂Ä Î¨¥Í∏∞)', type: 'STAT', icon: 'üçí' },
    { id: 'sniper', name: 'Ïä§ÎÇòÏù¥Ìçº', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ +20%', type: 'STAT', icon: 'üéØ' },
    { id: 'knockback', name: 'Ï∂©Í≤©ÌÉÑ', desc: 'ÎÑâÎ∞± ÌååÏõå Ï¶ùÍ∞Ä', type: 'STAT', icon: 'ü•ä' },
    { id: 'armor', name: 'Ìã∞ÌÉÄÎäÑ Ïû•Í∞ë', desc: 'Î∞õÎäî ÌîºÌï¥ -2', type: 'STAT', icon: 'üõ°Ô∏è' },
    { id: 'area', name: 'Ï¶ùÌè≠Í∏∞', desc: 'Î≤îÏúÑ Í≥µÍ≤© Î∞òÍ≤Ω +15%', type: 'STAT', icon: 'üì°' },
    { id: 'duration', name: 'Í≥†Ìö®Ïú® Î∞∞ÌÑ∞Î¶¨', desc: 'Î¨¥Í∏∞ ÏßÄÏÜçÏãúÍ∞Ñ +15%', type: 'STAT', icon: 'üîã' },
    { id: 'pickup', name: 'ÏûêÍ∏∞Ïû•', desc: 'ÏïÑÏù¥ÌÖú ÌöçÎìù Î∞òÍ≤Ω +30%', type: 'STAT', icon: 'üß≤' },
    { id: 'dash_cd', name: 'Î∂ÄÏä§ÌÑ∞', desc: 'ÎåÄÏãú Ïø®ÌÉÄÏûÑ -10%', type: 'STAT', icon: 'üëü' },
    { id: 'greed', name: 'Ï±ÑÍµ¥Ïûê', desc: 'Í≥®Îìú ÌöçÎìù +20%', type: 'STAT', icon: 'üí∞' },
    { id: 'growth', name: 'ÏÑ±Ïû•', desc: 'ÏµúÎåÄÏ≤¥Î†• +5%', type: 'STAT', icon: 'üå≤' }
];

const EVOLUTIONS = [
    { weapon: 'blaster', passive: 'sniper', evolveTo: 'exterminator', name: 'ÏóëÏä§ÌÑ∞ÎØ∏ÎÑ§Ïù¥ÌÑ∞', desc: 'Î∏îÎûòÏä§ÌÑ∞ ÏßÑÌôî: Í≥†ÏÜç Í¥ÄÌÜµ Î†àÏù¥Ï†Ä', icon: 'üëπ' },
    { weapon: 'blade', passive: 'area', evolveTo: 'soulreaper', name: 'ÏòÅÌòº ÏàòÌôïÏûê', desc: 'Î∏îÎ†àÏù¥Îìú ÏßÑÌôî: 360ÎèÑ ÏòÅÌòº Î≤†Í∏∞', icon: 'üíÄ' },
    { weapon: 'orbit', passive: 'area', evolveTo: 'blackhole', name: 'Ïù¥Î≤§Ìä∏ Ìò∏ÎùºÏù¥Ï¶å', desc: 'ÏúÑÏÑ± ÏßÑÌôî: Ï†ÅÏùÑ Îπ®ÏïÑÎì§Ïù¥Îäî Í≥µÌóà', icon: '‚ö´' },
    { weapon: 'tesla', passive: 'multishot', evolveTo: 'thundergod', name: 'ÎáåÏã†', desc: 'ÌÖåÏä¨Îùº ÏßÑÌôî: ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌÉÄÍ≤©', icon: '‚ö°' },
    { weapon: 'missile', passive: 'giant', evolveTo: 'nuke', name: 'Ìåª Îß®', desc: 'ÎØ∏ÏÇ¨Ïùº ÏßÑÌôî: Ï†ÑÏà† ÌïµÎ¨¥Í∏∞', icon: '‚ò¢Ô∏è' },
    { weapon: 'ion', passive: 'duration', evolveTo: 'orbital_strike', name: 'Ïò§ÎπÑÌÉà Ïä§Ìä∏ÎùºÏù¥ÌÅ¨', desc: 'Ïù¥Ïò® Ï∫êÎÖº ÏßÑÌôî: ÌñâÏÑ± ÌååÍ¥¥ Î≥ëÍ∏∞', icon: 'üåå' },
    { weapon: 'frost', passive: 'armor', evolveTo: 'blizzard', name: 'Î∏îÎ¶¨ÏûêÎìú', desc: 'ÌîÑÎ°úÏä§Ìä∏ ÎÖ∏Î∞î ÏßÑÌôî: ÏòÅÍµ¨Ï†ÅÏù∏ ÎààÎ≥¥Îùº', icon: 'ü•∂' }
];

const ACHIEVEMENTS = [
    { id: 'k100', name: 'Ï¥àÎ≥¥ ÏÇ¨ÎÉ•Íæº', desc: 'ÎàÑÏ†Å 100ÌÇ¨ Îã¨ÏÑ±', reward: 500, check: (s) => s.totalKills >= 100 },
    { id: 'k1000', name: 'Î≤†ÌÖåÎûë', desc: 'ÎàÑÏ†Å 1000ÌÇ¨ Îã¨ÏÑ±', reward: 1500, check: (s) => s.totalKills >= 1000 },
    { id: 'k5000', name: 'ÌïôÏÇ¥Ïûê', desc: 'ÎàÑÏ†Å 5000ÌÇ¨ Îã¨ÏÑ±', reward: 5000, check: (s) => s.totalKills >= 5000 },
    { id: 'c1000', name: 'ÏàòÏßëÍ∞Ä', desc: 'ÎàÑÏ†Å 1000ÏΩîÏù∏ ÌöçÎìù', reward: 500, check: (s) => s.totalCoins >= 1000 },
    { id: 'c10000', name: 'Î∂ÄÏûê', desc: 'ÎàÑÏ†Å 10000ÏΩîÏù∏ ÌöçÎìù', reward: 3000, check: (s) => s.totalCoins >= 10000 },
    { id: 't600', name: 'ÏÉùÏ°¥Ïûê', desc: 'ÏµúÎåÄ 10Î∂Ñ ÏÉùÏ°¥', reward: 2000, check: (s) => s.maxTime >= 600 }
];

const DEFAULT_DATA = {
    coins: 0,
    currentSkin: 'default',
    ownedSkins: ['default'],
    currentClass: 'soldier',
    ownedClasses: ['soldier'],
    currentUlt: 'nuclear',
    ownedUlts: ['nuclear'],
    upgrades: { 
        damage: 0, health: 0, speed: 0, greed: 0, 
        cooldown: 0, magnet: 0, crit: 0, regen: 0, 
        revive: 0, luck: 0, evasion: 0, xp: 0, duration: 0,
        armor: 0, knockback: 0, reroll: 0, skip: 0, banish: 0, growth: 0
    },
    equipment: { weapon: 0, helmet: 0, suit: 0, gloves: 0, boots: 0, ring: 0 },
    artifacts: {},
    stats: { totalKills: 0, totalTime: 0, totalCoins: 0, maxTime: 0 },
    achievements: [] 
};

let saveData = loadData();

function loadData() {
    const d = localStorage.getItem('ifko_evo_v16');
    if(!d) return JSON.parse(JSON.stringify(DEFAULT_DATA));
    const parsed = JSON.parse(d);
    const newData = JSON.parse(JSON.stringify(DEFAULT_DATA));
    for (let key in parsed) {
        if (typeof parsed[key] === 'object' && !Array.isArray(parsed[key])) {
            newData[key] = { ...newData[key], ...parsed[key] };
        } else {
            newData[key] = parsed[key];
        }
    }
    return newData;
}

function save() {
    localStorage.setItem('ifko_evo_v16', JSON.stringify(saveData));
}

function resetData() {
    if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
        saveData = JSON.parse(JSON.stringify(DEFAULT_DATA));
        save();
        alert("Ï¥àÍ∏∞Ìôî ÏôÑÎ£å.");
        closeSettings();
        location.reload();
    }
}

// --- Game State ---
const state = {
    running: false, paused: false, gameOver: false,
    lastTime: 0, time: 0, score: 0, kills: 0, coins: 0, level: 1, xp: 0, nextLevelXp: 10,
    keys: { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false },
    pointer: { x: 0, y: 0, down: false, id: null },
    joystick: { active: false, originX: 0, originY: 0, dx: 0, dy: 0 },
    lastTap: 0,
    player: null, enemies: [], particles: [], items: [], projectiles: [], 
    boss: null, bossRespawnTimer: 0, bossLevel: 1,
    popups: [], shockwaves: [], gravityWells: [], mines: [], drones: [], voidZones: [], ionBeams: [], worms: [], spikeBalls: [],
    event: { type: null, timer: 0 },
    stars: [],
    weapons: {},
    sessionStats: { 
        sizeMult: 1, projectileCount: 0, projectileSpeed: 1, 
        areaMult: 1, durationMult: 1, knockbackMult: 1, 
        dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1, growth: 0
    },
    meta: { reroll: 0, skip: 0, banish: 0, banishedItems: [] },
    isVoidMode: false,
    ult: { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 },
    facingRight: true
};

// --- Classes ---

class Star {
    constructor() {
        this.reset();
        this.x = Math.random() * CANVAS_W;
        this.y = Math.random() * CANVAS_H;
    }
    reset() {
        this.z = Math.random() * 2 + 0.5; // Depth
        this.size = Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        this.x = CANVAS_W/2 + Math.cos(angle) * CANVAS_W;
        this.y = CANVAS_H/2 + Math.sin(angle) * CANVAS_H;
    }
    update(px, py) {
        this.x -= (px * 0.1) / this.z;
        this.y -= (py * 0.1) / this.z;
        if (this.x < 0) this.x += CANVAS_W; if (this.x > CANVAS_W) this.x -= CANVAS_W;
        if (this.y < 0) this.y += CANVAS_H; if (this.y > CANVAS_H) this.y -= CANVAS_H;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255,255,255,${0.3 + 0.5/this.z})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
}

class Player {
    constructor() {
        this.x = 0; this.y = 0;
        
        const job = CLASSES.find(c => c.id === saveData.currentClass) || CLASSES[0];
        
        // Artifact bonuses
        const artDmg = (saveData.artifacts.cube || 0) * 0.1;
        const artSpd = (saveData.artifacts.feather || 0) * 0.05;
        const artCd = (saveData.artifacts.chip || 0) * 0.05 + (saveData.artifacts.drink || 0) * 0.1;
        const artCrit = (saveData.artifacts.scope || 0) * 0.1;
        const artDash = (saveData.artifacts.jet || 0) * 0.2;
        const artRegen = (saveData.artifacts.nano || 0) * 0.5; // 0.5 hp/sec
        const artSize = (saveData.artifacts.uranium || 0) * 0.2;

        const shopDmg = saveData.upgrades.damage * 0.1;
        const shopHp = saveData.upgrades.health * 10;
        const shopSpd = saveData.upgrades.speed * 0.05;
        const shopCd = (saveData.upgrades.cooldown || 0) * 0.05;
        const shopCrit = (saveData.upgrades.crit || 0) * 0.05 + (saveData.upgrades.luck || 0) * 0.02;
        const shopRegen = (saveData.upgrades.regen || 0) * 1;
        const shopRevive = (saveData.upgrades.revive || 0);
        const shopEvasion = (saveData.upgrades.evasion || 0) * 0.05;
        const shopArmor = (saveData.upgrades.armor || 0);
        const shopKnockback = (saveData.upgrades.knockback || 0) * 0.2;
        const shopGrowth = (saveData.upgrades.growth || 0) * 0.05;
        const shopDashCd = (saveData.upgrades.agility || 0) * 0.05;
        
        if (job.id === 'engineer') { state.sessionStats.durationMult += 0.2; state.sessionStats.sizeMult += 0.1; }

        const equipDmg = (saveData.equipment.weapon || 0) * 0.05; 
        const equipHp = (saveData.equipment.suit || 0) * 10;
        const equipSpd = (saveData.equipment.boots || 0) * 0.1; 
        const equipCd = (saveData.equipment.helmet || 0) * 0.01;
        const equipCrit = (saveData.equipment.gloves || 0) * 0.01;
        const equipRing = (saveData.equipment.ring || 0) * 0.05;

        this.maxHp = (100 + job.stats.hp + shopHp + equipHp) * (1 + shopGrowth);
        this.hp = this.maxHp;
        this.baseSpeed = (3 + job.stats.spd + shopSpd + artSpd + equipSpd);
        this.speed = this.baseSpeed;
        this.dmgMult = 1 + job.stats.dmg + shopDmg + artDmg + equipDmg;
        this.cdReduc = Math.min(0.7, job.stats.cd + artCd + equipCd + shopCd); 
        this.critChance = shopCrit + artCrit + equipCrit;
        this.regenRate = shopRegen + artRegen;
        this.revives = shopRevive;
        this.evasion = shopEvasion;
        
        state.sessionStats.armor = shopArmor;
        state.sessionStats.knockbackMult = 1 + shopKnockback;
        state.sessionStats.sizeMult += artSize;
        state.sessionStats.dashCdMult = (1 - artDash) * (1 - shopDashCd);
        state.sessionStats.areaMult += equipRing;
        state.sessionStats.durationMult += equipRing;

        this.size = 20;
        this.invuln = 0;
        this.dashCd = 0; this.dashTime = 0; this.dashVec = {x:0, y:0};
        this.skin = saveData.currentSkin;
        
        this.shieldTimer = 0;
        this.shield = 0;
    }

    update() {
        if (this.regenRate > 0 && state.time % 60 === 0 && this.hp < this.maxHp) {
            this.hp = Math.min(this.hp + this.regenRate, this.maxHp);
            createPopup('+', this.x, this.y - 20, '#0f0');
        }

        // Shield Artifact
        if (saveData.artifacts.shield) {
            this.shieldTimer++;
            if (this.shieldTimer > 600) { // 10 sec
                this.shield = saveData.artifacts.shield * 20; // 20 Shield per level
                this.shieldTimer = 0;
                createPopup("SHIELD", this.x, this.y - 40, '#00ccff');
            }
        }

        let moveX = 0, moveY = 0;

        if (this.dashTime > 0) {
            this.x += this.dashVec.x * 15; this.y += this.dashVec.y * 15;
            this.dashTime--;
            if(this.dashTime % 2 === 0) state.particles.push(new Particle(this.x, this.y, '#00ffcc', 0, 15, 10)); // Afterimage
        } else {
            let dx = 0, dy = 0;
            if (state.joystick.active) { dx += state.joystick.dx; dy += state.joystick.dy; }
            
            if (state.keys.w || state.keys.ArrowUp) dy -= 1;
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1;
            if (state.keys.d || state.keys.ArrowRight) dx += 1;

            if (dx !== 0 || dy !== 0) { 
                const len = Math.sqrt(dx*dx + dy*dy); 
                if (len > 1) { dx /= len; dy /= len; } 
                else if (len > 0 && !state.joystick.active) { dx /= len; dy /= len; } 
                if(dx > 0) state.facingRight = true; else if (dx < 0) state.facingRight = false;
            }

            if (dx !== 0 || dy !== 0) { 
                moveX = dx * this.speed; moveY = dy * this.speed;
                this.x += moveX; this.y += moveY; 
            }
        }
        
        state.stars.forEach(s => s.update(moveX || 0, moveY || 0));

        if (this.dashCd > 0) this.dashCd--;
        if (this.invuln > 0) this.invuln--;
    }
    
    dash() {
        if (this.dashCd > 0) return;
        let dx = 0, dy = 0;
        if (state.joystick.active) { dx = state.joystick.dx; dy = state.joystick.dy; } 
        else if (state.keys.w || state.keys.a || state.keys.s || state.keys.d || state.keys.ArrowUp || state.keys.ArrowLeft || state.keys.ArrowDown || state.keys.ArrowRight) {
            if (state.keys.w || state.keys.ArrowUp) dy -= 1; 
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1; 
            if (state.keys.d || state.keys.ArrowRight) dx += 1;
            const len = Math.sqrt(dx*dx + dy*dy); 
            if (len > 0) { dx /= len; dy /= len; }
        } else dx = state.facingRight ? 1 : -1;

        this.dashVec = {x: dx, y: dy};
        this.dashTime = 10; 
        this.dashCd = Math.floor(120 * (1 - this.cdReduc/2) * state.sessionStats.dashCdMult); // Cap dash cooldown reduction
        createExplosion(this.x, this.y, '#00ffff', 10);
        state.shockwaves.push(new Shockwave(this.x, this.y, 40, '#00ffff'));
    }

    takeDamage(amt) {
        if (this.dashTime > 0 || this.invuln > 0) return;
        
        if (Math.random() < this.evasion) { createPopup("MISS", this.x, this.y - 30, '#aaa'); return; }

        if (this.shield > 0) {
            this.shield -= amt;
            createPopup("BLOCKED", this.x, this.y, '#00ccff');
            if(this.shield < 0) this.shield = 0;
            this.invuln = 20;
            return;
        }

        amt = Math.max(1, amt - state.sessionStats.armor);
        this.hp -= amt;
        this.invuln = 30 + (saveData.upgrades.invuln || 0) * 12; // +0.2s per level
        
        const thorns = saveData.artifacts.thorn || 0;
        if (thorns > 0) { state.enemies.forEach(e => { if(Math.hypot(e.x - this.x, e.y - this.y) < 100) e.takeDamage(amt * thorns * 0.5); }); }
        
        createExplosion(this.x, this.y, '#ff0000', 5);
        state.shockwaves.push(new Shockwave(this.x, this.y, 50, '#ff0000'));
        
        if (this.hp <= 0) {
            if (this.revives > 0) {
                this.revives--; this.hp = this.maxHp * 0.5; this.invuln = 120;
                createExplosion(this.x, this.y, '#fff', 50); createPopup("REVIVE!", this.x, this.y, '#fff');
                state.enemies.forEach(e => { const dx = e.x - this.x, dy = e.y - this.y; e.pushX = dx * 3; e.pushY = dy * 3; });
            } else endGame();
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Dash Cooldown Indicator
        if(this.dashCd > 0) {
            ctx.beginPath(); ctx.arc(0, 0, this.size + 8, 0, (Math.PI * 2) * (1 - this.dashCd/(120*(1-this.cdReduc/2)*state.sessionStats.dashCdMult)));
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
        } else {
             ctx.beginPath(); ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2);
             ctx.strokeStyle = 'rgba(0, 255, 204, 0.3)'; ctx.lineWidth = 1; ctx.stroke();
        }

        let color = state.isVoidMode ? '#bc13fe' : '#00ffcc';
        if (state.weapons.blaster && state.weapons.blaster.evolved) color = '#ff0099';
        if (this.invuln > 0 && Math.floor(Date.now()/50)%2===0) color = '#fff';
        if (state.ult.activeTime > 0) color = '#ff3300';
        
        if (this.shield > 0) {
            ctx.beginPath(); ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2); 
            ctx.strokeStyle = '#00ccff'; ctx.lineWidth = 2; ctx.stroke();
        }

        ctx.fillStyle = color;
        // Optimized: Removed shadowBlur
        
        if (this.skin === 'neko') {
            ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-22, -25); ctx.lineTo(-5, -18); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(22, -25); ctx.lineTo(5, -18); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-7, -2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(7, -2, 4, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(-6, -4, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6, -4, 4, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Enemy {
    constructor(type, x, y, isElite = false) {
        this.type = type; this.x = x; this.y = y; this.pushX = 0; this.pushY = 0; this.frozen = 0;
        this.shootTimer = 0; this.volatileTimer = 0; this.isElite = isElite;
        this.flashTime = 0;
        
        let scaler = 1 + (state.time / 180);
        if (state.isVoidMode) scaler *= 2; 

        // Apply Golden Skull difficulty
        if (saveData.artifacts.skull) {
             scaler *= 1.3;
        }

        if (type === 'SQUARE') { this.hp = 10*scaler; this.speed = 1.5; this.size = 15; this.color = '#ff3333'; this.dmg = 10; }
        else if (type === 'TRIANGLE') { this.hp = 5*scaler; this.speed = 2.5; this.size = 12; this.color = '#ffcc00'; this.dmg = 15; }
        else if (type === 'PENTAGON') { this.hp = 20*scaler; this.speed = 1.0; this.size = 20; this.color = '#33ff33'; this.dmg = 20; }
        else if (type === 'RHOMBUS') { this.hp = 15*scaler; this.speed = 4.0; this.size = 14; this.color = '#00ccff'; this.dmg = 15; }
        else if (type === 'OCTAGON') { this.hp = 80*scaler; this.speed = 0.8; this.size = 30; this.color = '#9900ff'; this.dmg = 30; }
        else if (type === 'SHOOTER') { this.hp = 15*scaler; this.speed = 1.2; this.size = 18; this.color = '#ff5500'; this.dmg = 15; }
        else if (type === 'VOLATILE') { this.hp = 8*scaler; this.speed = 3.5; this.size = 12; this.color = '#550000'; this.dmg = 50; }
        else if (type === 'SWARM') { this.hp = 2*scaler; this.speed = 3.0; this.size = 8; this.color = '#bc13fe'; this.dmg = 5; }
        else if (type === 'WORM_HEAD') { this.hp = 150*scaler; this.speed = 2.0; this.size = 20; this.color = '#8800ff'; this.dmg = 20; }
        else if (type === 'WORM_BODY') { this.hp = 500*scaler; this.speed = 2.0; this.size = 18; this.color = '#6600cc'; this.dmg = 10; }
        else if (type === 'TANK') { this.hp = 100*scaler; this.speed = 0.6; this.size = 35; this.color = '#444'; this.dmg = 30; }
        else if (type === 'DASHER') { this.hp = 25*scaler; this.speed = 1.5; this.size = 16; this.color = '#ff9900'; this.dmg = 20; this.dashMode = false; this.dashCool = 100; }
        else if (type === 'SPLITTER') { this.hp = 40*scaler; this.speed = 1.0; this.size = 22; this.color = '#00ff99'; this.dmg = 20; }
        else if (type === 'SPLIT_MINI') { this.hp = 15*scaler; this.speed = 2.0; this.size = 12; this.color = '#00ff99'; this.dmg = 10; }
        
        if (state.isVoidMode) { this.dmg *= 1.5; this.speed *= 1.2; }
        if (this.isElite) {
            this.hp *= 5; this.size *= 1.5; this.dmg *= 2; 
        }
        
        if (saveData.artifacts.watch) this.speed *= 0.9;
        this.baseSpeed = this.speed;
        this.maxHp = this.hp;
    }
    update(player) {
        if(this.frozen > 0) { this.frozen--; return; }
        if(this.flashTime > 0) this.flashTime--;
        this.x += this.pushX; this.y += this.pushY; this.pushX *= 0.9; this.pushY *= 0.9;
        
        if (this.type === 'WORM_BODY') return; 

        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        
        if (this.type === 'SHOOTER') {
            if (dist > 300) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            else if (dist < 200) { this.x -= (dx / dist) * this.speed; this.y -= (dy / dist) * this.speed; }
            this.shootTimer++;
            if (this.shootTimer > 120) {
                this.shootTimer = 0;
                state.projectiles.push(new Projectile(this.x, this.y, (dx/dist)*5, (dy/dist)*5, 10 * (state.isVoidMode?1.5:1), '#ff3333', 100, 5, 'enemy_bullet'));
            }
        } else if (this.type === 'VOLATILE') {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
            if (dist < 80) {
                this.volatileTimer++;
                this.color = this.volatileTimer % 10 < 5 ? '#ff0000' : '#fff';
                if (this.volatileTimer > 30) {
                    createExplosion(this.x, this.y, '#ff0000', 5);
                    if (dist < 80) player.takeDamage(this.dmg);
                    removeEnemy(this);
                }
            } else { this.volatileTimer = 0; this.color = '#550000'; }
        } else if (this.type === 'DASHER') {
             if (this.dashMode) {
                 this.x += (dx / dist) * this.speed * 4; this.y += (dy / dist) * this.speed * 4;
                 this.dashCool--;
                 if (this.dashCool <= 0) { this.dashMode = false; this.dashCool = 100 + Math.random()*100; }
             } else {
                 this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
                 this.dashCool--;
                 if (this.dashCool <= 0 && dist < 300) { this.dashMode = true; this.dashCool = 40; createPopup("!", this.x, this.y - 20, "#ff0000"); }
             }
        } else if (this.type === 'WORM_HEAD') {
             const angle = Math.atan2(dy, dx);
             this.x += Math.cos(angle) * this.speed;
             this.y += Math.sin(angle) * this.speed;
        } else {
            if (dist > 0) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
        }
        
        if (dist < this.size + player.size) { 
            player.takeDamage(this.dmg); 
            if(this.type !== 'WORM_HEAD' && this.type !== 'TANK') { this.pushX = -(dx/dist)*10; this.pushY = -(dy/dist)*10; }
        }
    }
    takeDamage(amt, knockback = 0, sourceX = 0, sourceY = 0) {
        this.flashTime = 5;
        if(saveData.artifacts.axe) { const hpPct = state.player.hp / state.player.maxHp; if(hpPct < 0.5) amt *= 1.5; if(hpPct < 0.2) amt *= 2.0; }
        
        let isCrit = false;
        if (Math.random() < state.player.critChance) { amt *= 2; isCrit = true; }

        amt *= state.player.dmgMult; 
        
        if (knockback > 0 && sourceX && sourceY && this.type !== 'WORM_HEAD' && this.type !== 'WORM_BODY') {
            if (this.type === 'TANK') knockback *= 0.2;
            const dx = this.x - sourceX, dy = this.y - sourceY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const kbForce = knockback * state.sessionStats.knockbackMult;
            if (dist > 0) { this.pushX = (dx/dist) * kbForce; this.pushY = (dy/dist) * kbForce; }
        }

        this.hp -= amt; 
        createPopup(Math.round(amt) + (isCrit?'!':''), this.x, this.y - 10, isCrit ? '#f00' : '#fff', true);
        
        if (this.hp <= 0) { this.die(); return true; } return false;
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 3); // Reduced particles
        if(this.type === 'SPLITTER') {
            state.enemies.push(new Enemy('SPLIT_MINI', this.x + 10, this.y));
            state.enemies.push(new Enemy('SPLIT_MINI', this.x - 10, this.y));
        }

        if(saveData.artifacts.fang && Math.random() < 0.1) { state.player.hp = Math.min(state.player.hp + 1, state.player.maxHp); createPopup("+1", state.player.x, state.player.y, '#0f0'); }
        
        const rand = Math.random();
        const luck = saveData.upgrades.luck || 0;
        const isGoldRush = state.event.type === 'GOLDRUSH';

        if (this.isElite) {
            state.items.push(new Item(this.x, this.y, 0, 'CHEST'));
            createPopup("ELITE KILLED", this.x, this.y - 30, '#ffd700');
        }

        if (rand < 0.005 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'BOMB'));
        else if (rand < 0.01 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'MAGNET'));
        else if (rand < 0.02 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'HEAL'));
        else {
             if (isGoldRush || rand < (state.isVoidMode ? 0.2 : 0.1) * (1+luck*0.1)) { // Increased coin chance
                 let it = new Item(this.x, this.y, 300, 'XP'); // Increased base coin value
                 it.isCoin = true; it.color = '#ffd700'; it.val = 300;
                 state.items.push(it);
             } else {
                 state.items.push(new Item(this.x, this.y, 2 * (state.isVoidMode?2:1), 'XP')); 
             }
        }
        
        if(this.wormId) {
            state.worms.forEach(w => { if(w.wormId === this.wormId && w !== this) w.hp = 0; });
        }

        state.kills++; saveData.stats.totalKills++;
    }
    draw(ctx) {
        if(this.flashTime > 0) {
            ctx.fillStyle = '#ffffff';
        } else {
            ctx.fillStyle = this.color;
        }
        // Optimized: Removed shadowBlur
        ctx.beginPath();
        if (this.type === 'SQUARE') ctx.rect(this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        else if (this.type === 'TRIANGLE') { ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x + this.size, this.y + this.size); ctx.lineTo(this.x - this.size, this.y + this.size); }
        else if (this.type === 'SHOOTER') { ctx.moveTo(this.x - this.size, this.y - this.size); ctx.lineTo(this.x + this.size, this.y); ctx.lineTo(this.x - this.size, this.y + this.size); }
        else if (this.type === 'WORM_HEAD' || this.type === 'WORM_BODY') { ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); }
        else if (this.type === 'TANK') { ctx.rect(this.x - this.size, this.y - this.size*0.8, this.size*2, this.size*1.6); }
        else ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill(); 
        if(this.isElite) { ctx.strokeStyle='#ffd700'; ctx.lineWidth=2; ctx.stroke(); }
    }
}

class Boss extends Enemy {
    constructor(x, y) { 
        super('OCTAGON', x, y); 
        this.hp = 5000 * (1 + state.time/300) * state.bossLevel * (state.isVoidMode?2:1); 
        this.maxHp = this.hp; this.size = 60; this.speed = 1.2; this.color = '#bc13fe'; 
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 20); 
        const coins = state.isVoidMode ? 100 : 50; // Increased drop count
        for(let i=0; i<coins; i++) { 
            let it = new Item(this.x + (Math.random()-0.5)*120, this.y + (Math.random()-0.5)*120, 50, 'XP'); 
            it.isCoin = true; it.val = 2000; // Increased Boss Coin Value
            state.items.push(it); 
        } 
        state.boss = null; 
        state.bossRespawnTimer = BOSS_RESPAWN_DELAY; 
        state.bossLevel += 0.5;
        document.getElementById('boss-hud').classList.remove('active'); 
        createPopup("BOSS DEFEATED!", this.x, this.y, '#ffd700');
    }
}

class Item {
    constructor(x, y, val, type = 'XP') {
        this.x = x; this.y = y; this.val = val; this.size = 5; this.type = type; this.isCoin = false;
        if (type === 'HEAL') { this.color = '#ff0055'; this.size = 8; }
        else if (type === 'MAGNET') { this.color = '#0055ff'; this.size = 8; }
        else if (type === 'BOMB') { this.color = '#ffaa00'; this.size = 8; }
        else if (type === 'CHEST') { this.color = '#ffd700'; this.size = 12; }
        else { this.isCoin = false; this.color = '#33ccff'; }
    }
    update(player) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        let range = 100 + (saveData.artifacts.magnet || 0) * 20 + (saveData.upgrades.magnet || 0) * 30; 
        range *= state.sessionStats.pickupRangeMult;
        
        if (this.type === 'MAGNET') range = 150;
        if (dist < range) { this.x += (dx / dist) * 12; this.y += (dy / dist) * 12; }
        if (dist < player.size + this.size) {
            if (this.type === 'HEAL') { 
                const mult = saveData.artifacts.medkit ? 1.5 : 1;
                player.hp = Math.min(player.hp + 30 * mult, player.maxHp); createPopup("+" + (30*mult) + " HP", this.x, this.y, '#f00'); 
            }
            else if (this.type === 'MAGNET') { state.items.forEach(i => { if(i.type === 'XP' || i.isCoin) { i.x = player.x; i.y = player.y; } }); createPopup("MAGNET!", this.x, this.y, '#00f'); }
            else if (this.type === 'BOMB') { state.enemies.forEach(e => { if(!(e instanceof Boss)) e.die(); else e.takeDamage(500); }); createExplosion(player.x, player.y, '#fff', 20); createPopup("BOOM!", this.x, this.y, '#fa0'); }
            else if (this.type === 'CHEST') {
                 addXp(200); 
                 const gold = 30000; // Increased Chest value
                 state.coins += gold; 
                 saveData.coins += gold; // Add to wallet immediately
                 saveData.stats.totalCoins += gold; 
                 createPopup(`CHEST! +${gold}ü™ô`, this.x, this.y, '#ffd700');
                 createExplosion(this.x, this.y, '#ffd700', 10);
            }
            else if (this.isCoin) { 
                // Increased Coin value (base 200)
                const baseVal = this.val || 200;
                const gain = Math.floor(baseVal * (1 + saveData.upgrades.greed * 0.1) * state.sessionStats.greedMult * (saveData.artifacts.skull ? 1.3 : 1));
                state.coins += gain; 
                saveData.coins += gain; // Add to wallet immediately
                saveData.stats.totalCoins += gain; 
                createPopup(`+${gain}ü™ô`, this.x, this.y, '#ffd700');
            } else { 
                addXp(this.val); 
            }
            return true;
        } return false;
    }
    draw(ctx) { 
        ctx.fillStyle = this.color; ctx.beginPath(); 
        if(this.type === 'HEAL') { ctx.rect(this.x-3, this.y-8, 6, 16); ctx.rect(this.x-8, this.y-3, 16, 6); }
        else if(this.type === 'BOMB') { ctx.arc(this.x, this.y, 8, 0, Math.PI*2); }
        else if(this.type === 'MAGNET') { ctx.arc(this.x, this.y, 8, Math.PI, 0); ctx.lineTo(this.x+8, this.y+8); ctx.lineTo(this.x+4, this.y+8); ctx.lineTo(this.x+4, this.y); ctx.lineTo(this.x-4, this.y); ctx.lineTo(this.x-4, this.y+8); ctx.lineTo(this.x-8, this.y+8); }
        else if(this.type === 'CHEST') { 
            ctx.rect(this.x-10, this.y-8, 20, 16); ctx.fill(); 
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x-10, this.y-2, 20, 2); ctx.fillRect(this.x-2, this.y-8, 4, 16);
        }
        else if(this.isCoin) ctx.arc(this.x, this.y, 6, 0, Math.PI*2); else ctx.rect(this.x-3, this.y-3, 6, 6); 
        ctx.fill(); 
    }
}

class Projectile {
    constructor(x, y, vx, vy, dmg, color, duration, size=4, type='bullet', knockback=2) { 
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.dmg = dmg; this.color = color; 
        this.duration = duration * (1 + (saveData.upgrades.duration || 0) * 0.1) * state.sessionStats.durationMult; 
        this.size = size * state.sessionStats.sizeMult * state.sessionStats.areaMult; 
        this.type = type; // bullet, missile, slash, laser, enemy_bullet, boomerang, arrow
        this.hitList = []; this.knockback = knockback;
        this.angle = Math.atan2(vy, vx);
        this.returning = false; // For boomerang
    }
    update() { 
        if (this.type === 'boomerang') {
            if (!this.returning) {
                this.x += this.vx; this.y += this.vy;
                this.duration--;
                if(this.duration < 0) this.returning = true;
            } else {
                const dx = state.player.x - this.x, dy = state.player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const speed = 15 * state.sessionStats.projectileSpeed;
                this.x += (dx/dist) * speed; this.y += (dy/dist) * speed;
                this.angle += 0.3;
                if(dist < 20) return true; // Caught
            }
            return false;
        }

        this.x += this.vx; this.y += this.vy; this.duration--; 
        if(this.type === 'missile' || this.type === 'nuke') {
            if(state.time % 2 === 0) state.particles.push(new Particle(this.x, this.y, '#555', 0, 5, 2)); // Reduced smoke
        }
        return this.duration <= 0; 
    }
    draw(ctx) { 
        ctx.fillStyle = this.color; 
        // Optimized: Removed shadowBlur

        if (this.type === 'slash') {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'laser') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.beginPath(); ctx.rect(-15, -this.size/2, 30, this.size); ctx.fill();
            ctx.restore();
        } else if (this.type === 'arrow') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 5); ctx.lineTo(-10, -5); ctx.fill();
            ctx.restore();
        } else if (this.type === 'boomerang') {
             ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
             ctx.beginPath(); ctx.rect(-10, -3, 20, 6); ctx.fill();
             ctx.beginPath(); ctx.rect(-3, -10, 6, 20); ctx.fill();
             ctx.restore();
        } else if (this.type === 'bullet') {
             ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'missile' || this.type === 'nuke') {
             ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
             ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill();
             ctx.restore();
        } else {
             ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); 
        }
    }
}

class Mine {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; 
        this.radius = radius * state.sessionStats.areaMult; 
        this.active = false; this.timer = 60;
    }
    update() {
        if(this.timer > 0) this.timer--; else this.active = true;
        if (this.active) {
            for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < e.size + 15) { this.explode(); return true; } }
        }
        return false;
    }
    explode() {
        createExplosion(this.x, this.y, '#ff4400', 5, 5);
        for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) { if(e.takeDamage(this.dmg, 5, this.x, this.y)) removeEnemy(e); } }
    }
    draw(ctx) {
        ctx.fillStyle = this.active ? ((state.time % 20 < 10) ? '#ff0000' : '#550000') : '#555';
        ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
        if(this.active) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,50,0,0.2)'; ctx.stroke(); }
    }
}

class IonBeam {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; this.radius = radius;
        this.timer = 60; this.fired = false;
    }
    update() {
        this.timer--;
        if (this.timer === 0) {
            this.fired = true;
            createExplosion(this.x, this.y, '#00ffff', 10, 10);
            state.shockwaves.push(new Shockwave(this.x, this.y, this.radius * 2, '#00ffff'));
            state.enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) e.takeDamage(this.dmg);
            });
        }
        return this.timer < -20; 
    }
    draw(ctx) {
        if (!this.fired) {
            ctx.strokeStyle = `rgba(0, 255, 255, ${(60-this.timer)/60})`;
            ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
            // Targeting circle shrinking
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (this.timer/60), 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = `rgba(0, 255, 255, 0.2)`; ctx.fill();
            // Targeting line
            ctx.strokeStyle = 'rgba(0,255,255,0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x, this.y - 1000); ctx.stroke();
        } else {
            // Beam Effect
            const fade = (20 + this.timer) / 20;
            ctx.fillStyle = `rgba(200, 255, 255, ${fade})`;
            ctx.fillRect(this.x - this.radius, this.y - 1000, this.radius*2, 1000 + this.radius);
            ctx.fillStyle = `rgba(255, 255, 255, ${fade})`;
            ctx.fillRect(this.x - this.radius/2, this.y - 1000, this.radius, 1000 + this.radius);
        }
    }
}

class SpikeBall {
    constructor(player) {
        this.player = player;
        this.x = player.x + 50; this.y = player.y;
        this.vx = 10; this.vy = 10;
        this.radius = 15;
    }
    update(speedMult, areaMult) {
        const speed = 10 * speedMult;
        this.x += this.vx; this.y += this.vy;
        
        // Bounce within a virtual box around player
        const boxSize = 150 * areaMult;
        
        if (this.x > this.player.x + boxSize) { this.x = this.player.x + boxSize; this.vx = -Math.abs(this.vx); }
        if (this.x < this.player.x - boxSize) { this.x = this.player.x - boxSize; this.vx = Math.abs(this.vx); }
        if (this.y > this.player.y + boxSize) { this.y = this.player.y + boxSize; this.vy = -Math.abs(this.vy); }
        if (this.y < this.player.y - boxSize) { this.y = this.player.y - boxSize; this.vy = Math.abs(this.vy); }
        
        // Normalize speed
        const currentSpeed = Math.hypot(this.vx, this.vy);
        if (currentSpeed > 0) {
            this.vx = (this.vx / currentSpeed) * speed;
            this.vy = (this.vy / currentSpeed) * speed;
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#888';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        // Spikes
        for(let i=0; i<8; i++) {
            const a = state.time * 0.1 + (i * Math.PI / 4);
            const sx = this.x + Math.cos(a) * (this.radius + 5);
            const sy = this.y + Math.sin(a) * (this.radius + 5);
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(sx, sy); ctx.strokeStyle='#fff'; ctx.stroke();
        }
    }
}

class Drone {
    constructor(player, offset) { this.player = player; this.offset = offset; this.x = player.x; this.y = player.y; }
    update() {
        const t = state.time * 0.05; const targetX = this.player.x + Math.cos(t + this.offset) * 50; const targetY = this.player.y + Math.sin(t + this.offset) * 50;
        this.x += (targetX - this.x) * 0.1; this.y += (targetY - this.y) * 0.1;
    }
    draw(ctx) { 
        ctx.fillStyle = '#00ffff'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
    }
}

class Singularity {
    constructor(x, y) { this.x = x; this.y = y; this.timer = 180; this.radius = 10; }
    update() {
        this.timer--;
        if (this.timer > 0) {
            if (this.timer > 30) {
                // Pull phase
                this.radius = Math.min(100, this.radius + 1);
                state.enemies.forEach(e => {
                    if (e instanceof Boss) return;
                    const dx = this.x - e.x, dy = this.y - e.y, dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 300 && dist > 10) { e.x += (dx/dist)*3; e.y += (dy/dist)*3; }
                });
            } else {
                // Collapse
                this.radius *= 0.8;
            }
        } else {
            // Explode
            createExplosion(this.x, this.y, '#000', 30);
            state.shockwaves.push(new Shockwave(this.x, this.y, 200, '#000'));
            state.enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < 150) {
                     e.takeDamage(1000);
                }
            });
            return true;
        }
        return false;
    }
    draw(ctx) {
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        // Event Horizon
        ctx.strokeStyle = `rgba(157, 0, 255, ${Math.random()})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI*2); ctx.stroke();
    }
}

class Particle {
    constructor(x, y, color, speed, size=3, life=20) {
        this.x = x; this.y = y; 
        const a = Math.random() * Math.PI * 2; const s = Math.random() * speed;
        this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
        this.color = color; this.life = life + Math.random()*10; this.maxLife = this.life; this.size = size;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life <= 0; }
    draw(ctx) { 
        ctx.fillStyle = this.color; ctx.globalAlpha = this.life/this.maxLife; 
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); 
        ctx.globalAlpha = 1; 
    }
}

class Shockwave {
    constructor(x, y, maxR, color) { this.x = x; this.y = y; this.maxR = maxR; this.r = 1; this.color = color; }
    update() { this.r += 10; return this.r > this.maxR; }
    draw(ctx) {
        ctx.strokeStyle = this.color; ctx.lineWidth = 4 * (1 - this.r/this.maxR);
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
    }
}

// --- Functions ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize canvas
let animationId;

function resize() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function initStars() {
    state.stars = [];
    // Optimized: Reduced star count from 100 to 40
    for(let i=0; i<40; i++) state.stars.push(new Star()); 
}

function openWeaponSelection() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('weapon-screen').classList.remove('hidden');
    renderWeaponSelection();
}

function renderWeaponSelection() {
    const cont = document.getElementById('weapon-cards');
    cont.innerHTML = '';
    const pool = UPGRADES.filter(u => u.type === 'WEAPON' && !u.id.includes('hidden'));
    const options = [];
    
    // Pick 3 random
    while(options.length < 3 && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        options.push(pool[idx]);
        pool.splice(idx, 1);
    }
    
    options.forEach(w => {
        const d = document.createElement('div');
        d.className = 'card';
        d.innerHTML = `<div class="card-icon">${w.icon}</div><div class="card-title">${w.name}</div><div class="card-desc">${w.desc}</div>`;
        d.onclick = () => startGame(w.id);
        cont.appendChild(d);
    });
}

function startGame(startWeaponId) {
    document.querySelectorAll('.ui-layer').forEach(e => e.classList.add('hidden'));
    document.getElementById('hud').classList.remove('hidden');
    document.getElementById('joystick-zone').style.display = 'block';

    state.running = true; state.paused = false; state.gameOver = false;
    state.time = 0; state.score = 0; state.kills = 0; state.coins = 0;
    state.level = 1; state.xp = 0; state.nextLevelXp = 10;
    state.boss = null; state.bossRespawnTimer = 0; state.bossLevel = 1;
    
    // Reset state arrays
    state.enemies = []; state.particles = []; state.items = []; state.projectiles = [];
    state.popups = []; state.shockwaves = []; state.mines = []; state.drones = []; state.voidZones = []; state.ionBeams = []; state.worms = []; state.spikeBalls = [];
    
    // Reset Session Stats
    state.sessionStats = { sizeMult: 1, projectileCount: 0, projectileSpeed: 1, areaMult: 1, durationMult: 1, knockbackMult: 1, dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1, growth: 0 };
    state.weapons = {};
    state.meta = { reroll: saveData.upgrades.reroll, skip: saveData.upgrades.skip, banish: saveData.upgrades.banish, banishedItems: [] };
    
    // Ultimate Ready at Start
    state.ult = { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 }; 
    updateUltBtn();

    state.player = new Player();
    
    addWeapon(startWeaponId);
    
    // Initial Spawn
    for(let i=0; i<5; i++) spawnEnemy();
    initStars();
    
    startLoop();
}

function startLoop() {
    if(animationId) cancelAnimationFrame(animationId);
    let lastT = 0;
    function loop(t) {
        if(!lastT) lastT = t;
        const dt = t - lastT;
        if (state.running && !state.paused) {
            update();
            draw();
            
            // Auto Save every 3 seconds (approx 180 frames)
            if (state.time % 180 === 0) {
                save();
            }
        }
        lastT = t;
        animationId = requestAnimationFrame(loop);
    }
    animationId = requestAnimationFrame(loop);
}

function update() {
    state.time++;
    
    // Difficulty
    if (state.time % 60 === 0) state.score++;
    
    // Spawning
    const spawnRate = Math.max(10, 60 - Math.floor(state.time / 60));
    if (state.time % spawnRate === 0 && state.enemies.length < 300) spawnEnemy();

    // Boss Spawn
    if (state.time % (BOSS_SPAWN_TIME * 60) === 0 && !state.boss && state.bossRespawnTimer <= 0) {
        spawnBoss();
    }
    if (state.bossRespawnTimer > 0) state.bossRespawnTimer--;
    
    // Events
    if (state.time % 1800 === 0 && Math.random() < 0.3) triggerEvent(); 
    if (state.event.timer > 0) {
        state.event.timer--;
        if (state.event.type === 'METEOR' && state.event.timer % 10 === 0) {
            const ex = state.player.x + (Math.random()-0.5)*CANVAS_W/ZOOM;
            const ey = state.player.y + (Math.random()-0.5)*CANVAS_H/ZOOM;
            createExplosion(ex, ey, '#ff5500', 10);
            state.enemies.forEach(e => { if(Math.hypot(e.x-ex, e.y-ey) < 100) e.takeDamage(500); });
        }
        if (state.event.timer === 0) document.getElementById('event-hud').style.display = 'none';
    }

    state.player.update();
    
    // Collision & Logic
    state.enemies = state.enemies.filter(e => {
        e.update(state.player);
        return e.hp > 0;
    });

    state.items = state.items.filter(i => {
        const picked = i.update(state.player);
        return !picked;
    });

    state.projectiles = state.projectiles.filter(p => {
        let hit = false;
        if(p.update()) return false;
        
        // Optimize collision detection with QuadTree or spatial hash if needed, but simple loop for now
        // Simple optimization: only check if near
        for (const e of state.enemies) {
            if (Math.abs(e.x - p.x) > e.size + p.size + 10 || Math.abs(e.y - p.y) > e.size + p.size + 10) continue;
            
            if (Math.hypot(e.x - p.x, e.y - p.y) < e.size + p.size) {
                if (!p.hitList.includes(e)) {
                    if (e.takeDamage(p.dmg, p.knockback, state.player.x, state.player.y)) {
                        removeEnemy(e);
                    }
                    p.hitList.push(e);
                    if (p.type === 'bullet' || p.type === 'enemy_bullet' || p.type === 'arrow') hit = true;
                    // Frost
                    if (state.weapons.frost) { e.frozen = 60 * state.sessionStats.durationMult; }
                }
            }
        }
        return !hit;
    });
    
    state.particles = state.particles.filter(p => !p.update());
    state.popups = state.popups.filter(p => p.update());
    state.shockwaves = state.shockwaves.filter(s => !s.update());
    state.mines = state.mines.filter(m => !m.update());
    state.ionBeams = state.ionBeams.filter(i => !i.update());
    state.singularity && state.singularity.update() && (state.singularity = null);
    
    state.drones.forEach(d => d.update());
    state.spikeBalls.forEach(s => s.update(state.sessionStats.projectileSpeed, state.sessionStats.areaMult));

    updateWeapons();
    updateUI();
    
    if (state.ult.activeTime > 0) state.ult.activeTime--;
    if (!state.ult.ready && state.ult.charge < 100) {
        state.ult.charge += 0.05 + (saveData.upgrades.cooldown * 0.01);
        if (state.ult.charge >= 100) { state.ult.charge = 100; state.ult.ready = true; createPopup("ULTIMATE READY!", state.player.x, state.player.y - 50, '#ff0099'); updateUltBtn(); }
    }
}

function removeEnemy(e) {
    const idx = state.enemies.indexOf(e);
    if(idx > -1) state.enemies.splice(idx, 1);
}

function spawnEnemy() {
    const angle = Math.random() * Math.PI * 2;
    const r = (Math.max(CANVAS_W, CANVAS_H) / 2 / ZOOM) + 50;
    const ex = state.player.x + Math.cos(angle) * r;
    const ey = state.player.y + Math.sin(angle) * r;
    
    const types = ['SQUARE', 'TRIANGLE', 'PENTAGON', 'RHOMBUS', 'SHOOTER', 'VOLATILE', 'TANK', 'DASHER', 'SPLITTER'];
    let type = types[Math.min(types.length-1, Math.floor(state.time / 1200))]; 
    if (Math.random() < 0.2) type = types[Math.floor(Math.random() * Math.min(types.length, 5 + state.level/5))];
    
    // Worm spawn rare
    if (state.time > 3600 && Math.random() < 0.005) { spawnWorm(ex, ey); return; }

    const isElite = Math.random() < (0.01 + (saveData.upgrades.luck||0)*0.005);
    state.enemies.push(new Enemy(type, ex, ey, isElite));
}

function spawnWorm(x, y) {
    const id = Math.random();
    const head = new Enemy('WORM_HEAD', x, y); head.wormId = id;
    state.enemies.push(head); state.worms.push(head);
    for(let i=1; i<8; i++) {
        const body = new Enemy('WORM_BODY', x - i*15, y); body.wormId = id;
        state.enemies.push(body); state.worms.push(body);
    }
}

function spawnBoss() {
    const angle = Math.random() * Math.PI * 2;
    const r = 400;
    const bx = state.player.x + Math.cos(angle) * r;
    const by = state.player.y + Math.sin(angle) * r;
    state.boss = new Boss(bx, by);
    state.enemies.push(state.boss);
    
    const hud = document.getElementById('boss-hud');
    hud.classList.add('active');
    document.getElementById('boss-name').innerText = state.isVoidMode ? "‚ö†Ô∏è VOID MONARCH ‚ö†Ô∏è" : "‚ö†Ô∏è THE HEXAGON ‚ö†Ô∏è";
}

function triggerEvent() {
    const type = Math.random() < 0.5 ? 'METEOR' : 'GOLDRUSH';
    state.event = { type: type, timer: 600 };
    const el = document.getElementById('event-hud');
    el.innerText = type === 'METEOR' ? "‚ö†Ô∏è METEOR SHOWER ‚ö†Ô∏è" : "üí∞ GOLD RUSH üí∞";
    el.style.color = type === 'METEOR' ? '#ff3300' : '#ffd700';
    el.style.display = 'block';
}

function addWeapon(id) {
    if (!state.weapons[id]) {
        state.weapons[id] = { level: 1, timer: 0, evolved: false };
        if (id === 'mines') state.mines.push(new Mine(state.player.x, state.player.y, 10, 50));
        if (id === 'drone') state.drones.push(new Drone(state.player, 0));
        if (id === 'spikedball') state.spikeBalls.push(new SpikeBall(state.player));
    } else {
        state.weapons[id].level++;
        if (state.weapons[id].level === 5) checkEvolution(id);
        if (id === 'drone') state.drones.push(new Drone(state.player, (state.weapons[id].level-1) * (Math.PI/3)));
        if (id === 'spikedball') state.spikeBalls.push(new SpikeBall(state.player));
    }
}

function checkEvolution(wid) {
    const evo = EVOLUTIONS.find(e => e.weapon === wid);
    if (evo) {
        // Just need to have the passive, level doesn't matter for simplicity or max level
        const hasPassive = Object.keys(state.weapons).includes(evo.passive) || (UPGRADES.find(u=>u.id===evo.passive).type==='STAT' && saveData.upgrades[evo.passive] > 0);
        // Evolution happens next level up or immediately? Let's make it a chance in level up
    }
}

function updateWeapons() {
    const p = state.player;
    const stats = state.sessionStats;

    // Blaster
    if (state.weapons.blaster) {
        const w = state.weapons.blaster;
        const cd = w.evolved ? 10 : Math.max(5, 30 - w.level * 3);
        w.timer++;
        if (w.timer > cd * (1 - p.cdReduc)) {
            w.timer = 0;
            let target = getNearestEnemy();
            if (target) {
                const count = 1 + stats.projectileCount + (state.weapons.multishot ? 1 : 0);
                for(let i=0; i<count; i++) {
                    const angle = Math.atan2(target.y - p.y, target.x - p.x) + (i - count/2)*0.1;
                    const vx = Math.cos(angle) * 10 * stats.projectileSpeed;
                    const vy = Math.sin(angle) * 10 * stats.projectileSpeed;
                    state.projectiles.push(new Projectile(p.x, p.y, vx, vy, 15 * w.level, w.evolved?'#ff0099':'#ffff00', 60, w.evolved?8:4, w.evolved?'laser':'bullet'));
                }
            }
        }
    }

    // Blade
    if (state.weapons.blade) {
        const w = state.weapons.blade;
        w.timer++;
        if (w.timer > 50 * (1 - p.cdReduc)) {
            w.timer = 0;
            state.projectiles.push(new Projectile(p.x + (state.facingRight?40:-40), p.y, state.facingRight?2:-2, 0, 25*w.level, '#fff', 10, 40, 'slash', 5));
        }
    }

    // Orbit
    if (state.weapons.orbit) {
        const w = state.weapons.orbit;
        w.timer += 0.05 * stats.projectileSpeed;
        const r = 80 * stats.areaMult;
        const count = w.level + stats.projectileCount;
        for(let i=0; i<count; i++) {
            const angle = w.timer + (i * (Math.PI*2/count));
            const ox = p.x + Math.cos(angle) * r;
            const oy = p.y + Math.sin(angle) * r;
            // Projectile visual only, damage logic via proximity
            state.enemies.forEach(e => {
                if(Math.hypot(e.x - ox, e.y - oy) < 20) e.takeDamage(10 * w.level, 1, p.x, p.y);
            });
            // Draw handled in draw() loop or push temp projectiles?
            // Actually let's just push a short lived projectile every frame for visual or draw manually
             state.particles.push(new Particle(ox, oy, w.evolved?'#000':'#00ccff', 0, 5, 2));
        }
    }

    // Missile
    if (state.weapons.missile) {
        const w = state.weapons.missile;
        w.timer++;
        if (w.timer > 60 * (1 - p.cdReduc)) {
            w.timer = 0;
            let target = getNearestEnemy();
            if (target) {
                const dx = target.x - p.x; const dy = target.y - p.y; const dist = Math.sqrt(dx*dx+dy*dy);
                state.projectiles.push(new Projectile(p.x, p.y, (dx/dist)*5, (dy/dist)*5, 40*w.level, '#ff5500', 100, 6, w.evolved?'nuke':'missile'));
            }
        }
    }

    // Mines
    if (state.weapons.mines) {
        const w = state.weapons.mines;
        w.timer++;
        if (w.timer > 120 * (1 - p.cdReduc)) {
            w.timer = 0;
            state.mines.push(new Mine(p.x, p.y, 50*w.level, 60));
        }
    }

    // Ion Cannon
    if (state.weapons.ion) {
        const w = state.weapons.ion;
        w.timer++;
        if (w.timer > 200 * (1 - p.cdReduc)) {
            w.timer = 0;
            const t = getRandomEnemy();
            if (t) state.ionBeams.push(new IonBeam(t.x, t.y, 100*w.level, 60*stats.areaMult));
        }
    }

    // Boomerang
    if (state.weapons.boomerang) {
        const w = state.weapons.boomerang;
        w.timer++;
        if (w.timer > 60 * (1 - p.cdReduc)) {
            w.timer = 0;
            let target = getNearestEnemy();
            const angle = target ? Math.atan2(target.y-p.y, target.x-p.x) : (state.facingRight?0:Math.PI);
            const vx = Math.cos(angle) * 8 * stats.projectileSpeed;
            const vy = Math.sin(angle) * 8 * stats.projectileSpeed;
            state.projectiles.push(new Projectile(p.x, p.y, vx, vy, 20*w.level, '#00ff88', 40, 8, 'boomerang'));
        }
    }

    // Flamethrower
    if (state.weapons.flame) {
        const w = state.weapons.flame;
        if (state.time % 5 === 0) { // High fire rate
            const angle = (state.facingRight ? 0 : Math.PI) + (Math.random()-0.5)*0.5;
            const vx = Math.cos(angle) * 6;
            const vy = Math.sin(angle) * 6;
            state.projectiles.push(new Projectile(p.x, p.y, vx, vy, 5*w.level, '#ffaa00', 30, 6, 'bullet'));
        }
    }

    // Gauss
    if (state.weapons.gauss) {
        const w = state.weapons.gauss;
        w.timer++;
        if (w.timer > 90 * (1 - p.cdReduc)) {
            w.timer = 0;
            let target = getNearestEnemy();
            const angle = target ? Math.atan2(target.y-p.y, target.x-p.x) : (state.facingRight?0:Math.PI);
            // Instant hit line
            createExplosion(p.x + Math.cos(angle)*300, p.y + Math.sin(angle)*300, '#00ffff', 5);
            // Visual line
            state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle)*30, Math.sin(angle)*30, 60*w.level, '#00ffff', 5, 2, 'laser')); 
            // Hit logic handled by projectile update usually, but for instant hit:
            // Just simulate a super fast projectile or raycast logic here
            // For simplicity, spawn a fast invisible projectile
        }
    }

    // Crossbow
    if (state.weapons.crossbow) {
         const w = state.weapons.crossbow;
         w.timer++;
         if (w.timer > 45 * (1 - p.cdReduc)) {
             w.timer = 0;
             let target = getNearestEnemy();
             const angle = target ? Math.atan2(target.y-p.y, target.x-p.x) : (Math.random()*Math.PI*2);
             state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle)*12, Math.sin(angle)*12, 40*w.level, '#ddd', 60, 5, 'arrow', 10));
         }
    }

    // Singularity (Hidden)
    if (state.weapons.singularity) {
         const w = state.weapons.singularity;
         w.timer++;
         if (w.timer > 600) { // Rare proc
             w.timer = 0;
             state.singularity = new Singularity(p.x, p.y);
         }
    }
}

function getNearestEnemy() {
    let near = null, minDist = 9999;
    for(const e of state.enemies) {
        const d = Math.hypot(e.x - state.player.x, e.y - state.player.y);
        if(d < minDist) { minDist = d; near = e; }
    }
    return near;
}

function getRandomEnemy() {
    if (state.enemies.length === 0) return null;
    return state.enemies[Math.floor(Math.random()*state.enemies.length)];
}

function draw() {
    // Clear Background
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    ctx.save();
    
    // Camera
    const px = state.player.x; const py = state.player.y;
    const cx = CANVAS_W / 2 - px * ZOOM;
    const cy = CANVAS_H / 2 - py * ZOOM;
    ctx.translate(cx + px * (1-ZOOM), cy + py * (1-ZOOM)); // Parallax anchor? No just zoom center
    ctx.setTransform(ZOOM, 0, 0, ZOOM, CANVAS_W/2 - px*ZOOM, CANVAS_H/2 - py*ZOOM);

    // Grid (Lightweight)
    ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
    const gridSize = 100;
    const startX = Math.floor((px - CANVAS_W/2/ZOOM)/gridSize)*gridSize;
    const startY = Math.floor((py - CANVAS_H/2/ZOOM)/gridSize)*gridSize;
    const endX = startX + CANVAS_W/ZOOM + gridSize;
    const endY = startY + CANVAS_H/ZOOM + gridSize;
    
    ctx.beginPath();
    for(let x = startX; x < endX; x+=gridSize) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
    for(let y = startY; y < endY; y+=gridSize) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
    ctx.stroke();

    state.stars.forEach(s => s.draw(ctx));
    
    state.voidZones.forEach(z => { ctx.fillStyle='rgba(100,0,200,0.3)'; ctx.beginPath(); ctx.arc(z.x, z.y, 50, 0, Math.PI*2); ctx.fill(); });
    
    state.mines.forEach(m => m.draw(ctx));
    state.ionBeams.forEach(i => i.draw(ctx));
    state.singularity && state.singularity.draw(ctx);
    state.items.forEach(i => i.draw(ctx));
    state.enemies.forEach(e => e.draw(ctx));
    state.spikeBalls.forEach(s => s.draw(ctx));
    state.player.draw(ctx);
    state.drones.forEach(d => d.draw(ctx));
    state.projectiles.forEach(p => p.draw(ctx));
    state.particles.forEach(p => p.draw(ctx));
    state.shockwaves.forEach(s => s.draw(ctx));
    
    // Popups
    ctx.font = "bold 12px 'Exo 2'";
    state.popups.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillText(p.text, p.x, p.y);
    });

    ctx.restore();
}

function createExplosion(x, y, color, count, size=3) {
    // Optimized: Reduced particle count significantly
    const realCount = Math.ceil(count / 3); 
    for(let i=0; i<realCount; i++) state.particles.push(new Particle(x, y, color, 3, size));
}

function createPopup(text, x, y, color, float=true) {
    state.popups.push({ text, x, y, color, life: 30, update: function() { this.y -= float?1:0; this.life--; return this.life > 0; } });
}

function updateUI() {
    // Top Bar
    document.getElementById('level-display').innerText = state.level;
    document.getElementById('kill-display').innerText = state.kills;
    document.getElementById('coin-display').innerText = state.coins;
    
    const xpPct = (state.xp / state.nextLevelXp) * 100;
    document.getElementById('xp-bar').style.width = xpPct + '%';
    
    const hpPct = (state.player.hp / state.player.maxHp) * 100;
    document.getElementById('hp-bar').style.width = hpPct + '%';
    document.getElementById('hp-text').innerText = `${Math.ceil(state.player.hp)} / ${Math.ceil(state.player.maxHp)}`;

    const m = Math.floor(state.time / 3600);
    const s = Math.floor((state.time % 3600) / 60);
    document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    
    // Boss HUD
    if (state.boss) {
        document.getElementById('boss-hp-fill').style.width = ((state.boss.hp / state.boss.maxHp) * 100) + '%';
    }
}

function addXp(amt) {
    state.xp += amt * (1 + (saveData.upgrades.xp||0)*0.1);
    if (state.xp >= state.nextLevelXp) {
        state.xp -= state.nextLevelXp;
        state.level++;
        state.nextLevelXp = Math.floor(state.nextLevelXp * 1.2);
        createPopup("LEVEL UP!", state.player.x, state.player.y - 40, '#ff00ff');
        showUpgradeScreen();
    }
}

function showUpgradeScreen() {
    state.paused = true;
    document.getElementById('upgrade-screen').classList.remove('hidden');
    document.getElementById('cnt-reroll').innerText = state.meta.reroll;
    document.getElementById('cnt-skip').innerText = state.meta.skip;
    document.getElementById('cnt-banish').innerText = state.meta.banish;
    generateUpgradeCards();
}

function generateUpgradeCards() {
    const cont = document.getElementById('upgrade-cards');
    cont.innerHTML = '';
    
    const pool = [];
    
    // Weapon Upgrades
    UPGRADES.forEach(u => {
        if (state.meta.banishedItems.includes(u.id)) return;
        if (u.type === 'WEAPON') {
            if (state.weapons[u.id]) {
                if(state.weapons[u.id].level < 5) pool.push(u);
            } else {
                if(Object.keys(state.weapons).length < 6) pool.push(u); // Slot limit
            }
        } else if (u.type === 'STAT') {
            pool.push(u);
        }
    });

    const choices = [];
    for(let i=0; i<3; i++) {
        if(pool.length === 0) break;
        const idx = Math.floor(Math.random() * pool.length);
        choices.push(pool[idx]);
        pool.splice(idx, 1);
    }
    
    // Evolution check (Guaranteed if applicable)
    // For simplicity, just mixing them in

    if(choices.length === 0) { // All maxed
        choices.push({id:'heal', name:'ÌíÄ ÌöåÎ≥µ', desc:'Ï≤¥Î†• Î™®Îëê ÌöåÎ≥µ', icon:'üíñ'});
        choices.push({id:'money', name:'ÎèàÎã§Î∞ú', desc:'ÏΩîÏù∏ 500Í∞ú', icon:'üí∞'});
    }

    choices.forEach(c => {
        const d = document.createElement('div');
        d.className = 'card';
        if (state.weapons[c.id]) {
            const lvl = state.weapons[c.id].level;
            d.innerHTML = `<div class="card-type">LV.${lvl} -> ${lvl+1}</div><div class="card-icon">${c.icon}</div><div class="card-title">${c.name}</div><div class="card-desc">${c.desc}</div>`;
        } else {
            d.innerHTML = `<div class="card-type">${c.type === 'WEAPON' ? 'NEW WEAPON' : 'UPGRADE'}</div><div class="card-icon">${c.icon}</div><div class="card-title">${c.name}</div><div class="card-desc">${c.desc}</div>`;
        }
        d.onclick = () => selectUpgrade(c);
        cont.appendChild(d);
    });
}

function selectUpgrade(u) {
    if (u.id === 'heal') { state.player.hp = state.player.maxHp; }
    else if (u.id === 'money') { state.coins += 500; }
    else if (u.type === 'WEAPON') { addWeapon(u.id); }
    else {
        // Apply Stat
        if (u.id === 'heal_stat') state.player.hp += 30; // Emergency Heal
        else {
            // Apply temp session buff
            if(u.id === 'giant') state.sessionStats.sizeMult += 0.15;
            if(u.id === 'multishot') state.sessionStats.projectileCount += 1;
            if(u.id === 'sniper') state.sessionStats.projectileSpeed += 0.2;
            if(u.id === 'area') state.sessionStats.areaMult += 0.15;
            if(u.id === 'duration') state.sessionStats.durationMult += 0.15;
            if(u.id === 'knockback') state.sessionStats.knockbackMult += 0.2;
            if(u.id === 'pickup') state.sessionStats.pickupRangeMult += 0.3;
            if(u.id === 'dash_cd') state.sessionStats.dashCdMult *= 0.9;
            if(u.id === 'greed') state.sessionStats.greedMult += 0.2;
            if(u.id === 'growth') { state.sessionStats.growth += 0.05; state.player.maxHp *= 1.05; state.player.hp += 5; }
            if(u.id === 'armor') state.sessionStats.armor += 1;
        }
    }
    
    // Growth Upgrade Logic (Heal on level up)
    if (saveData.upgrades.growth > 0) {
        state.player.hp = Math.min(state.player.hp + state.player.maxHp * 0.1, state.player.maxHp);
    }

    document.getElementById('upgrade-screen').classList.add('hidden');
    state.paused = false;
}

// Meta Upgrades (Reroll/Skip)
function doReroll() {
    if (state.meta.reroll > 0) { state.meta.reroll--; document.getElementById('cnt-reroll').innerText = state.meta.reroll; generateUpgradeCards(); }
}
function doSkip() {
    if (state.meta.skip > 0) { state.meta.skip--; document.getElementById('upgrade-screen').classList.add('hidden'); state.paused = false; state.xp += state.nextLevelXp * 0.2; }
}
let banishMode = false;
function toggleBanishMode() {
    if (state.meta.banish <= 0) return;
    banishMode = !banishMode;
    document.getElementById('btn-banish').style.borderColor = banishMode ? '#f00' : '#555';
    // Update visuals on cards to show they are bannable?
}

// Input Handling
window.addEventListener('keydown', e => {
    if (state.keys.hasOwnProperty(e.key)) state.keys[e.key] = true;
    if (e.code === 'Space' && !state.keys.space) { state.player && state.player.dash(); state.keys.space = true; }
    if (e.key === 'Escape') togglePause();
});
window.addEventListener('keyup', e => {
    if (state.keys.hasOwnProperty(e.key)) state.keys[e.key] = false;
    if (e.code === 'Space') state.keys.space = false;
});

// Touch / Joystick
const zone = document.getElementById('joystick-zone');
const base = document.getElementById('joystick-base');
const knob = document.getElementById('joystick-knob');

zone.addEventListener('pointerdown', e => {
    state.pointer.id = e.pointerId; state.pointer.down = true;
    state.joystick.active = true;
    state.joystick.originX = e.clientX; state.joystick.originY = e.clientY;
    base.style.display = 'block'; knob.style.display = 'block';
    base.style.left = e.clientX + 'px'; base.style.top = e.clientY + 'px';
    knob.style.left = e.clientX + 'px'; knob.style.top = e.clientY + 'px';
    
    const now = Date.now();
    if (now - state.lastTap < 300) state.player.dash();
    state.lastTap = now;
});

zone.addEventListener('pointermove', e => {
    if (!state.joystick.active || e.pointerId !== state.pointer.id) return;
    const dx = e.clientX - state.joystick.originX;
    const dy = e.clientY - state.joystick.originY;
    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 60);
    const angle = Math.atan2(dy, dx);
    const kx = state.joystick.originX + Math.cos(angle) * dist;
    const ky = state.joystick.originY + Math.sin(angle) * dist;
    knob.style.left = kx + 'px'; knob.style.top = ky + 'px';
    state.joystick.dx = (Math.cos(angle) * dist) / 60;
    state.joystick.dy = (Math.sin(angle) * dist) / 60;
});

const endJoystick = () => {
    state.joystick.active = false; state.joystick.dx = 0; state.joystick.dy = 0;
    base.style.display = 'none'; knob.style.display = 'none';
};
zone.addEventListener('pointerup', endJoystick);
zone.addEventListener('pointercancel', endJoystick);

// Mouse Wheel Zoom
window.addEventListener('wheel', e => {
    if (state.paused) return;
    ZOOM += e.deltaY * -0.001;
    ZOOM = Math.min(Math.max(0.5, ZOOM), 1.5);
    const ind = document.getElementById('zoom-indicator');
    ind.innerText = 'x' + ZOOM.toFixed(1);
    ind.style.opacity = 1;
    clearTimeout(state.zoomTimer);
    state.zoomTimer = setTimeout(() => ind.style.opacity = 0, 1000);
}, {passive: true});

// Ultimate
function useUltimate() {
    if (!state.ult.ready || state.paused) return;
    
    // Trigger Effect
    state.ult.ready = false; state.ult.charge = 0; state.ult.activeTime = 600; // 10s effect duration
    updateUltBtn();
    
    const type = saveData.currentUlt;
    createPopup("ULTIMATE ACTIVATED!", state.player.x, state.player.y - 60, '#ff0099');
    
    if (type === 'nuclear') {
        state.shockwaves.push(new Shockwave(state.player.x, state.player.y, 1000, '#ff3300'));
        createExplosion(state.player.x, state.player.y, '#ff3300', 50);
        state.enemies.forEach(e => {
            if(!(e instanceof Boss)) e.takeDamage(9999); else e.takeDamage(2000);
        });
        document.body.style.background = '#300';
        setTimeout(() => document.body.style.background = '#000', 100);
    } else if (type === 'chrono') {
        state.enemies.forEach(e => e.frozen = 300); // 5 sec freeze
        document.body.style.filter = 'grayscale(100%)';
        setTimeout(() => document.body.style.filter = 'none', 5000);
    } else if (type === 'berserk') {
        state.player.cdReduc = 0.9; // 90% CD reduction
        state.player.speed *= 2;
        setTimeout(() => { state.player.speed /= 2; state.player.cdReduc = new Player().cdReduc; }, 10000);
    }
}

function updateUltBtn() {
    const btn = document.getElementById('ult-btn');
    if (state.ult.ready) { btn.classList.remove('disabled'); btn.classList.add('ready'); }
    else { btn.classList.add('disabled'); btn.classList.remove('ready'); }
}

function togglePause() {
    if (state.gameOver) return;
    state.paused = !state.paused;
    if (state.paused) {
        document.getElementById('pause-screen').classList.remove('hidden');
        document.getElementById('pause-dmg').innerText = Math.round(state.player.dmgMult * 100) + '%';
        document.getElementById('pause-area').innerText = Math.round(state.sessionStats.areaMult * 100) + '%';
        document.getElementById('pause-spd').innerText = Math.round(state.player.speed/3 * 100) + '%';
        document.getElementById('pause-crit').innerText = Math.round(state.player.critChance * 100) + '%';
        document.getElementById('pause-greed').innerText = Math.round(saveData.upgrades.greed * 10) + '%';
    } else {
        document.getElementById('pause-screen').classList.add('hidden');
    }
}

function endGame() {
    state.running = false; state.gameOver = true;
    saveData.stats.totalTime += state.time;
    if (state.time > saveData.stats.maxTime) saveData.stats.maxTime = state.time;
    save();
    
    // Check Achievements
    ACHIEVEMENTS.forEach(a => {
        if (!saveData.achievements.includes(a.id) && a.check(saveData.stats)) {
            saveData.achievements.push(a.id);
            saveData.coins += a.reward; saveData.stats.totalCoins += a.reward;
            alert(`ÏóÖÏ†Å Îã¨ÏÑ±: ${a.name}\nÎ≥¥ÏÉÅ: ${a.reward} ÏΩîÏù∏`);
        }
    });
    save();

    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('final-score').innerText = document.getElementById('timer').innerText;
    document.getElementById('final-coins').innerText = `ÌöçÎìù: ${state.coins} ü™ô`;
}

function quitGame() {
    state.running = false;
    document.getElementById('pause-screen').classList.add('hidden');
    showStartScreen();
}

function showStartScreen() {
    document.querySelectorAll('.ui-layer').forEach(e => e.classList.add('hidden'));
    document.getElementById('start-screen').classList.remove('hidden');
    document.getElementById('joystick-zone').style.display = 'none';
    document.body.className = ''; // Reset Void Mode visually in menu
    
    // Update currency display
    document.getElementById('start-currency').innerText = saveData.coins;
}

// Menus
function openShop() { 
    document.getElementById('start-screen').classList.add('hidden'); 
    document.getElementById('shop-screen').classList.remove('hidden');
    renderShop();
}
function closeShop() { document.getElementById('shop-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function renderShop() {
    const cont = document.getElementById('shop-container');
    cont.innerHTML = '';
    document.getElementById('shop-currency').innerText = saveData.coins;
    
    // Upgrades List
    const upgrades = [
        {id:'damage', name:'Í≥µÍ≤©Î†•', desc:'Îç∞ÎØ∏ÏßÄ +10%'}, {id:'health', name:'ÏµúÎåÄ Ï≤¥Î†•', desc:'Ï≤¥Î†• +10'},
        {id:'speed', name:'Ïù¥Îèô ÏÜçÎèÑ', desc:'ÏÜçÎèÑ +5%'}, {id:'cooldown', name:'Ïø®ÌÉÄÏûÑ', desc:'Ïø®ÌÉÄÏûÑ -5%'},
        {id:'magnet', name:'ÏûêÏÑù', desc:'ÌöçÎìù Î∞òÍ≤Ω +30%'}, {id:'greed', name:'ÌÉêÏöï', desc:'Í≥®Îìú ÌöçÎìù +10%'},
        {id:'luck', name:'ÌñâÏö¥', desc:'ÌñâÏö¥ +1'}, {id:'regen', name:'Ïû¨ÏÉù', desc:'Ï≤¥Î†• Ïû¨ÏÉù +1/Ï¥à'},
        {id:'revive', name:'Î∂ÄÌôú', desc:'ÏÇ¨Îßù Ïãú Î∂ÄÌôú +1'}, {id:'evasion', name:'ÌöåÌîº', desc:'ÌöåÌîºÏú® +5%'},
        {id:'reroll', name:'Î¶¨Î°§', desc:'Î†àÎ≤®ÏóÖ Î¶¨Î°§ ÌöüÏàò +1'}, {id:'skip', name:'Ïä§ÌÇµ', desc:'Î†àÎ≤®ÏóÖ Ïä§ÌÇµ ÌöüÏàò +1'},
        {id:'banish', name:'Î∞∞ÎãàÏãú', desc:'ÏïÑÏù¥ÌÖú Î∞∞ÎãàÏãú ÌöüÏàò +1'}, {id:'growth', name:'ÏÑ±Ïû•', desc:'Î†àÎ≤®ÏóÖ Ïãú ÌöåÎ≥µ'},
        // New
        {id:'velocity', name:'Í∞ÄÏÜçÍ∏∞', desc:'Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ +10%'}, {id:'crit_dmg', name:'ÏπòÎ™ÖÌÉÄ Ïó∞Îßà', desc:'ÏπòÎ™ÖÌÉÄ Îç∞ÎØ∏ÏßÄ +20%'},
        {id:'healing', name:'ÏùëÍ∏â Ï≤òÏπò', desc:'ÌöåÎ≥µ Ìö®Ïú® +20%'}, {id:'invuln', name:'Î≥¥Ìò∏Îßâ', desc:'ÌîºÍ≤© Î¨¥Ï†ÅÏãúÍ∞Ñ +0.2Ï¥à'},
        {id:'agility', name:'Î∞òÏÇ¨ Ïã†Í≤Ω', desc:'ÎåÄÏãú Ïø®ÌÉÄÏûÑ -5%'}
    ];

    upgrades.forEach(u => {
        const d = document.createElement('div');
        d.className = 'shop-item';
        const lvl = saveData.upgrades[u.id] || 0;
        const cost = Math.floor(SHOP_BASE_COST * Math.pow(1.5, lvl));
        d.innerHTML = `<h3>${u.name} (Lv.${lvl})</h3><p>${u.desc}</p><button class="btn btn-small" onclick="buyUpgrade('${u.id}', ${cost})">${cost} ü™ô</button>`;
        cont.appendChild(d);
    });
}

function buyUpgrade(id, cost) {
    if (saveData.coins >= cost) {
        saveData.coins -= cost;
        if(!saveData.upgrades[id]) saveData.upgrades[id] = 0;
        saveData.upgrades[id]++;
        save(); renderShop();
    } else alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.");
}

function openArmory() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('armory-screen').classList.remove('hidden');
    renderArmory();
}
function closeArmory() { document.getElementById('armory-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function renderArmory() {
    const cont = document.getElementById('armory-container');
    cont.innerHTML = '';
    document.getElementById('armory-currency').innerText = saveData.coins;
    
    const items = [
        {id:'weapon', name:'ÌîåÎùºÏ¶àÎßà ÎùºÏù¥Ìîå', icon:'üî´', desc:'Í≥µÍ≤©Î†• +5%'},
        {id:'helmet', name:'Ï†ÑÏà† Ìó¨Î©ß', icon:'ü™ñ', desc:'Ïø®ÌÉÄÏûÑ -1%'},
        {id:'suit', name:'ÎÇòÎÖ∏ ÏäàÌä∏', icon:'üëï', desc:'Ï≤¥Î†• +10'},
        {id:'gloves', name:'ÌååÏõå Í±¥ÌãÄÎ¶ø', icon:'ü•ä', desc:'ÏπòÎ™ÖÌÉÄ +1%'},
        {id:'boots', name:'Ï§ëÎ†• Î∂ÄÏ∏†', icon:'ü•æ', desc:'Ïù¥ÎèôÏÜçÎèÑ +0.1'},
        {id:'ring', name:'ÏóêÎÑàÏßÄ ÎßÅ', icon:'üíç', desc:'Î≤îÏúÑ/ÏßÄÏÜç +5%'}
    ];

    items.forEach(i => {
        const lvl = saveData.equipment[i.id] || 0;
        const cost = Math.floor(200 * Math.pow(1.2, lvl));
        
        const d = document.createElement('div');
        d.className = 'card';
        // Calculate display value
        let val = 0;
        if(i.id === 'suit') val = lvl * 10;
        else if(i.id === 'boots') val = lvl * 0.1;
        else if(i.id === 'helmet' || i.id === 'gloves') val = lvl * 1;
        else val = lvl * 5;

        d.innerHTML = `
            <div class="card-icon">${i.icon}</div>
            <div class="card-title">${i.name}</div>
            <div class="card-type">Lv. ${lvl}</div>
            <div class="card-desc">${i.desc} <br><span style="color:var(--primary)">(ÌòÑÏû¨: +${Math.round(val*10)/10}${i.id==='suit'||i.id==='boots'?'':'%'})</span></div>
            <button class="btn btn-small" onclick="upgradeEquip('${i.id}', ${cost})">${cost} ü™ô</button>
        `;
        cont.appendChild(d);
    });
}
function upgradeEquip(id, cost) {
    if (saveData.coins >= cost) { 
        saveData.coins -= cost; 
        if(!saveData.equipment[id]) saveData.equipment[id] = 0;
        saveData.equipment[id]++; 
        save(); 
        renderArmory(); 
    }
}

function openClassScreen() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('class-screen').classList.remove('hidden');
    renderClasses();
}
function closeClassScreen() { document.getElementById('class-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderClasses() {
    const cont = document.getElementById('class-container');
    cont.innerHTML = '';
    document.getElementById('class-currency').innerText = saveData.coins;
    
    CLASSES.forEach(c => {
        const d = document.createElement('div');
        const owned = saveData.ownedClasses.includes(c.id);
        const selected = saveData.currentClass === c.id;
        d.className = 'shop-item ' + (selected ? 'selected' : '');
        
        let btnHtml = '';
        if (selected) btnHtml = `<button class="btn btn-small btn-secondary" disabled>Ïû•Ï∞© Ï§ë</button>`;
        else if (owned) btnHtml = `<button class="btn btn-small" onclick="selectClass('${c.id}')">Ïû•Ï∞©</button>`;
        else btnHtml = `<button class="btn btn-small btn-accent" onclick="buyClass('${c.id}', ${c.cost})">${c.cost} ü™ô</button>`;
        
        d.innerHTML = `
            <div class="selected-check">‚úî</div>
            <div style="font-size:2rem; margin-bottom:5px;">${c.icon}</div>
            <h3>${c.name}</h3><p>${c.desc}</p>${btnHtml}
        `;
        cont.appendChild(d);
    });
}
function buyClass(id, cost) {
    if(saveData.coins >= cost) { saveData.coins -= cost; saveData.ownedClasses.push(id); saveData.currentClass = id; save(); renderClasses(); }
}
function selectClass(id) { saveData.currentClass = id; save(); renderClasses(); }

function openSkillScreen() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('skill-screen').classList.remove('hidden');
    renderSkills();
}
function closeSkillScreen() { document.getElementById('skill-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderSkills() {
    const cont = document.getElementById('skill-container');
    cont.innerHTML = '';
    ULTIMATES.forEach(u => {
        const owned = saveData.ownedUlts.includes(u.id);
        const selected = saveData.currentUlt === u.id;
        const d = document.createElement('div');
        d.className = 'ult-card ' + (selected ? 'selected' : '');
        d.innerHTML = `<div class="ult-icon-l">${u.icon}</div><div><div style="font-weight:bold; color:${u.color}">${u.name}</div><div style="font-size:0.8rem; color:#aaa;">${u.desc}</div></div>`;
        if (owned) d.onclick = () => { saveData.currentUlt = u.id; save(); renderSkills(); };
        cont.appendChild(d);
    });
}

function openAchieveScreen() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('achieve-screen').classList.remove('hidden');
    renderAchievements();
}
function closeAchieveScreen() { document.getElementById('achieve-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderAchievements() {
    const cont = document.getElementById('achieve-container');
    cont.innerHTML = '';
    document.getElementById('achieve-currency').innerText = saveData.coins;
    
    ACHIEVEMENTS.forEach(a => {
        const completed = saveData.achievements.includes(a.id);
        const d = document.createElement('div');
        d.className = 'achieve-item ' + (completed ? 'completed' : '');
        d.innerHTML = `
            <div class="achieve-info"><div class="achieve-title">${a.name}</div><div class="achieve-desc">${a.desc}</div></div>
            <div class="achieve-reward">${completed ? 'ÏôÑÎ£åÎê®' : a.reward + ' ü™ô'}</div>
        `;
        cont.appendChild(d);
    });
}

function openGacha() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('gacha-screen').classList.remove('hidden');
    document.getElementById('gacha-currency').innerText = saveData.coins;
    document.getElementById('gacha-result').style.display = 'none';
    document.getElementById('gacha-buttons').style.display = 'flex';
}
function closeGacha() { document.getElementById('gacha-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function rollGacha() {
    if (saveData.coins < GACHA_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }
    saveData.coins -= GACHA_COST;
    
    // Pick random artifact
    const art = ARTIFACTS[Math.floor(Math.random() * ARTIFACTS.length)];
    if (!saveData.artifacts[art.id]) saveData.artifacts[art.id] = 0;
    saveData.artifacts[art.id]++;
    save();
    
    showGachaResult(art.icon, art.name, `Î†àÎ≤® ${saveData.artifacts[art.id]} (Ïúº)Î°ú Í∞ïÌôîÎê®!`);
    document.getElementById('gacha-currency').innerText = saveData.coins;
}

function rollSkinGacha() {
    if (saveData.coins < SKIN_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }
    saveData.coins -= SKIN_COST;
    
    const unowned = SKINS.filter(s => !saveData.ownedSkins.includes(s.id));
    let skin;
    if (unowned.length === 0) {
        // Fallback compensation
        saveData.coins += 500;
        showGachaResult('üí∞', 'Ï§ëÎ≥µ Î≥¥ÏÉÅ', 'Î™®Îì† Ïä§ÌÇ®ÏùÑ Î≥¥Ïú† Ï§ëÏûÖÎãàÎã§. 500ÏΩîÏù∏ Î∞òÌôò.');
    } else {
        skin = unowned[Math.floor(Math.random() * unowned.length)];
        saveData.ownedSkins.push(skin.id);
        showGachaResult(skin.icon, skin.name, 'ÏÉàÎ°úÏö¥ Ïä§ÌÇ® ÌöçÎìù!');
    }
    save();
    document.getElementById('gacha-currency').innerText = saveData.coins;
}

function showGachaResult(icon, name, desc) {
    document.getElementById('gacha-buttons').style.display = 'none';
    const res = document.getElementById('gacha-result');
    res.style.display = 'flex';
    document.getElementById('g-icon').innerText = icon;
    document.getElementById('g-name').innerText = name;
    document.getElementById('g-desc').innerText = desc;
}
function closeGachaResult() {
    document.getElementById('gacha-result').style.display = 'none';
    document.getElementById('gacha-buttons').style.display = 'flex';
}

function openWardrobe() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('wardrobe-screen').classList.remove('hidden');
    renderWardrobe();
}
function closeWardrobe() { document.getElementById('wardrobe-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderWardrobe() {
    const cont = document.getElementById('skin-container');
    cont.innerHTML = '';
    SKINS.forEach(s => {
        const owned = saveData.ownedSkins.includes(s.id);
        const selected = saveData.currentSkin === s.id;
        const d = document.createElement('div');
        d.className = 'skin-item ' + (selected ? 'selected' : '') + (owned ? '' : ' locked');
        d.innerHTML = `
            ${!owned ? '<div class="lock-icon">üîí</div>' : ''}
            <div class="skin-preview">${s.icon}</div>
            <div class="skin-name">${s.name}</div>
        `;
        if (owned) d.onclick = () => { saveData.currentSkin = s.id; save(); renderWardrobe(); };
        cont.appendChild(d);
    });
}

function openArtifactScreen() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('artifact-screen').classList.remove('hidden');
    const cont = document.getElementById('artifact-container');
    cont.innerHTML = '';
    ARTIFACTS.forEach(a => {
        const lvl = saveData.artifacts[a.id] || 0;
        const d = document.createElement('div');
        d.className = 'card ' + (lvl===0 ? 'locked' : '');
        d.innerHTML = `<div class="card-icon">${a.icon}</div><div class="card-title">${a.name}</div><div class="card-desc">${a.desc}</div><div class="card-type">LV.${lvl}</div>`;
        cont.appendChild(d);
    });
}
function closeArtifactScreen() { document.getElementById('artifact-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function openSettings() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('settings-screen').classList.remove('hidden');
    updateVoidToggle();
}
function closeSettings() { document.getElementById('settings-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function toggleVoidMode() {
    state.isVoidMode = !state.isVoidMode;
    updateVoidToggle();
}
function updateVoidToggle() {
    const t = document.getElementById('void-mode-toggle');
    const cb = document.getElementById('void-mode-cb');
    if (state.isVoidMode) {
        t.classList.add('active'); cb.checked = true; document.body.classList.add('void-mode');
    } else {
        t.classList.remove('active'); cb.checked = false; document.body.classList.remove('void-mode');
    }
}

// Init
resize();
showStartScreen(); // Initialize UI with currency

</script>
</body>
</html>