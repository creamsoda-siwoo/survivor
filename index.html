
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IFKO SURVIVOR: EVOLUTION</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß¨</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Exo+2:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ffcc;
            --primary-dark: #00cc99;
            --accent: #ff0099;
            --accent-dark: #cc0077;
            --gold: #ffd700;
            --void: #9d00ff;
            --bg: #050508;
            --glass: rgba(20, 20, 30, 0.9);
            --border: rgba(255, 255, 255, 0.15);
            --font: 'Noto Sans KR', 'Exo 2', sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        body {
            margin: 0; padding: 0; background-color: #000; color: white;
            font-family: var(--font); overflow: hidden;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            background: var(--bg); overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

        /* Effects */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 15; opacity: 0.3;
        }
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 16;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; z-index: 20;
        }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }

        /* Credits */
        #credits {
            position: absolute; top: 15px; right: 15px;
            color: rgba(255,255,255,0.3); font-size: 0.7rem; font-weight: 700;
            z-index: 100; pointer-events: none; letter-spacing: 1px;
        }

        /* HUD */
        #hud { padding: 15px; justify-content: space-between; height: 100%; z-index: 30; }
        .top-row { 
            display: flex; flex-direction: column; align-items: center; width: 100%; pointer-events: none; 
        }
        
        .stat-box {
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid var(--border); backdrop-filter: blur(4px);
            display: flex; align-items: center; gap: 15px;
            pointer-events: auto;
        }
        .stat-text { font-size: 0.9rem; font-weight: 700; display: flex; gap: 10px; align-items: center; }
        
        .bar-container {
            background: rgba(0,0,0,0.5); border-radius: 5px;
            overflow: hidden; position: relative;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .bar-fill { height: 100%; transition: width 0.2s ease-out; border-radius: 5px; }
        #hp-bar { background: linear-gradient(90deg, #ff3333, #ff6666); width: 100%; box-shadow: 0 0 8px rgba(255,51,51,0.5); }
        #xp-bar { background: linear-gradient(90deg, #00ccff, #33ffff); width: 0%; box-shadow: 0 0 8px rgba(51,255,255,0.5); }

        #timer {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 1.8rem; font-weight: 900; color: #fff;
            text-shadow: 0 0 15px rgba(0,0,0,0.8); letter-spacing: 2px; font-family: 'Exo 2';
        }

        #pause-btn {
            width: 45px; height: 45px; background: var(--glass);
            border: 1px solid var(--border); border-radius: 12px;
            color: white; font-size: 1.2rem; display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #pause-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.1); }

        /* Ultimate Button */
        #ult-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            background: radial-gradient(circle, #ff0099, #550033);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 0 20px rgba(255,0,153,0.6);
            cursor: pointer; pointer-events: auto; z-index: 40; transition: 0.2s;
        }
        #ult-btn:active { transform: scale(0.9); }
        #ult-btn.disabled { filter: grayscale(1) brightness(0.4); box-shadow: none; border-color: #333; cursor: not-allowed; }
        #ult-icon { font-size: 2rem; }
        #ult-label { font-size: 0.7rem; font-weight: bold; margin-top: -2px; }

        /* Boss HUD */
        #boss-hud {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 500px; opacity: 0; transition: opacity 0.5s;
            display: flex; flex-direction: column; align-items: center;
        }
        #boss-hud.active { opacity: 1; }
        #boss-name { color: #bc13fe; font-weight: 900; font-size: 1rem; margin-bottom: 5px; letter-spacing: 3px; text-shadow: 0 0 10px #bc13fe; }
        #boss-hp-container { width: 100%; height: 20px; background: rgba(0,0,0,0.8); border: 2px solid #4a0b63; border-radius: 4px; overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #9d00ff, #bc13fe); box-shadow: 0 0 10px #9d00ff; }

        /* Common Menu Styles */
        .menu-screen {
            background: rgba(8, 8, 12, 0.98);
            justify-content: center; align-items: center; text-align: center;
            backdrop-filter: blur(10px); z-index: 50;
        }
        
        .screen-title {
            font-size: 2.5rem; margin: 0 0 5px 0;
            background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; color: transparent;
            font-family: 'Exo 2'; font-style: italic; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        .screen-subtitle { color: #888; margin-bottom: 25px; font-size: 0.9rem; letter-spacing: 1px; }

        /* Buttons */
        .btn {
            padding: 12px 24px; font-size: 1rem;
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            border: none; border-radius: 8px;
            color: #000; font-family: var(--font); font-weight: 900;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            position: relative; overflow: hidden;
            min-width: 140px;
        }
        .btn::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent); pointer-events: none;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 255, 204, 0.5); filter: brightness(1.1); }
        .btn:active { transform: translateY(1px); box-shadow: 0 2px 10px rgba(0, 255, 204, 0.3); }

        .btn-secondary {
            background: linear-gradient(135deg, #333, #444); color: #ccc;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn-secondary:hover { box-shadow: 0 6px 15px rgba(0,0,0,0.7); color: #fff; }
        
        .btn-danger {
            background: linear-gradient(135deg, #990033, #ff3333); color: white;
            box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent-dark), var(--accent)); color: white;
            box-shadow: 0 4px 15px rgba(255, 0, 153, 0.3);
        }
        .btn-accent:hover { box-shadow: 0 6px 20px rgba(255, 0, 153, 0.5); }

        /* Menu Grid */
        .menu-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;
            max-width: 500px; width: 100%; margin-bottom: 20px;
        }
        .menu-grid .btn { width: 100%; padding: 10px; font-size: 0.9rem; }

        /* Upgrade Cards */
        .card-container {
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
            padding: 20px; max-height: 70vh; overflow-y: auto; width: 100%;
        }
        .card {
            width: 160px; min-height: 250px;
            background: linear-gradient(160deg, rgba(25,25,35,0.9), rgba(10,10,15,0.95));
            border: 1px solid var(--border); border-radius: 12px;
            padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--primary); box-shadow: 0 10px 25px rgba(0, 255, 204, 0.2); }
        .card:active { transform: scale(0.98); }
        
        .card-icon { font-size: 3rem; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.1)); }
        .card-title { font-size: 1.1rem; font-weight: 700; color: var(--primary); margin-bottom: 8px; line-height: 1.2; }
        .card-desc { font-size: 0.8rem; color: #aaa; line-height: 1.4; margin-bottom: 10px; flex-grow: 1; }
        .card-type { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; width: 100%; }
        
        .card.evolution { border-color: var(--accent); background: linear-gradient(160deg, #2a0a1a, #1a050d); animation: pulse 2s infinite; }
        .card.evolution .card-title { color: var(--accent); }
        .card.evolution:hover { box-shadow: 0 10px 30px rgba(255, 0, 153, 0.5); }

        .card.hidden-tier { border-color: var(--void); background: linear-gradient(160deg, #120024, #05000a); }
        .card.hidden-tier .card-title { color: var(--void); text-shadow: 0 0 5px var(--void); }

        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } 50% { box-shadow: 0 0 25px rgba(255,0,153,0.6); } 100% { box-shadow: 0 0 10px rgba(255,0,153,0.3); } }

        .card.locked { opacity: 0.7; filter: grayscale(1); border-style: dashed; }

        /* Lists */
        .list-layout {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px; width: 100%; max-width: 900px; padding: 10px;
            max-height: 65vh; overflow-y: auto;
        }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid var(--border);
            border-radius: 10px; padding: 12px; display: flex; flex-direction: column; align-items: center;
            transition: 0.2s; position: relative;
        }
        .shop-item:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.3); }
        .shop-item h3 { margin: 5px 0; color: #fff; font-size: 0.95rem; }
        .shop-item p { margin: 0 0 10px 0; color: #888; font-size: 0.8rem; text-align: center; line-height: 1.3; }
        
        .currency-display {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.3rem; color: var(--gold); font-weight: 900;
            display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.6);
            padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,215,0,0.3);
        }

        /* Skin Grid */
        .skin-grid { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 700px; }
        .skin-item {
            width: 100px; height: 140px; border: 2px solid #444; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; background: rgba(20,20,20,0.8); position: relative;
        }
        .skin-item.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(0,255,204,0.3); background: rgba(0,255,204,0.05); }
        .skin-item.locked { opacity: 0.6; border-color: #222; cursor: not-allowed; }
        .skin-preview { font-size: 3rem; margin-bottom: 10px; }
        .skin-name { font-size: 0.85rem; color: #ddd; font-weight: bold; }
        .lock-icon { position: absolute; top: 8px; right: 8px; font-size: 1rem; color: #777; }

        /* Gacha */
        #gacha-result {
            width: 300px; padding: 30px; border: 1px solid var(--gold);
            background: radial-gradient(circle at center, #222, #050505);
            border-radius: 20px; display: none; flex-direction: column; align-items: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2); animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .gacha-icon { font-size: 6rem; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(255,255,255,0.5)); }

        /* Joystick */
        #joystick-zone { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        #joystick-base {
            position: absolute; width: 120px; height: 120px;
            border: 2px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #joystick-knob {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(255,255,255,0.5);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 6;
        }
        #dash-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.8rem; pointer-events: none; letter-spacing: 1px;
            text-shadow: 0 1px 2px #000;
        }
        #scroll-hint {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 0.7rem; pointer-events: none; letter-spacing: 1px;
        }

        /* Class & Ultimate Selection */
        .class-badge { font-size: 0.7rem; background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; margin-top: 5px; }
        .selected-check { position: absolute; top: 10px; right: 10px; color: var(--primary); font-size: 1.2rem; display: none; }
        .shop-item.selected { border-color: var(--primary); background: rgba(0, 255, 204, 0.05); }
        .shop-item.selected .selected-check { display: block; }
        
        .ult-card {
            width: 100%; border: 1px solid #444; border-radius: 10px; background: rgba(0,0,0,0.5);
            padding: 15px; margin-bottom: 10px; cursor: pointer; display:flex; align-items:center; gap: 15px; transition: 0.2s;
        }
        .ult-card:hover { border-color: #666; background: rgba(255,255,255,0.05); }
        .ult-card.selected { border-color: var(--accent); background: rgba(255,0,153,0.1); }
        .ult-icon-l { font-size: 2.5rem; }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="credits">v10.0 EVOLUTION UPDATE</div>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <canvas id="gameCanvas"></canvas>

        <!-- Joystick UI -->
        <div id="joystick-zone" class="interactive"></div>
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
        <div id="dash-hint">SPACE / DOUBLE TAP : DASH</div>
        <div id="scroll-hint">MOUSE WHEEL : ZOOM</div>

        <!-- HUD -->
        <div id="hud" class="ui-layer hidden">
            <div class="top-row">
                <!-- Stats and Controls -->
                <div style="display:flex; width:100%; justify-content:space-between; align-items: flex-start; margin-bottom: 5px;">
                    <div class="stat-box" style="width: fit-content;">
                        <div class="stat-text"><span style="color:var(--primary)">LV.<span id="level-display">1</span></span></div>
                        <div class="stat-text"><span style="color:#ccc">üíÄ <span id="kill-display">0</span></span></div>
                        <div class="stat-text"><span style="color:var(--gold)">ü™ô <span id="coin-display">0</span></span></div>
                    </div>
                    <div id="pause-btn" onclick="togglePause()">‚ùö‚ùö</div>
                </div>
                
                <!-- XP Bar -->
                <div class="bar-container" style="width: 100%; max-width: 600px; height: 8px; margin-bottom: 5px;">
                    <div id="xp-bar" class="bar-fill"></div>
                </div>

                <!-- HP Bar -->
                <div class="bar-container" style="width: 300px; height: 24px; border: 2px solid rgba(255,50,50,0.6); background: rgba(0,0,0,0.8);">
                    <div id="hp-bar" class="bar-fill"></div>
                    <div id="hp-text" style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; justify-content:center; align-items:center; font-size:0.8rem; font-weight:bold; text-shadow:0 1px 2px #000;">100 / 100</div>
                </div>
            </div>
            
            <div id="timer">00:00</div>

            <div id="boss-hud">
                <div id="boss-name">‚ö†Ô∏è THE HEXAGON ‚ö†Ô∏è</div>
                <div id="boss-hp-container"><div id="boss-hp-fill"></div></div>
            </div>

            <div id="ult-btn" class="interactive disabled" onclick="useUltimate()">
                <div id="ult-icon">üí£Ô∏è</div>
                <div id="ult-label">ULTIMATE</div>
            </div>
        </div>

        <!-- Upgrade Screen -->
        <div id="upgrade-screen" class="ui-layer hidden interactive menu-screen">
            <h2 class="screen-title" style="font-size:2rem;">SYSTEM UPGRADE</h2>
            <p class="screen-subtitle">Í∞ïÌôî Î™®ÎìàÏùÑ ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§</p>
            <div class="card-container" id="upgrade-cards"></div>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="ui-layer hidden interactive menu-screen" style="display:flex; flex-direction:column;">
            <h1 class="screen-title">PAUSED</h1>
            <p class="screen-subtitle">ÏûëÏ†Ñ ÏùºÏãú Ï§ëÏßÄ</p>
            <div style="display:flex; gap:15px; flex-direction:column;">
                <button class="btn" onclick="togglePause()">Í≥ÑÏÜçÌïòÍ∏∞</button>
                <button class="btn btn-secondary" onclick="quitGame()">Í∑∏ÎßåÌïòÍ∏∞</button>
            </div>
        </div>

        <!-- Shop Screen -->
        <div id="shop-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="shop-currency">0</span></div>
            <h1 class="screen-title">LABORATORY</h1>
            <p class="screen-subtitle">Í∏∞Î≥∏ Îä•Î†•Ïπò ÏòÅÍµ¨ Í∞ïÌôî</p>
            <div class="list-layout" id="shop-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeShop()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Armory Screen -->
        <div id="armory-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="armory-currency">0</span></div>
            <h1 class="screen-title">ARMORY</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ Ïû•ÎπÑ ÏóÖÍ∑∏Î†àÏù¥Îìú</p>
            <div class="list-layout" id="armory-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArmory()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Class Screen -->
        <div id="class-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="class-currency">0</span></div>
            <h1 class="screen-title">BARRACKS</h1>
            <p class="screen-subtitle">Ï†ÑÌà¨ ÏßÅÏóÖ ÏÑ†ÌÉù Î∞è Ìï¥Í∏à</p>
            <div class="list-layout" id="class-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeClassScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Skill Screen (Ultimate) -->
        <div id="skill-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SKILLS</h1>
            <p class="screen-subtitle">Í∂ÅÍ∑πÍ∏∞ ÏÑ†ÌÉù</p>
            <div id="skill-container" style="width: 100%; max-width: 500px; text-align: left;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeSkillScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Gacha Screen -->
        <div id="gacha-screen" class="ui-layer hidden interactive menu-screen">
            <div class="currency-display">ü™ô <span id="gacha-currency">0</span></div>
            <h1 class="screen-title">SUPPLY DEPOT</h1>
            <p class="screen-subtitle">Î≥¥Í∏âÌíà Ìà¨Ìïò ÏöîÏ≤≠</p>
            
            <div id="gacha-result">
                <div class="gacha-icon" id="g-icon">üíé</div>
                <div class="gacha-name" id="g-name">???</div>
                <div class="gacha-desc" id="g-desc">...</div>
                <button class="btn" onclick="closeGachaResult()">ÌôïÏù∏</button>
            </div>
            
            <div id="gacha-buttons" style="display:flex; flex-direction:column; gap:15px;">
                <button id="gacha-roll-btn" class="btn" onclick="rollGacha()">
                    <div>Ïú†Î¨º ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">300 ü™ô</div>
                </button>
                <button id="skin-roll-btn" class="btn btn-accent" onclick="rollSkinGacha()">
                    <div>Ïä§ÌÇ® ÎΩëÍ∏∞</div><div style="font-size:0.8rem; opacity:0.8">1000 ü™ô</div>
                </button>
            </div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeGacha()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Artifact Dex Screen -->
        <div id="artifact-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">ARTIFACTS</h1>
            <p class="screen-subtitle">ÏàòÏßëÌïú Ïú†Î¨º ÎèÑÍ∞ê</p>
            <div class="card-container" id="artifact-container" style="justify-content: flex-start;"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeArtifactScreen()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Wardrobe Screen -->
        <div id="wardrobe-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">WARDROBE</h1>
            <p class="screen-subtitle">Ïô∏Ìòï Î≥ÄÍ≤Ω</p>
            <div class="skin-grid" id="skin-container"></div>
            <button class="btn btn-secondary" style="margin-top:20px;" onclick="closeWardrobe()">Îí§Î°úÍ∞ÄÍ∏∞</button>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="ui-layer menu-screen interactive" style="display:flex;">
            <h1 class="screen-title" style="font-size:3.5rem; margin-bottom:10px; color:var(--primary);">IFKO<br><span style="font-size:2.5rem; color:#fff;">EVOLUTION</span></h1>
            <p class="screen-subtitle" style="margin-bottom:40px;">PLANET : IFKO-X10</p>
            
            <button class="btn" style="width:220px; height:60px; font-size:1.3rem; margin-bottom:30px; box-shadow: 0 0 20px var(--primary);" onclick="startGame()">MISSION START</button>
            
            <div class="menu-grid">
                <button class="btn btn-secondary" onclick="openClassScreen()">ÏßÅÏóÖÏÜå</button>
                <button class="btn btn-secondary" onclick="openSkillScreen()">Ïä§ÌÇ¨</button>
                <button class="btn btn-secondary" onclick="openArmory()">Î¨¥Í∏∞Í≥†</button>
                <button class="btn btn-secondary" onclick="openShop()">Ïó∞Íµ¨ÏÜå</button>
                <button class="btn btn-secondary" onclick="openGacha()">Î≥¥Í∏âÏÜå</button>
                <button class="btn btn-secondary" onclick="openArtifactScreen()">ÎèÑÍ∞ê</button>
                <button class="btn btn-secondary" onclick="openWardrobe()">Ïò∑Ïû•</button>
                <button class="btn btn-secondary" onclick="openSettings()">ÏÑ§Ï†ï</button>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="ui-layer hidden interactive menu-screen">
            <h1 class="screen-title">SETTINGS</h1>
            <p class="screen-subtitle">ÏãúÏä§ÌÖú ÏÑ§Ï†ï</p>
            <div style="display:flex; flex-direction:column; gap:15px;">
                <button class="btn btn-danger" onclick="resetData()">Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî</button>
                <button class="btn btn-secondary" onclick="closeSettings()">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-layer hidden menu-screen interactive">
            <h1 class="screen-title" style="color:#ff3333; background:none;">MISSION FAILED</h1>
            <p id="final-score" style="font-size:1.5rem; margin-bottom:5px;">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 00:00</p>
            <p id="final-coins" style="font-size:1.2rem; color:var(--gold); margin-bottom:30px;">ÌöçÎìù: 0 ü™ô</p>
            <div style="display:flex; gap:15px;">
                <button class="btn" onclick="restartGame()">Ïû¨ÏãúÎèÑ</button>
                <button class="btn btn-secondary" onclick="showStartScreen()">Î©îÏù∏ÏúºÎ°ú</button>
            </div>
        </div>
    </div>

<script>
/**
 * IFKO SURVIVOR v10.0 - Evolution Update
 * Features: Scroll Zoom, Hidden Weapons, Evolution System, Expanded Upgrades, Ultimate Switching
 */

// --- Constants ---
const CANVAS_W = window.innerWidth;
const CANVAS_H = window.innerHeight;
let ZOOM = 0.75; 
const BOSS_SPAWN_TIME = 60; 
const BOSS_RESPAWN_DELAY = 60 * 60; 
const SHOP_BASE_COST = 50;
const GACHA_COST = 300;
const SKIN_COST = 1000;

// --- Definitions ---
const CLASSES = [
    { id: 'soldier', name: 'ÏÜîÏ†Ä', desc: 'Í∑†Ìòï Ïû°Ìûå Ï†ÑÌà¨ ÏöîÏõê', stats: { hp: 0, dmg: 0, spd: 0, cd: 0 }, cost: 0, icon: 'ü™ñ' },
    { id: 'guardian', name: 'Í∞ÄÎîîÏñ∏', desc: 'Ï≤¥Î†• +50, Ïù¥ÎèôÏÜçÎèÑ -10%', stats: { hp: 50, dmg: 0, spd: -0.5, cd: 0 }, cost: 1000, icon: 'üõ°Ô∏è' },
    { id: 'assassin', name: 'Ïñ¥ÏåîÏã†', desc: 'Í≥µÍ≤©Î†• +30%, Ï≤¥Î†• -30', stats: { hp: -30, dmg: 0.3, spd: 1.0, cd: 0 }, cost: 2000, icon: 'üó°Ô∏è' },
    { id: 'mage', name: 'ÏïÑÌÅ¨Î©îÏù¥ÏßÄ', desc: 'Ïø®ÌÉÄÏûÑ -10%, Ï≤¥Î†• -20', stats: { hp: -20, dmg: 0.1, spd: 0, cd: 0.1 }, cost: 3000, icon: 'üîÆ' }
];

const ULTIMATES = [
    { id: 'nuclear', name: 'Îâ¥ÌÅ¥Î¶¨Ïñ¥', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥Ïùò Ï†ÅÏóêÍ≤å Í¥¥Î©∏Ï†ÅÏù∏ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.', icon: '‚ò¢Ô∏è', color: '#ff3300' },
    { id: 'chrono', name: 'ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨', desc: '5Ï¥à ÎèôÏïà ÏãúÍ∞ÑÏùÑ Î©àÏ∂îÍ≥† ÏûêÏã†ÏùÄ Í∞ÄÏÜçÌï©ÎãàÎã§.', icon: '‚è≥', color: '#00ccff' },
    { id: 'berserk', name: 'Î≤ÑÏÑúÏª§', desc: '10Ï¥à ÎèôÏïà Í≥µÍ≤©ÏÜçÎèÑÏôÄ Ïù¥ÎèôÏÜçÎèÑÍ∞Ä 200% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.', icon: 'ü©∏', color: '#ff0055' }
];

const SKINS = [
    { id: 'default', name: 'Í∏∞Î≥∏', icon: '‚è∫Ô∏è' },
    { id: 'neko', name: 'Ïù¥ÌîÑÎÉ•', icon: 'üê±' },
    { id: 'bot', name: 'Î°úÎ¥á', icon: 'ü§ñ' },
    { id: 'star', name: 'Ïä§ÌÉÄ', icon: '‚≠ê' },
    { id: 'demon', name: 'Îç∞Î™¨', icon: 'üòà' },
    { id: 'alien', name: 'Ïô∏Í≥ÑÏù∏', icon: 'üëΩ' }
];

const ARTIFACTS = [
    { id: 'cube', name: 'Í≥†ÎåÄ ÌÅêÎ∏å', desc: 'Í≥µÍ≤©Î†• +10%', icon: 'üßä' },
    { id: 'feather', name: 'Î∞îÎûåÏùò ÍπÉÌÑ∏', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5%', icon: 'ü™∂' },
    { id: 'chip', name: 'AI Ïπ©ÏÖã', desc: 'Ïø®ÌÉÄÏûÑ Í∞êÏÜå -5%', icon: 'üíæ' },
    { id: 'magnet', name: 'Ï¥àÏ†ÑÎèÑ ÏûêÏÑù', desc: 'ÏûêÏÑù Î≤îÏúÑ +20%', icon: 'üß≤' },
    { id: 'fang', name: 'Ìù°ÌòàÏùò ÏÜ°Í≥≥Îãà', desc: 'Ï≤òÏπò Ïãú Ï≤¥Î†• ÌöåÎ≥µ +1', icon: 'üßõ' },
    { id: 'axe', name: 'Í¥ëÏ†ÑÏÇ¨Ïùò ÎèÑÎÅº', desc: 'Ï≤¥Î†•Ïù¥ ÎÇÆÏùÑÏàòÎ°ù Í∞ïÌï¥Ïßê', icon: 'ü™ì' },
    { id: 'watch', name: 'Ï†ïÏßÄÎêú ÏãúÍ≥Ñ', desc: 'Ï†Å Ïù¥ÎèôÏÜçÎèÑ -10%', icon: '‚è±Ô∏è' },
    { id: 'thorn', name: 'Í∞ÄÏãú Í∞ëÏò∑', desc: 'ÌîºÍ≤© Ïãú Î∞òÏÇ¨ ÌîºÌï¥', icon: 'üåµ' }
];

// Expanded Upgrade List (System Upgrades)
const UPGRADES = [
    // Weapons
    { id: 'blaster', name: 'Î∏îÎûòÏä§ÌÑ∞', desc: 'Í∏∞Î≥∏ ÏÇ¨Í≤© Î¨¥Í∏∞', type: 'WEAPON', icon: 'üî´' },
    { id: 'orbit', name: 'ÏúÑÏÑ± Ìè¨Í≤©', desc: 'Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî ÏóêÎÑàÏßÄÏ≤¥', type: 'WEAPON', icon: 'ü™ê' },
    { id: 'field', name: 'Ï†ÑÍ∏∞Ïû•', desc: 'Ï£ºÎ≥Ä ÏßÄÏÜç ÌîºÌï¥', type: 'WEAPON', icon: '‚ö°' },
    { id: 'tesla', name: 'ÌÖåÏä¨Îùº ÏΩîÏùº', desc: 'Ïó∞ÏáÑ Î≤àÍ∞ú Í≥µÍ≤©', type: 'WEAPON', icon: 'üå©Ô∏è' },
    { id: 'missile', name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', desc: 'Ï∂îÏ†Å Ìè≠Î∞ú ÎØ∏ÏÇ¨Ïùº', type: 'WEAPON', icon: 'üöÄ' },
    { id: 'gravity', name: 'Ï§ëÎ†• Î∂ïÍ¥¥', desc: 'Ï†ÅÏùÑ Î™®ÏúºÎäî Î∏îÎûôÌôÄ', type: 'WEAPON', icon: 'üåå' },
    { id: 'mines', name: 'ÏñëÏûê ÏßÄÎ¢∞', desc: 'ÏÑ§ÏπòÌòï ÏßÄÎ¢∞', type: 'WEAPON', icon: 'üí£' },
    { id: 'drone', name: 'ÏûêÏú® ÎìúÎ°†', desc: 'Ìò∏ÏúÑ ÎìúÎ°†', type: 'WEAPON', icon: 'üöÅ' },
    { id: 'voidwalker', name: 'Î≥¥Ïù¥Îìú ÏõåÏª§', desc: '[ÌûàÎì†] Í≥µÌóàÏùò ÌãàÏùÑ ÏóΩÎãàÎã§', type: 'HIDDEN', icon: 'üßø', weight: 0.05 },
    
    // Stats (Original + New)
    { id: 'heal', name: 'Í∏¥Í∏â ÏàòÎ¶¨', desc: 'Ï≤¥Î†• 30% ÌöåÎ≥µ', type: 'STAT', icon: '‚ù§Ô∏è' },
    { id: 'giant', name: 'Í±∞ÎåÄÌôî', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ +15%', type: 'STAT', icon: 'üêò' },
    { id: 'multishot', name: 'Î©ÄÌã∞ÏÉ∑', desc: 'Ìà¨ÏÇ¨Ï≤¥ Í∞úÏàò +1 (ÏùºÎ∂Ä Î¨¥Í∏∞)', type: 'STAT', icon: 'üçí' },
    { id: 'sniper', name: 'Ïä§ÎÇòÏù¥Ìçº', desc: 'Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ +20%', type: 'STAT', icon: 'üéØ' },
    { id: 'knockback', name: 'Ï∂©Í≤©ÌÉÑ', desc: 'ÎÑâÎ∞± ÌååÏõå Ï¶ùÍ∞Ä', type: 'STAT', icon: 'ü•ä' },
    { id: 'armor', name: 'Ìã∞ÌÉÄÎäÑ Ïû•Í∞ë', desc: 'Î∞õÎäî ÌîºÌï¥ -2', type: 'STAT', icon: 'üõ°Ô∏è' },
    { id: 'area', name: 'Ï¶ùÌè≠Í∏∞', desc: 'Î≤îÏúÑ Í≥µÍ≤© Î∞òÍ≤Ω +15%', type: 'STAT', icon: 'üì°' },
    { id: 'duration', name: 'Í≥†Ìö®Ïú® Î∞∞ÌÑ∞Î¶¨', desc: 'Î¨¥Í∏∞ ÏßÄÏÜçÏãúÍ∞Ñ +15%', type: 'STAT', icon: 'üîã' },
    { id: 'pickup', name: 'ÏûêÍ∏∞Ïû•', desc: 'ÏïÑÏù¥ÌÖú ÌöçÎìù Î∞òÍ≤Ω +30%', type: 'STAT', icon: 'üß≤' },
    { id: 'dash_cd', name: 'Î∂ÄÏä§ÌÑ∞', desc: 'ÎåÄÏãú Ïø®ÌÉÄÏûÑ -10%', type: 'STAT', icon: 'üëü' },
    { id: 'greed', name: 'Ï±ÑÍµ¥Ïûê', desc: 'Í≥®Îìú ÌöçÎìù +20%', type: 'STAT', icon: 'üí∞' }
];

// Evolution Recipes
const EVOLUTIONS = [
    { weapon: 'blaster', passive: 'sniper', evolveTo: 'exterminator', name: 'ÏóëÏä§ÌÑ∞ÎØ∏ÎÑ§Ïù¥ÌÑ∞', desc: 'Î∏îÎûòÏä§ÌÑ∞ ÏßÑÌôî: Í≥†ÏÜç Í¥ÄÌÜµ Î†àÏù¥Ï†Ä', icon: 'üëπ' },
    { weapon: 'orbit', passive: 'area', evolveTo: 'blackhole', name: 'Ïù¥Î≤§Ìä∏ Ìò∏ÎùºÏù¥Ï¶å', desc: 'ÏúÑÏÑ± ÏßÑÌôî: Ï†ÅÏùÑ Í∞àÏïÑÎ≤ÑÎ¶¨Îäî Î∏îÎûôÌôÄ ÎßÅ', icon: '‚ö´' },
    { weapon: 'tesla', passive: 'multishot', evolveTo: 'thundergod', name: 'ÎáåÏã†', desc: 'ÌÖåÏä¨Îùº ÏßÑÌôî: ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌÉÄÍ≤©', icon: '‚ö°' },
    { weapon: 'missile', passive: 'giant', evolveTo: 'nuke', name: 'Ìåª Îß®', desc: 'ÎØ∏ÏÇ¨Ïùº ÏßÑÌôî: Ï†ÑÏà† ÌïµÎ¨¥Í∏∞', icon: '‚ò¢Ô∏è' }
];

// --- Persistent Save Data ---
const DEFAULT_DATA = {
    coins: 0,
    currentSkin: 'default',
    ownedSkins: ['default'],
    currentClass: 'soldier',
    ownedClasses: ['soldier'],
    currentUlt: 'nuclear',
    ownedUlts: ['nuclear'],
    upgrades: { 
        damage: 0, health: 0, speed: 0, greed: 0, 
        cooldown: 0, magnet: 0, crit: 0, regen: 0, 
        revive: 0, luck: 0, evasion: 0, xp: 0, duration: 0,
        armor: 0, knockback: 0
    },
    equipment: { weapon: 0, armor: 0, boots: 0 },
    artifacts: {},
    stats: { totalKills: 0, totalTime: 0, totalCoins: 0 }
};

let saveData = loadData();

function loadData() {
    const d = localStorage.getItem('ifko_evo_v10');
    if(!d) return JSON.parse(JSON.stringify(DEFAULT_DATA));
    const parsed = JSON.parse(d);
    // Deep merge for safety
    const newData = JSON.parse(JSON.stringify(DEFAULT_DATA));
    // Simple merge logic
    for (let key in parsed) {
        if (typeof parsed[key] === 'object' && !Array.isArray(parsed[key])) {
            newData[key] = { ...newData[key], ...parsed[key] };
        } else {
            newData[key] = parsed[key];
        }
    }
    return newData;
}

function save() {
    localStorage.setItem('ifko_evo_v10', JSON.stringify(saveData));
}

function resetData() {
    if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
        saveData = JSON.parse(JSON.stringify(DEFAULT_DATA));
        save();
        alert("Ï¥àÍ∏∞Ìôî ÏôÑÎ£å.");
        closeSettings();
        location.reload();
    }
}

// --- Game State ---
const state = {
    running: false, paused: false, gameOver: false,
    lastTime: 0, time: 0, score: 0, kills: 0, coins: 0, level: 1, xp: 0, nextLevelXp: 10,
    keys: { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false },
    pointer: { x: 0, y: 0, down: false, id: null },
    joystick: { active: false, originX: 0, originY: 0, dx: 0, dy: 0 },
    lastTap: 0,
    player: null, enemies: [], particles: [], items: [], projectiles: [], 
    boss: null, bossRespawnTimer: 0, bossLevel: 1,
    popups: [], shockwaves: [], gravityWells: [], mines: [], drones: [], voidZones: [],
    weapons: {
        blaster: { level: 1, cd: 0, maxCd: 40, evolved: false },
        orbit: { level: 0, cd: 0, angle: 0, count: 1, evolved: false },
        field: { level: 0, cd: 0, radius: 80, evolved: false },
        tesla: { level: 0, cd: 0, maxCd: 120, evolved: false },
        missile: { level: 0, cd: 0, maxCd: 80, evolved: false },
        gravity: { level: 0, cd: 0, maxCd: 300, evolved: false },
        mines: { level: 0, cd: 0, maxCd: 120, evolved: false },
        drone: { level: 0, cd: 0, maxCd: 40, evolved: false },
        voidwalker: { level: 0, cd: 0, maxCd: 60 } // Hidden
    },
    sessionStats: { 
        sizeMult: 1, projectileCount: 0, projectileSpeed: 1, 
        areaMult: 1, durationMult: 1, knockbackMult: 1, 
        dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1
    },
    ult: { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 }
};

// --- Classes ---

class Player {
    constructor() {
        this.x = 0; this.y = 0;
        
        const job = CLASSES.find(c => c.id === saveData.currentClass) || CLASSES[0];
        
        const artDmg = (saveData.artifacts.cube || 0) * 0.1;
        const artSpd = (saveData.artifacts.feather || 0) * 0.05;
        const artCd = (saveData.artifacts.chip || 0) * 0.05;
        
        const shopDmg = saveData.upgrades.damage * 0.1;
        const shopHp = saveData.upgrades.health * 10;
        const shopSpd = saveData.upgrades.speed * 0.05;
        const shopCd = (saveData.upgrades.cooldown || 0) * 0.05;
        const shopCrit = (saveData.upgrades.crit || 0) * 0.05 + (saveData.upgrades.luck || 0) * 0.02;
        const shopRegen = (saveData.upgrades.regen || 0) * 1;
        const shopRevive = (saveData.upgrades.revive || 0);
        const shopEvasion = (saveData.upgrades.evasion || 0) * 0.05;
        const shopArmor = (saveData.upgrades.armor || 0);
        const shopKnockback = (saveData.upgrades.knockback || 0) * 0.2;

        const equipDmg = saveData.equipment.weapon * 0.2; 
        const equipHp = saveData.equipment.armor * 20;    
        const equipSpd = saveData.equipment.boots * 0.05; 
        const equipCd = saveData.equipment.boots * 0.02;  

        this.maxHp = 100 + job.stats.hp + shopHp + equipHp;
        this.hp = this.maxHp;
        this.baseSpeed = (3 + job.stats.spd + shopSpd + artSpd + equipSpd);
        this.speed = this.baseSpeed;
        this.dmgMult = 1 + job.stats.dmg + shopDmg + artDmg + equipDmg;
        this.cdReduc = Math.min(0.6, job.stats.cd + artCd + equipCd + shopCd); 
        this.critChance = shopCrit;
        this.regenRate = shopRegen;
        this.revives = shopRevive;
        this.evasion = shopEvasion;
        
        // Initial session stats from shop
        state.sessionStats.armor = shopArmor;
        state.sessionStats.knockbackMult = 1 + shopKnockback;

        this.size = 20;
        this.invuln = 0;
        this.dashCd = 0; this.dashTime = 0; this.dashVec = {x:0, y:0};
        this.skin = saveData.currentSkin;
    }

    update() {
        // Regen
        if (this.regenRate > 0 && state.time % 180 === 0 && this.hp < this.maxHp) {
            this.hp = Math.min(this.hp + this.regenRate, this.maxHp);
            createPopup('+', this.x, this.y - 20, '#0f0');
        }

        if (this.dashTime > 0) {
            this.x += this.dashVec.x * 15; this.y += this.dashVec.y * 15;
            this.dashTime--;
            if(this.dashTime % 3 === 0) state.particles.push(new Particle(this.x, this.y, '#00ffcc', 10, 10));
        } else {
            let dx = 0, dy = 0;
            if (state.joystick.active) { dx += state.joystick.dx; dy += state.joystick.dy; }
            
            if (state.keys.w || state.keys.ArrowUp) dy -= 1;
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1;
            if (state.keys.d || state.keys.ArrowRight) dx += 1;

            if (dx !== 0 || dy !== 0) { 
                const len = Math.sqrt(dx*dx + dy*dy); 
                if (len > 1) { dx /= len; dy /= len; } 
                else if (len > 0 && !state.joystick.active) { dx /= len; dy /= len; } 
            }

            if (dx !== 0 || dy !== 0) { this.x += dx * this.speed; this.y += dy * this.speed; }
        }
        if (this.dashCd > 0) this.dashCd--;
        if (this.invuln > 0) this.invuln--;
    }
    
    dash() {
        if (this.dashCd > 0) return;
        let dx = 0, dy = 0;
        if (state.joystick.active) { dx = state.joystick.dx; dy = state.joystick.dy; } 
        else if (state.keys.w || state.keys.a || state.keys.s || state.keys.d || state.keys.ArrowUp || state.keys.ArrowLeft || state.keys.ArrowDown || state.keys.ArrowRight) {
            if (state.keys.w || state.keys.ArrowUp) dy -= 1; 
            if (state.keys.s || state.keys.ArrowDown) dy += 1;
            if (state.keys.a || state.keys.ArrowLeft) dx -= 1; 
            if (state.keys.d || state.keys.ArrowRight) dx += 1;
            const len = Math.sqrt(dx*dx + dy*dy); 
            if (len > 0) { dx /= len; dy /= len; }
        } else dx = 1;

        this.dashVec = {x: dx, y: dy};
        this.dashTime = 10; 
        this.dashCd = Math.floor(120 * (1 - this.cdReduc) * state.sessionStats.dashCdMult);
        createExplosion(this.x, this.y, '#ffffff', 5);
    }

    takeDamage(amt) {
        if (this.dashTime > 0 || this.invuln > 0) return;
        
        if (Math.random() < this.evasion) {
            createPopup("MISS", this.x, this.y - 30, '#aaa');
            return;
        }

        // Apply Armor
        amt = Math.max(1, amt - state.sessionStats.armor);

        this.hp -= amt;
        this.invuln = 30;
        const thorns = saveData.artifacts.thorn || 0;
        if (thorns > 0) {
            state.enemies.forEach(e => {
                if(Math.hypot(e.x - this.x, e.y - this.y) < 100) e.takeDamage(amt * thorns * 0.5);
            });
        }
        createExplosion(this.x, this.y, '#ff0000', 5);
        state.shockwaves.push(new Shockwave(this.x, this.y, 50, '#ff0000'));
        
        if (this.hp <= 0) {
            if (this.revives > 0) {
                this.revives--;
                this.hp = this.maxHp * 0.5;
                this.invuln = 120;
                createExplosion(this.x, this.y, '#fff', 50);
                createPopup("REVIVE!", this.x, this.y, '#fff');
                state.enemies.forEach(e => {
                    const dx = e.x - this.x, dy = e.y - this.y;
                    e.pushX = dx * 3; e.pushY = dy * 3;
                });
            } else {
                endGame();
            }
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw Dash Indicator
        if(this.dashCd > 0) {
            ctx.beginPath(); ctx.arc(0, 0, this.size + 8, 0, (Math.PI * 2) * (1 - this.dashCd/(120*(1-this.cdReduc)*state.sessionStats.dashCdMult)));
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
        }

        let color = '#00ffcc';
        if (state.weapons.blaster.evolved) color = '#ff0099';
        if (this.invuln > 0 && Math.floor(Date.now()/50)%2===0) color = '#fff';
        if (state.ult.activeTime > 0) color = '#ff3300';
        
        ctx.fillStyle = color; ctx.shadowBlur = 20; ctx.shadowColor = color;

        if (this.skin === 'neko') {
            ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-22, -25); ctx.lineTo(-5, -18); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(22, -25); ctx.lineTo(5, -18); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-7, -2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(7, -2, 4, 0, Math.PI*2); ctx.fill();
        } else if (this.skin === 'bot') {
            ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, -30); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, -33, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillRect(-this.size, -this.size, this.size*2, this.size*2);
            ctx.fillStyle = '#000'; ctx.fillRect(-15, -5, 30, 8);
        } else if (this.skin === 'star') {
            ctx.save(); ctx.rotate(Date.now() / 200); ctx.beginPath();
            for(let i=0; i<5; i++) {
                ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*25, -Math.sin((18+i*72)/180*Math.PI)*25);
                ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*12, -Math.sin((54+i*72)/180*Math.PI)*12);
            }
            ctx.closePath(); ctx.fill(); ctx.restore();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5, -2, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5, -2, 3, 0, Math.PI*2); ctx.fill();
        } else if (this.skin === 'demon') {
             ctx.beginPath(); ctx.moveTo(-10, -15); ctx.lineTo(-20, -35); ctx.lineTo(-5, -20); ctx.fill();
             ctx.beginPath(); ctx.moveTo(10, -15); ctx.lineTo(20, -35); ctx.lineTo(5, -20); ctx.fill();
             ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
             ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(-10,-5); ctx.lineTo(-2,0); ctx.lineTo(-10,5); ctx.fill(); ctx.beginPath(); ctx.moveTo(10,-5); ctx.lineTo(2,0); ctx.lineTo(10,5); ctx.fill();
        } else if (this.skin === 'alien') {
             ctx.beginPath(); ctx.ellipse(0, -5, this.size, this.size*1.2, 0, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(-8, -5, 5, 8, 0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(8, -5, 5, 8, -0.2, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(-6, -4, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6, -4, 4, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class Enemy {
    constructor(type, x, y) {
        this.type = type; this.x = x; this.y = y; this.pushX = 0; this.pushY = 0; this.frozen = 0;
        const scaler = 1 + (state.time / 180);
        if (type === 'SQUARE') { this.hp = 10*scaler; this.speed = 1.5; this.size = 15; this.color = '#ff3333'; this.dmg = 10; }
        else if (type === 'TRIANGLE') { this.hp = 5*scaler; this.speed = 2.5; this.size = 12; this.color = '#ffcc00'; this.dmg = 15; }
        else if (type === 'PENTAGON') { this.hp = 20*scaler; this.speed = 1.0; this.size = 20; this.color = '#33ff33'; this.dmg = 20; }
        else if (type === 'RHOMBUS') { this.hp = 15*scaler; this.speed = 4.0; this.size = 14; this.color = '#00ccff'; this.dmg = 15; }
        else if (type === 'OCTAGON') { this.hp = 80*scaler; this.speed = 0.8; this.size = 30; this.color = '#9900ff'; this.dmg = 30; }
        else if (type === 'SWARM') { this.hp = 2*scaler; this.speed = 3.0; this.size = 8; this.color = '#bc13fe'; this.dmg = 5; }
        else { this.hp = 10; this.speed = 1; this.size = 10; this.color = '#fff'; this.dmg = 5; }
        
        if (saveData.artifacts.watch) this.speed *= 0.9;
        this.baseSpeed = this.speed;
        this.maxHp = this.hp;
    }
    update(player) {
        if(this.frozen > 0) { this.frozen--; return; }
        this.x += this.pushX; this.y += this.pushY; this.pushX *= 0.9; this.pushY *= 0.9;
        
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 0) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
        if (dist < this.size + player.size) { 
            player.takeDamage(this.dmg); 
            this.pushX = -(dx/dist)*10; this.pushY = -(dy/dist)*10; 
        }
    }
    takeDamage(amt, knockback = 0, sourceX = 0, sourceY = 0) {
        if(saveData.artifacts.axe) { const hpPct = state.player.hp / state.player.maxHp; if(hpPct < 0.5) amt *= 1.5; if(hpPct < 0.2) amt *= 2.0; }
        
        let isCrit = false;
        if (Math.random() < state.player.critChance) { amt *= 2; isCrit = true; }

        amt *= state.player.dmgMult; 
        
        // Knockback
        if (knockback > 0 && sourceX && sourceY) {
            const dx = this.x - sourceX, dy = this.y - sourceY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const kbForce = knockback * state.sessionStats.knockbackMult;
            if (dist > 0) { this.pushX = (dx/dist) * kbForce; this.pushY = (dy/dist) * kbForce; }
        }

        this.hp -= amt; 
        createPopup(Math.round(amt) + (isCrit?'!':''), this.x, this.y - 10, isCrit ? '#f00' : (amt > 20 ? '#ff0' : '#fff'));
        
        if (this.hp <= 0) { this.die(); return true; } return false;
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 8); 
        if(saveData.artifacts.fang && Math.random() < 0.1) { state.player.hp = Math.min(state.player.hp + 1, state.player.maxHp); createPopup("+1", state.player.x, state.player.y, '#0f0'); }
        
        const rand = Math.random();
        const luck = saveData.upgrades.luck || 0;
        
        if (rand < 0.005 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'BOMB'));
        else if (rand < 0.01 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'MAGNET'));
        else if (rand < 0.02 * (1+luck*0.2)) state.items.push(new Item(this.x, this.y, 0, 'HEAL'));
        else state.items.push(new Item(this.x, this.y, 2, 'XP')); 
        
        state.kills++; 
        saveData.stats.totalKills++;
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath();
        if (this.type === 'SQUARE') ctx.rect(this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        else if (this.type === 'TRIANGLE') { ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x + this.size, this.y + this.size); ctx.lineTo(this.x - this.size, this.y + this.size); }
        else ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill(); ctx.shadowBlur = 0;
    }
}

class Boss extends Enemy {
    constructor(x, y) { 
        super('OCTAGON', x, y); 
        this.hp = 5000 * (1 + state.time/300) * state.bossLevel; 
        this.maxHp = this.hp; this.size = 60; this.speed = 1.2; this.color = '#bc13fe'; 
    }
    die() { 
        createExplosion(this.x, this.y, this.color, 50); 
        for(let i=0; i<30; i++) { 
            let it = new Item(this.x + (Math.random()-0.5)*80, this.y + (Math.random()-0.5)*80, 50, 'XP'); 
            it.isCoin = true; it.val = 100; state.items.push(it); 
        } 
        state.boss = null; 
        state.bossRespawnTimer = BOSS_RESPAWN_DELAY; 
        state.bossLevel += 0.5;
        document.getElementById('boss-hud').classList.remove('active'); 
        createPopup("BOSS DEFEATED!", this.x, this.y, '#ffd700');
    }
}

class Item {
    constructor(x, y, val, type = 'XP') {
        this.x = x; this.y = y; this.val = val; this.size = 5; this.type = type; this.isCoin = false;
        const luckMult = 1 + ((saveData.upgrades.luck || 0) * 0.1);
        if (type === 'HEAL') { this.color = '#ff0055'; this.size = 8; }
        else if (type === 'MAGNET') { this.color = '#0055ff'; this.size = 8; }
        else if (type === 'BOMB') { this.color = '#ffaa00'; this.size = 8; }
        else { 
            this.isCoin = Math.random() < 0.25; 
            if (this.isCoin) { 
                this.color = '#ffd700'; 
                this.val = Math.floor(50 * (1 + saveData.upgrades.greed * 0.1) * luckMult * state.sessionStats.greedMult); 
            } else { this.color = '#33ccff'; } 
        }
    }
    update(player) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx*dx + dy*dy);
        let range = 100 + (saveData.artifacts.magnet || 0) * 20 + (saveData.upgrades.magnet || 0) * 30; 
        range *= state.sessionStats.pickupRangeMult;
        
        if (this.type === 'MAGNET') range = 150;
        
        if (dist < range) { this.x += (dx / dist) * 12; this.y += (dy / dist) * 12; }
        if (dist < player.size + this.size) {
            if (this.type === 'HEAL') { player.hp = Math.min(player.hp + 30, player.maxHp); createPopup("+30 HP", this.x, this.y, '#f00'); }
            else if (this.type === 'MAGNET') { state.items.forEach(i => { if(i.type === 'XP' || i.isCoin) { i.x = player.x; i.y = player.y; } }); createPopup("MAGNET!", this.x, this.y, '#00f'); }
            else if (this.type === 'BOMB') { state.enemies.forEach(e => { if(!(e instanceof Boss)) e.die(); else e.takeDamage(500); }); createExplosion(player.x, player.y, '#fff', 50); createPopup("BOOM!", this.x, this.y, '#fa0'); }
            else if (this.isCoin) { state.coins += this.val; saveData.stats.totalCoins += this.val; } else { addXp(this.val); }
            return true;
        } return false;
    }
    draw(ctx) { 
        ctx.fillStyle = this.color; ctx.beginPath(); 
        if(this.type === 'HEAL') { ctx.rect(this.x-3, this.y-8, 6, 16); ctx.rect(this.x-8, this.y-3, 16, 6); }
        else if(this.type === 'BOMB') { ctx.arc(this.x, this.y, 8, 0, Math.PI*2); }
        else if(this.type === 'MAGNET') { ctx.arc(this.x, this.y, 8, Math.PI, 0); ctx.lineTo(this.x+8, this.y+8); ctx.lineTo(this.x+4, this.y+8); ctx.lineTo(this.x+4, this.y); ctx.lineTo(this.x-4, this.y); ctx.lineTo(this.x-4, this.y+8); ctx.lineTo(this.x-8, this.y+8); }
        else if(this.isCoin) ctx.arc(this.x, this.y, 6, 0, Math.PI*2); else ctx.rect(this.x-3, this.y-3, 6, 6); 
        ctx.fill(); 
    }
}

class Projectile {
    constructor(x, y, vx, vy, dmg, color, duration, size=4, pierce=false, knockback=2) { 
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.dmg = dmg; this.color = color; 
        this.duration = duration * (1 + (saveData.upgrades.duration || 0) * 0.1) * state.sessionStats.durationMult; 
        this.size = size * state.sessionStats.sizeMult * state.sessionStats.areaMult; 
        this.pierce = pierce; this.hitList = []; this.knockback = knockback;
    }
    update() { this.x += this.vx; this.y += this.vy; this.duration--; return this.duration <= 0; }
    draw(ctx) { ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; }
}

class Mine {
    constructor(x, y, dmg, radius) {
        this.x = x; this.y = y; this.dmg = dmg; 
        this.radius = radius * state.sessionStats.areaMult; 
        this.active = false; this.timer = 60;
    }
    update() {
        if(this.timer > 0) this.timer--; else this.active = true;
        if (this.active) {
            for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < e.size + 15) { this.explode(); return true; } }
        }
        return false;
    }
    explode() {
        createExplosion(this.x, this.y, '#ff4400', 10, 5);
        for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) { if(e.takeDamage(this.dmg, 5, this.x, this.y)) removeEnemy(e); } }
    }
    draw(ctx) {
        ctx.fillStyle = this.active ? ((state.time % 20 < 10) ? '#ff0000' : '#550000') : '#555';
        ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
        if(this.active) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,50,0,0.1)'; ctx.stroke(); }
    }
}

class Drone {
    constructor(player, offset) { this.player = player; this.offset = offset; this.x = player.x; this.y = player.y; }
    update() {
        const t = state.time * 0.05; const targetX = this.player.x + Math.cos(t + this.offset) * 50; const targetY = this.player.y + Math.sin(t + this.offset) * 50;
        this.x += (targetX - this.x) * 0.1; this.y += (targetY - this.y) * 0.1;
    }
    draw(ctx) { ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#00ffff'; }
}

class VoidZone {
    constructor(x, y) { this.x = x; this.y = y; this.life = 300 * state.sessionStats.durationMult; this.r = 0; this.maxR = 150 * state.sessionStats.areaMult; }
    update() {
        if(this.r < this.maxR) this.r += 2; this.life--;
        if(this.life % 20 === 0) {
             for(const e of state.enemies) { if(Math.hypot(e.x - this.x, e.y - this.y) < this.r) if(e.takeDamage(10)) removeEnemy(e); }
        }
        return this.life <= 0;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(157, 0, 255, ${this.life/300 * 0.3})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#9d00ff'; ctx.lineWidth = 2; ctx.stroke();
    }
}

class Particle {
    constructor(x, y, color, speed, life, size=0) { 
        this.x = x; this.y = y; this.color = color; const angle = Math.random() * Math.PI * 2; 
        this.vx = Math.cos(angle) * speed * Math.random(); this.vy = Math.sin(angle) * speed * Math.random(); 
        this.life = life; this.maxLife = life; this.size = size > 0 ? size : Math.random() * 3 + 1; 
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; this.vx *= 0.95; this.vy *= 0.95; return this.life <= 0; }
    draw(ctx) { ctx.fillStyle = this.color; ctx.globalAlpha = this.life / this.maxLife; ctx.beginPath(); ctx.rect(this.x, this.y, this.size, this.size); ctx.fill(); ctx.globalAlpha = 1; }
}

class PopupText {
    constructor(text, x, y, color) { this.text = text; this.x = x; this.y = y; this.color = color; this.life = 30; }
    update() { this.y -= 1; this.life--; return this.life <= 0; }
    draw(ctx) { ctx.fillStyle = this.color; ctx.font = "12px 'Exo 2'"; ctx.fillText(this.text, this.x, this.y); }
}

class Shockwave {
    constructor(x, y, maxR, color) { this.x = x; this.y = y; this.r = 10; this.maxR = maxR; this.color = color; this.alpha = 1; }
    update() { this.r += 40; this.alpha -= 0.02; return this.alpha <= 0; }
    draw(ctx) { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.strokeStyle = this.color; ctx.lineWidth = 15; ctx.globalAlpha = this.alpha; ctx.stroke(); ctx.restore(); }
}

function createPopup(text, x, y, color) { state.popups.push(new PopupText(text, x, y, color)); }
function createExplosion(x, y, color, count, size=0) { for(let i=0; i<count; i++) state.particles.push(new Particle(x, y, color, 8, 40, size)); }

// --- Logic ---
function updateWeapons() {
    const p = state.player, w = state.weapons; let cdReduc = 1 - p.cdReduc;
    const sizeMult = state.sessionStats.sizeMult;
    const projSpeedMult = state.sessionStats.projectileSpeed;
    const extraProj = state.sessionStats.projectileCount;
    const areaMult = state.sessionStats.areaMult;

    // Blaster / Exterminator
    if (w.blaster.cd <= 0) {
        let closest = null, minDist = w.blaster.evolved ? 700 : 450;
        for (const e of state.enemies) { const d = Math.hypot(e.x - p.x, e.y - p.y); if (d < minDist) { minDist = d; closest = e; } }
        if (closest) {
            const angle = Math.atan2(closest.y - p.y, closest.x - p.x);
            const shotCount = 1 + extraProj + (w.blaster.evolved ? 2 : 0);
            for(let i=0; i<shotCount; i++) {
                const spread = shotCount > 1 ? (i - (shotCount-1)/2) * (w.blaster.evolved ? 0.1 : 0.2) : 0;
                if (w.blaster.evolved) { 
                    state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle + spread)*20*projSpeedMult, Math.sin(angle + spread)*20*projSpeedMult, 60, '#ff0099', 60, 8, true, 4)); 
                } else { 
                    state.projectiles.push(new Projectile(p.x, p.y, Math.cos(angle + spread)*10*projSpeedMult, Math.sin(angle + spread)*10*projSpeedMult, 30+(w.blaster.level*5), '#ffff00', 40, 4, false, 2)); 
                }
            }
            w.blaster.cd = w.blaster.evolved ? 3 : Math.max(10, (40-(w.blaster.level*4))*cdReduc);
        }
    } else w.blaster.cd--;

    // Orbit / Black Hole
    if (w.orbit.level > 0) {
        w.orbit.angle += (w.orbit.evolved ? 0.1 : 0.05); 
        const count = w.orbit.level + (saveData.artifacts.cube ? 1 : 0) + extraProj + (w.orbit.evolved ? 2 : 0);
        for(let i=0; i<count; i++) {
            const theta = w.orbit.angle + (Math.PI*2*i/count); 
            const dist = w.orbit.evolved ? 120 : 70;
            const ox = p.x + Math.cos(theta)*dist*sizeMult, oy = p.y + Math.sin(theta)*dist*sizeMult;
            
            if (w.orbit.evolved) {
                // Black Hole effect
                if(state.time % 5 === 0) {
                     state.particles.push(new Particle(ox, oy, '#000', 1, 5, 8 * sizeMult * areaMult));
                     createExplosion(ox, oy, '#330066', 1, 2);
                }
                for(const e of state.enemies) {
                    if(Math.hypot(e.x - ox, e.y - oy) < 40 * sizeMult * areaMult) {
                        e.takeDamage(2); e.pushX = (ox - e.x)*0.1; e.pushY = (oy - e.y)*0.1;
                        if(e.hp <= 0) removeEnemy(e);
                    }
                }
            } else {
                state.particles.push(new Particle(ox, oy, '#33ccff', 1, 5, 3 * sizeMult));
                for(const e of state.enemies) if(Math.hypot(e.x - ox, e.y - oy) < 15 * sizeMult && e.takeDamage(15)) removeEnemy(e);
            }
        }
    }

    if (w.field.level > 0) {
        if (w.field.cd <= 0) {
            createExplosion(p.x, p.y, 'rgba(0,255,100,0.2)', 5, 10*sizeMult);
            const range = (w.field.radius + (w.field.level*10)) * sizeMult * areaMult;
            for(const e of state.enemies) if(Math.hypot(e.x - p.x, e.y - p.y) < range && e.takeDamage(5+w.field.level)) removeEnemy(e);
            w.field.cd = 30 * cdReduc;
        } else w.field.cd--;
    }

    // Tesla / Thunder God
    if (w.tesla.level > 0) { 
        if (w.tesla.cd <= 0) { 
            if (w.tesla.evolved) {
                // Global Strike
                createPopup("THUNDER!", p.x, p.y-50, '#00ffff');
                for(let i=0; i<10; i++) {
                    if(state.enemies.length > 0) {
                        const target = state.enemies[Math.floor(Math.random()*state.enemies.length)];
                        createLightning(p.x, p.y-500, target.x, target.y);
                        target.takeDamage(100);
                        if(target.hp<=0) removeEnemy(target);
                    }
                }
                w.tesla.cd = 90 * cdReduc;
            } else {
                let target = null; for(const e of state.enemies) if(Math.hypot(e.x - p.x, e.y - p.y) < 250) { target = e; break; } 
                if(target) { fireTesla(target, 3+w.tesla.level+extraProj, 20+w.tesla.level*5); w.tesla.cd = (120-(w.tesla.level*5)) * cdReduc; } 
            }
        } else w.tesla.cd--; 
    }
    
    // Missile / Nuke
    if (w.missile.level > 0) { 
        if (w.missile.cd <= 0) { 
            const count = 1 + Math.floor(extraProj/2) + (w.missile.evolved ? 1 : 0);
            for(let i=0; i<count; i++) {
                const dmg = w.missile.evolved ? 200 : 40+w.missile.level*10;
                const area = w.missile.evolved ? 150 : 50;
                const col = w.missile.evolved ? '#00ff00' : '#ffaa00';
                const proj = new Projectile(p.x, p.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, dmg, col, 150, w.missile.evolved?15:8, false);
                if(w.missile.evolved) { proj.onHit = () => { createExplosion(proj.x, proj.y, '#0f0', 30); state.enemies.forEach(e => { if(Math.hypot(e.x-proj.x, e.y-proj.y)<area) e.takeDamage(dmg); }); }; }
                state.projectiles.push(proj); 
            }
            w.missile.cd = (80 - w.missile.level*5) * cdReduc; 
        } else w.missile.cd--; 
    }

    if (w.gravity.level > 0) { if(w.gravity.cd <= 0) { spawnGravityWell(p.x, p.y, w.gravity.level); w.gravity.cd = (300 - w.gravity.level*10) * cdReduc; } else w.gravity.cd--; }

    if (w.mines.level > 0) {
        if (w.mines.cd <= 0) {
            state.mines.push(new Mine(p.x, p.y, 100 + w.mines.level*20, 100 * sizeMult));
            w.mines.cd = Math.max(30, (120 - w.mines.level * 10) * cdReduc);
        } else w.mines.cd--;
    }

    if (w.drone.level > 0) {
        if (state.drones.length < 1 + extraProj) {
            state.drones = [];
            for(let i=0; i < 1 + extraProj; i++) state.drones.push(new Drone(p, i));
        }
        if (w.drone.cd <= 0) {
            state.drones.forEach(d => {
                let closest = null, min = 300;
                for(const e of state.enemies) { const dist = Math.hypot(e.x - d.x, e.y - d.y); if(dist < min) { min = dist; closest = e; } }
                if(closest) {
                    const ang = Math.atan2(closest.y - d.y, closest.x - d.x);
                    state.projectiles.push(new Projectile(d.x, d.y, Math.cos(ang)*12, Math.sin(ang)*12, 15+w.drone.level*5, '#00ffff', 40, 3));
                }
            });
            w.drone.cd = Math.max(10, (40 - w.drone.level*3) * cdReduc);
        } else w.drone.cd--;
    }

    // Hidden Weapon: Void Walker
    if (w.voidwalker.level > 0) {
        if (w.voidwalker.cd <= 0) {
            state.voidZones.push(new VoidZone(p.x + (Math.random()-0.5)*400, p.y + (Math.random()-0.5)*400));
            w.voidwalker.cd = 60 * cdReduc;
        } else w.voidwalker.cd--;
    }
    
    // Ultimate Cooldown
    if (!state.ult.ready) { 
        state.ult.cd++; 
        if (state.ult.cd >= state.ult.maxCd) { 
            state.ult.ready = true; 
            document.getElementById('ult-btn').classList.remove('disabled'); 
            const curUlt = ULTIMATES.find(u => u.id === saveData.currentUlt);
            document.getElementById('ult-btn').innerHTML = `<div id="ult-icon">${curUlt.icon}</div><div id="ult-label">ULTIMATE</div>`; 
            document.getElementById('ult-btn').style.borderColor = curUlt.color;
        } else { 
            document.getElementById('ult-btn').innerHTML = `<div style="font-size:0.8rem">${Math.floor((state.ult.cd/state.ult.maxCd)*100)}%</div>`; 
        } 
    }
    
    // Active Ultimate Effects
    if (state.ult.activeTime > 0) {
        state.ult.activeTime--;
        if (saveData.currentUlt === 'berserk') {
             if(state.ult.activeTime % 5 === 0) createExplosion(p.x, p.y, '#ff0000', 1);
        }
        if (state.ult.activeTime <= 0) {
            // End effects
            if(saveData.currentUlt === 'berserk') { p.speed = p.baseSpeed; p.dmgMult /= 3; }
            if(saveData.currentUlt === 'chrono') { state.enemies.forEach(e => e.frozen = 0); p.speed = p.baseSpeed; }
        }
    }
}

function fireTesla(target, bounces, dmg) {
    let curr = target, visited = [target];
    for(let i=0; i<bounces; i++) {
        if(curr.takeDamage(dmg)) removeEnemy(curr);
        let next = null, minD = 150;
        for(const e of state.enemies) { if (!visited.includes(e)) { const d = Math.hypot(e.x - curr.x, e.y - curr.y); if(d < minD) { minD = d; next = e; } } }
        if(next) { createLightning(curr.x, curr.y, next.x, next.y); curr = next; visited.push(next); } else break;
    }
}
function createLightning(x1, y1, x2, y2) { const d = Math.hypot(x2-x1, y2-y1), steps = d/10; for(let i=0; i<steps; i++) state.particles.push(new Particle(x1+(x2-x1)*(i/steps), y1+(y2-y1)*(i/steps), '#88ccff', 0, 5)); }

function spawnGravityWell(x, y, level) { state.gravityWells.push({x, y, life: 180, range: 150+level*20*state.sessionStats.sizeMult * state.sessionStats.areaMult, dmg: level}); }

function useUltimate() { 
    if (!state.ult.ready) return; 
    state.ult.ready = false; state.ult.cd = 0; 
    document.getElementById('ult-btn').classList.add('disabled'); 
    
    const u = saveData.currentUlt;
    
    if (u === 'nuclear') {
        createExplosion(state.player.x, state.player.y, '#ffd700', 100, 10); 
        createExplosion(state.player.x, state.player.y, '#ff00ff', 50, 5);
        state.shockwaves.push(new Shockwave(state.player.x, state.player.y, 1500, '#ffd700'));
        document.body.style.filter = 'invert(1)'; setTimeout(() => document.body.style.filter = 'none', 100); 
        for(let i=state.enemies.length-1; i>=0; i--) { 
            const e = state.enemies[i]; 
            if (e instanceof Boss) e.takeDamage(1000); 
            else { createExplosion(e.x, e.y, e.color, 5); state.enemies.splice(i, 1); state.kills++; } 
        } 
    } else if (u === 'chrono') {
        state.ult.activeTime = 300; // 5 sec
        state.shockwaves.push(new Shockwave(state.player.x, state.player.y, 1500, '#00ccff'));
        createPopup("TIME STOP!", state.player.x, state.player.y - 50, '#00ccff');
        state.enemies.forEach(e => e.frozen = 300);
        state.player.speed *= 2;
    } else if (u === 'berserk') {
        state.ult.activeTime = 600; // 10 sec
        state.player.speed *= 2;
        state.player.dmgMult *= 3;
        createPopup("BERSERK MODE!", state.player.x, state.player.y - 50, '#ff0055');
    }
}

const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();
window.addEventListener('wheel', (e) => {
    e.preventDefault();
    ZOOM += e.deltaY * -0.001;
    ZOOM = Math.max(0.3, Math.min(2.0, ZOOM));
}, { passive: false });

function startGame() {
    document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
    document.getElementById('hud').classList.remove('hidden'); document.getElementById('joystick-zone').classList.remove('hidden');
    state.running = true; state.paused = false; state.gameOver = false; state.time = 0; state.score = 0; state.kills = 0; state.coins = 0; state.level = 1; state.xp = 0; state.nextLevelXp = 10;
    
    // Reset State
    state.weapons = { 
        blaster: { level: 1, cd: 0, maxCd: 40, evolved: false }, 
        orbit: { level: 0, cd: 0, angle: 0, count: 1, evolved: false }, 
        field: { level: 0, cd: 0, radius: 80, evolved: false }, 
        tesla: { level: 0, cd: 0, maxCd: 120, evolved: false }, 
        missile: { level: 0, cd: 0, maxCd: 80, evolved: false }, 
        gravity: { level: 0, cd: 0, maxCd: 300, evolved: false },
        mines: { level: 0, cd: 0, maxCd: 120, evolved: false },
        drone: { level: 0, cd: 0, maxCd: 40, evolved: false },
        voidwalker: { level: 0, cd: 0, maxCd: 60 }
    };
    
    state.sessionStats = { 
        sizeMult: 1, projectileCount: 0, projectileSpeed: 1, 
        areaMult: 1, durationMult: 1, knockbackMult: 1, 
        dashCdMult: 1, pickupRangeMult: 1, armor: 0, greedMult: 1 
    };

    state.ult = { ready: true, charge: 100, cd: 0, maxCd: 1800, activeTime: 0 };
    state.player = new Player(); state.enemies = []; state.items = []; state.particles = []; state.projectiles = []; 
    state.popups = []; state.shockwaves = []; state.gravityWells = []; state.mines = []; state.drones = []; state.voidZones = [];
    state.boss = null; state.bossLevel = 1;
    state.keys = { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
    
    updateHUD(); requestAnimationFrame(loop);
}

function loop() {
    if (!state.running) return;
    if (!state.paused) {
        if (state.time % 60 === 0 && state.enemies.length < 300) spawnEnemy();
        
        // Boss Logic
        if (state.time === BOSS_SPAWN_TIME * 60 && !state.boss) spawnBoss();
        if (state.bossRespawnTimer > 0) {
            state.bossRespawnTimer--;
            if (state.bossRespawnTimer <= 0 && !state.boss) {
                spawnBoss();
                createPopup("WARNING!", state.player.x, state.player.y - 50, '#ff00ff');
            }
        }

        state.player.update();
        state.drones.forEach(d => d.update());
        for (let i = state.enemies.length - 1; i >= 0; i--) state.enemies[i].update(state.player);
        for (let i = state.projectiles.length - 1; i >= 0; i--) { 
            const p = state.projectiles[i]; 
            if(p.update()) { state.projectiles.splice(i, 1); continue; } 
            let hit = false; 
            for (const e of state.enemies) { 
                if (p.pierce && p.hitList.includes(e)) continue; 
                if (Math.hypot(e.x - p.x, e.y - p.y) < e.size + p.size) { 
                    if(e.takeDamage(p.dmg, p.knockback, p.x, p.y)) removeEnemy(e); 
                    hit = true; 
                    if(p.onHit) p.onHit();
                    createExplosion(p.x, p.y, p.color, 3); 
                    if (!p.pierce) break; else p.hitList.push(e); 
                } 
            } 
            if (hit && !p.pierce) state.projectiles.splice(i, 1); 
        }
        for (let i = state.mines.length - 1; i >= 0; i--) { if(state.mines[i].update()) state.mines.splice(i, 1); }
        for (let i = state.voidZones.length - 1; i >= 0; i--) { if(state.voidZones[i].update()) state.voidZones.splice(i, 1); }
        
        updateWeapons(); 
        
        // Gravity Wells
        for(let i=state.gravityWells.length-1; i>=0; i--) {
            const g = state.gravityWells[i]; g.life--;
            for(const e of state.enemies) { const dx = g.x - e.x, dy = g.y - e.y, d = Math.hypot(dx, dy); if(d < g.range && d > 10) { e.x += (dx/d)*2; e.y += (dy/d)*2; if(g.life%10===0 && e.takeDamage(g.dmg)) removeEnemy(e); } }
            if(g.life%5===0) state.particles.push(new Particle(g.x, g.y, '#6600cc', 2, 10)); if(g.life <= 0) state.gravityWells.splice(i, 1);
        }

        for (let i = state.items.length - 1; i >= 0; i--) if (state.items[i].update(state.player)) state.items.splice(i, 1);
        for (let i = state.particles.length - 1; i >= 0; i--) if (state.particles[i].update()) state.particles.splice(i, 1);
        for (let i = state.popups.length - 1; i >= 0; i--) if (state.popups[i].update()) state.popups.splice(i, 1);
        for (let i = state.shockwaves.length - 1; i >= 0; i--) if (state.shockwaves[i].update()) state.shockwaves.splice(i, 1);
        state.time++; if (state.time % 60 === 0) updateHUD();
    }
    render(); requestAnimationFrame(loop);
}

function render() {
    ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    if(!state.player) return;

    ctx.save(); const cx = canvas.width / 2, cy = canvas.height / 2; 
    
    // Screen Shake
    if (state.shockwaves.length > 0) {
        const shake = Math.random() * 10 - 5;
        ctx.translate(shake, shake);
    }

    ctx.translate(cx, cy); ctx.scale(ZOOM, ZOOM); ctx.translate(-state.player.x, -state.player.y);
    
    // Grid
    ctx.strokeStyle = 'rgba(50, 0, 100, 0.2)'; ctx.lineWidth = 2; const gridSize = 100; const offX = Math.floor(state.player.x / gridSize) * gridSize, offY = Math.floor(state.player.y / gridSize) * gridSize;
    ctx.beginPath(); for (let x = offX - 1000/ZOOM; x < offX + 1000/ZOOM; x += gridSize) { ctx.moveTo(x, offY - 1000/ZOOM); ctx.lineTo(x, offY + 1000/ZOOM); } for (let y = offY - 1000/ZOOM; y < offY + 1000/ZOOM; y += gridSize) { ctx.moveTo(offX - 1000/ZOOM, y); ctx.lineTo(offX + 1000/ZOOM, y); } ctx.stroke();
    
    state.mines.forEach(m => m.draw(ctx));
    state.voidZones.forEach(z => z.draw(ctx));
    state.items.forEach(i => i.draw(ctx)); 
    state.gravityWells.forEach(g => { ctx.beginPath(); ctx.arc(g.x, g.y, g.range, 0, Math.PI*2); ctx.strokeStyle='#6600cc'; ctx.stroke(); });
    state.enemies.forEach(e => e.draw(ctx)); 
    state.player.draw(ctx); 
    state.drones.forEach(d => d.draw(ctx));
    state.projectiles.forEach(p => p.draw(ctx)); 
    state.particles.forEach(p => p.draw(ctx)); 
    state.popups.forEach(p => p.draw(ctx)); 
    state.shockwaves.forEach(s => s.draw(ctx));
    
    ctx.restore();
}

function spawnEnemy() {
    const angle = Math.random() * Math.PI * 2, dist = 800 / ZOOM, x = state.player.x + Math.cos(angle) * dist, y = state.player.y + Math.sin(angle) * dist;
    let type = 'SQUARE'; const t = state.time / 60;
    if (t > 180 && Math.random() < 0.1) type = 'OCTAGON'; else if (t > 120 && Math.random() < 0.2) type = 'RHOMBUS'; else if (t > 60 && Math.random() < 0.3) type = 'PENTAGON'; else if (t > 30 && Math.random() < 0.4) type = 'TRIANGLE';
    if (t > 90 && Math.random() < 0.05) for(let i=0; i<10; i++) state.enemies.push(new Enemy('SWARM', x + Math.random()*50, y + Math.random()*50)); else state.enemies.push(new Enemy(type, x, y));
}
function spawnBoss() { 
    const angle = Math.random() * Math.PI * 2, dist = 600, x = state.player.x + Math.cos(angle) * dist, y = state.player.y + Math.sin(angle) * dist; 
    state.boss = new Boss(x, y); state.enemies.push(state.boss); 
    document.getElementById('boss-hud').classList.add('active'); 
}
function removeEnemy(e) { const idx = state.enemies.indexOf(e); if (idx > -1) state.enemies.splice(idx, 1); if (e instanceof Boss) { e.die(); } }
function addXp(amt) { 
    const xpBoost = 1 + ((saveData.upgrades.xp || 0) * 0.1);
    state.xp += amt * xpBoost; 
    if (state.xp >= state.nextLevelXp) { state.xp -= state.nextLevelXp; state.level++; state.nextLevelXp = Math.floor(state.nextLevelXp * 1.2); showUpgradeScreen(); } updateHUD(); 
}
function updateHUD() {
    document.getElementById('xp-bar').style.width = `${(state.xp / state.nextLevelXp) * 100}%`; 
    
    const hpPct = Math.max(0, Math.min(100, (state.player.hp / state.player.maxHp) * 100));
    document.getElementById('hp-bar').style.width = `${hpPct}%`;
    document.getElementById('hp-text').innerText = `${Math.ceil(Math.max(0, state.player.hp))} / ${Math.ceil(state.player.maxHp)}`;

    document.getElementById('level-display').innerText = state.level; document.getElementById('kill-display').innerText = state.kills; document.getElementById('coin-display').innerText = state.coins;
    const m = Math.floor(state.time / 3600), s = Math.floor((state.time % 3600) / 60); document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    if(state.boss) document.getElementById('boss-hp-fill').style.width = `${(state.boss.hp / state.boss.maxHp) * 100}%`;
}

// System Upgrade Logic (with Evolutions and Hidden)
function showUpgradeScreen() {
    state.paused = true; const container = document.getElementById('upgrade-cards'); container.innerHTML = '';
    document.getElementById('upgrade-screen').classList.remove('hidden'); document.getElementById('joystick-zone').classList.add('hidden');
    
    // Check for Evolutions
    for (const evo of EVOLUTIONS) {
        if (!state.weapons[evo.weapon].evolved && state.weapons[evo.weapon].level >= 5) {
            // Check if player has the passive (sessionStats or general upgrades logic simplified for gameplay)
            // Simplified: If you have max level weapon, evolution chance is high
            if (Math.random() < 0.4) {
                const card = document.createElement('div'); card.className = 'card evolution'; 
                card.innerHTML = `<div class="card-icon">${evo.icon}</div><div class="card-title">${evo.name}</div><div class="card-desc">${evo.desc}</div><div class="card-type">EVOLUTION</div>`; 
                card.onclick = () => selectUpgrade(evo.evolveTo); container.appendChild(card); 
                return; // Only show evolution
            }
        }
    }

    let choices = [];
    const pool = [...UPGRADES];
    
    // Filter out Hidden unless lucky
    const hiddenChance = (saveData.upgrades.luck || 0) * 0.05 + 0.01;
    
    for(let i=0; i<3; i++) {
        let u;
        if (state.level >= 15 && Math.random() < hiddenChance) {
             u = pool.find(x => x.type === 'HIDDEN');
        }
        if (!u) {
            const commonPool = pool.filter(x => x.type !== 'HIDDEN');
            u = commonPool[Math.floor(Math.random() * commonPool.length)];
        }
        
        choices.push(u);
        const card = document.createElement('div'); 
        card.className = u.type === 'HIDDEN' ? 'card hidden-tier' : 'card';
        
        let lvlInfo = '';
        if(u.type === 'WEAPON' || u.type === 'HIDDEN') lvlInfo = `(Lv.${state.weapons[u.id]?.level || 0})`;

        card.innerHTML = `<div class="card-icon">${u.icon}</div><div class="card-title">${u.name}</div><div class="card-desc">${u.desc} ${lvlInfo}</div><div class="card-type">${u.type}</div>`;
        card.onclick = () => selectUpgrade(u.id); 
        container.appendChild(card);
    }
}

function selectUpgrade(id) {
    // Stats
    if (id === 'heal') state.player.hp = Math.min(state.player.hp + state.player.maxHp * 0.5, state.player.maxHp);
    else if (id === 'giant') state.sessionStats.sizeMult += 0.15;
    else if (id === 'multishot') state.sessionStats.projectileCount += 1;
    else if (id === 'sniper') state.sessionStats.projectileSpeed += 0.2;
    else if (id === 'area') state.sessionStats.areaMult += 0.15;
    else if (id === 'duration') state.sessionStats.durationMult += 0.15;
    else if (id === 'knockback') state.sessionStats.knockbackMult += 0.2;
    else if (id === 'armor') state.sessionStats.armor += 1;
    else if (id === 'dash_cd') state.sessionStats.dashCdMult *= 0.9;
    else if (id === 'pickup') state.sessionStats.pickupRangeMult += 0.3;
    else if (id === 'greed') state.sessionStats.greedMult += 0.2;
    
    // Evolutions
    else if (id === 'exterminator') { state.weapons.blaster.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'blackhole') { state.weapons.orbit.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'thundergod') { state.weapons.tesla.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    else if (id === 'nuke') { state.weapons.missile.evolved = true; createPopup("EVOLUTION!", state.player.x, state.player.y, '#ff0099'); }
    
    // Weapons
    else if (state.weapons[id]) state.weapons[id].level++;
    
    document.getElementById('upgrade-screen').classList.add('hidden'); document.getElementById('joystick-zone').classList.remove('hidden'); state.paused = false;
}

function togglePause() { if (!state.running) return; state.paused = !state.paused; if (state.paused) { document.getElementById('pause-screen').classList.remove('hidden'); document.getElementById('joystick-zone').classList.add('hidden'); } else { document.getElementById('pause-screen').classList.add('hidden'); document.getElementById('joystick-zone').classList.remove('hidden'); } }
function quitGame() { saveData.coins += Math.floor(state.coins); save(); state.running = false; showStartScreen(); }
function showStartScreen() { document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden')); document.getElementById('start-screen').classList.remove('hidden'); document.getElementById('joystick-zone').classList.add('hidden'); }
function endGame() { state.running = false; document.getElementById('hud').classList.add('hidden'); document.getElementById('joystick-zone').classList.add('hidden'); document.getElementById('game-over-screen').classList.remove('hidden'); const m = Math.floor(state.time / 3600), s = Math.floor((state.time % 3600) / 60); document.getElementById('final-score').innerText = `ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${m}:${s}`; document.getElementById('final-coins').innerText = `ÌöçÎìù: ${state.coins} ü™ô`; saveData.coins += state.coins; save(); }
function restartGame() { startGame(); }

// Menus
function openArmory() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('armory-screen').classList.remove('hidden'); renderArmory(); }
function closeArmory() { document.getElementById('armory-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderArmory() {
    document.getElementById('armory-currency').innerText = saveData.coins; const container = document.getElementById('armory-container'); container.innerHTML = '';
    const gears = [{ id: 'weapon', name: 'ÌîåÎùºÏ¶àÎßà ÎùºÏù¥Ìîå', desc: 'Í≥µÍ≤©Î†• +20%', icon: 'üî´' }, { id: 'armor', name: 'ÎÇòÎÖ∏ ÏäàÌä∏', desc: 'ÏµúÎåÄ Ï≤¥Î†• +20', icon: 'üõ°Ô∏è' }, { id: 'boots', name: 'Ï†úÌä∏ Î∂ÄÏ∏†', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5% / Ïø®ÌÉÄÏûÑ -2%', icon: 'ü•æ' }];
    gears.forEach(g => { const lvl = saveData.equipment[g.id], cost = SHOP_BASE_COST * (lvl + 1); const div = document.createElement('div'); div.className = 'shop-item'; div.innerHTML = `<h3 style="font-size:1.5rem">${g.icon}</h3><h3>${g.name} (Lv.${lvl})</h3><p>${g.desc}</p><button class="btn" style="font-size:0.85rem;" onclick="upgradeEquipment('${g.id}', ${cost})">${cost} ü™ô</button>`; container.appendChild(div); });
}
function upgradeEquipment(id, cost) { if(saveData.coins >= cost) { saveData.coins -= cost; saveData.equipment[id]++; save(); renderArmory(); } else alert('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'); }

function openWardrobe() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('wardrobe-screen').classList.remove('hidden'); renderWardrobe(); }
function closeWardrobe() { document.getElementById('wardrobe-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderWardrobe() {
    const c = document.getElementById('skin-container'); c.innerHTML = '';
    SKINS.forEach(s => {
        const owned = saveData.ownedSkins.includes(s.id); const d = document.createElement('div'); d.className = 'skin-item' + (saveData.currentSkin === s.id ? ' selected' : '') + (!owned ? ' locked' : '');
        d.innerHTML = `<div class="skin-preview">${s.icon}</div><div class="skin-name">${s.name}</div>${!owned?'<div class="lock-icon">üîí</div>':''}`;
        if(owned) d.onclick = () => selectSkin(s.id); c.appendChild(d);
    });
}
function selectSkin(id) { saveData.currentSkin = id; save(); renderWardrobe(); }

function openArtifactScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('artifact-screen').classList.remove('hidden'); renderArtifacts(); }
function closeArtifactScreen() { document.getElementById('artifact-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderArtifacts() {
    const container = document.getElementById('artifact-container'); container.innerHTML = '';
    ARTIFACTS.forEach(art => {
        const lvl = saveData.artifacts[art.id] || 0;
        const owned = lvl > 0;
        const card = document.createElement('div'); card.className = owned ? 'card' : 'card locked';
        if (owned) {
            card.innerHTML = `<div class="card-icon">${art.icon}</div><div class="card-title">${art.name}</div><div class="card-desc">${art.desc}</div><div class="card-type">LV.${lvl}</div>`;
        } else {
            card.innerHTML = `<div class="card-icon">‚ùì</div><div class="card-title">???</div><div class="card-desc">Ïû†ÍπÄ</div><div class="card-type">LOCKED</div>`;
        }
        container.appendChild(card);
    });
}

function openShop() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('shop-screen').classList.remove('hidden'); renderShop(); }
function closeShop() { document.getElementById('shop-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderShop() {
    document.getElementById('shop-currency').innerText = saveData.coins; const container = document.getElementById('shop-container'); container.innerHTML = '';
    const items = [
        { id: 'damage', name: 'Í∏∞Ï¥à Í≥µÍ≤©Ìïô', desc: 'Í≥µÍ≤©Î†• +10%' }, { id: 'health', name: 'Ï≤¥Î†• Îã®Î†®', desc: 'ÏµúÎåÄ Ï≤¥Î†• +10' }, { id: 'speed', name: 'Í∏∞ÎèôÏÑ± ÌõàÎ†®', desc: 'Ïù¥ÎèôÏÜçÎèÑ +5%' }, { id: 'greed', name: 'ÌÉêÏöïÏùò ÏãúÏÑ†', desc: 'Í≥®Îìú ÌöçÎìùÎüâ +10%' },
        { id: 'cooldown', name: 'Îπ†Î•∏ Ïû•Ï†Ñ', desc: 'Ïø®ÌÉÄÏûÑ -5%' }, { id: 'crit', name: 'ÏπòÎ™ÖÌÉÄ Ïó∞Îßà', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%' }, { id: 'luck', name: 'ÌñâÏö¥', desc: 'Ï¢ãÏùÄ ÏïÑÏù¥ÌÖú ÌôïÎ•† Ï¶ùÍ∞Ä' }, { id: 'evasion', name: 'ÌöåÌîºÏà†', desc: 'ÌöåÌîºÏú® +5%' },
        { id: 'xp', name: 'ÌïôÏäµ Îä•Î†•', desc: 'Í≤ΩÌóòÏπò ÌöçÎìù +10%' }, { id: 'duration', name: 'ÏßÄÏÜçÏÑ±', desc: 'Ìö®Í≥º ÏßÄÏÜçÏãúÍ∞Ñ +10%' }, { id: 'regen', name: 'ÏûêÏó∞ ÏπòÏú†', desc: '3Ï¥àÎßàÎã§ Ï≤¥Î†• 1 ÌöåÎ≥µ' }, { id: 'revive', name: 'Î∂àÍµ¥Ïùò ÏùòÏßÄ', desc: 'ÏÇ¨Îßù Ïãú 1Ìöå Î∂ÄÌôú' },
        { id: 'armor', name: 'Ìã∞ÌÉÄÎäÑ ÏΩîÌåÖ', desc: 'ÌîºÌï¥ Í∞êÏÜå +1' }, { id: 'knockback', name: 'Ï∂©Í≤© Ï¶ùÌè≠Í∏∞', desc: 'ÎÑâÎ∞± +20%' }
    ];
    items.forEach(item => { 
        const lvl = saveData.upgrades[item.id] || 0; 
        const cost = SHOP_BASE_COST * (lvl + 1) * (item.id === 'revive' ? 10 : 1); 
        const div = document.createElement('div'); div.className = 'shop-item'; 
        div.innerHTML = `<h3>${item.name} (Lv.${lvl})</h3><p>${item.desc}</p><button class="btn" style="font-size:0.85rem;" onclick="buyUpgrade('${item.id}', ${cost})">${cost} ü™ô</button>`; 
        container.appendChild(div); 
    });
}
function buyUpgrade(id, cost) { 
    if (saveData.coins >= cost) { 
        saveData.coins -= cost; 
        saveData.upgrades[id] = (saveData.upgrades[id] || 0) + 1; 
        save(); renderShop(); 
    } else alert('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'); 
}

function openGacha() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('gacha-screen').classList.remove('hidden'); document.getElementById('gacha-currency').innerText = saveData.coins; document.getElementById('gacha-result').style.display = 'none'; document.getElementById('gacha-buttons').style.display = 'flex'; }
function closeGacha() { document.getElementById('gacha-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function rollGacha() { if(saveData.coins < GACHA_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; } saveData.coins -= GACHA_COST; document.getElementById('gacha-currency').innerText = saveData.coins; const art = ARTIFACTS[Math.floor(Math.random() * ARTIFACTS.length)]; if (!saveData.artifacts[art.id]) saveData.artifacts[art.id] = 0; saveData.artifacts[art.id]++; save(); showGachaResult(art.icon, art.name, `${art.desc}\n(ÌòÑÏû¨ Lv.${saveData.artifacts[art.id]})`); }
function rollSkinGacha() { if(saveData.coins < SKIN_COST) { alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; } saveData.coins -= SKIN_COST; document.getElementById('gacha-currency').innerText = saveData.coins; const skin = SKINS[Math.floor(Math.random() * SKINS.length)]; if (saveData.ownedSkins.includes(skin.id)) { const refund = Math.floor(SKIN_COST * 0.5); saveData.coins += refund; showGachaResult(skin.icon, skin.name, `Ïù¥ÎØ∏ Î≥¥Ïú†Ï§ëÏûÖÎãàÎã§!\n${refund}ü™ô ÌôòÍ∏âÎê®.`); } else { saveData.ownedSkins.push(skin.id); showGachaResult(skin.icon, skin.name, "ÏÉàÎ°úÏö¥ Ïä§ÌÇ® ÌöçÎìù!"); } save(); }
function showGachaResult(icon, name, desc) { document.getElementById('gacha-buttons').style.display = 'none'; const res = document.getElementById('gacha-result'); res.style.display = 'flex'; document.getElementById('g-icon').innerText = icon; document.getElementById('g-name').innerText = name; document.getElementById('g-desc').innerText = desc; }
function closeGachaResult() { document.getElementById('gacha-result').style.display = 'none'; document.getElementById('gacha-buttons').style.display = 'flex'; }
function openSettings() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('settings-screen').classList.remove('hidden'); }
function closeSettings() { document.getElementById('settings-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function openClassScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('class-screen').classList.remove('hidden'); renderClasses(); }
function closeClassScreen() { document.getElementById('class-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderClasses() {
    document.getElementById('class-currency').innerText = saveData.coins; const container = document.getElementById('class-container'); container.innerHTML = '';
    CLASSES.forEach(cls => {
        const owned = saveData.ownedClasses.includes(cls.id); const selected = saveData.currentClass === cls.id;
        const div = document.createElement('div'); div.className = 'shop-item' + (selected ? ' selected' : '');
        let btnHtml = selected ? `<button class="btn btn-secondary" disabled>Ïû•Ï∞© Ï§ë</button>` : owned ? `<button class="btn" onclick="selectClass('${cls.id}')">ÏÑ†ÌÉù</button>` : `<button class="btn btn-accent" onclick="buyClass('${cls.id}', ${cls.cost})">${cls.cost} ü™ô</button>`;
        div.innerHTML = `<h3 style="font-size:1.5rem">${cls.icon}</h3><h3>${cls.name}</h3><p>${cls.desc}</p><div style="margin-bottom:10px; display:flex; gap:5px; flex-wrap:wrap; justify-content:center;">${cls.stats.hp!==0?`<span class="class-badge">HP ${cls.stats.hp>0?'+':''}${cls.stats.hp}</span>`:''}${cls.stats.dmg!==0?`<span class="class-badge">DMG ${cls.stats.dmg*100}%</span>`:''}${cls.stats.spd!==0?`<span class="class-badge">SPD ${cls.stats.spd}</span>`:''}${cls.stats.cd!==0?`<span class="class-badge">CDR ${cls.stats.cd*100}%</span>`:''}</div><div class="selected-check">‚úÖ</div>${btnHtml}`;
        container.appendChild(div);
    });
}
function selectClass(id) { saveData.currentClass = id; save(); renderClasses(); }
function buyClass(id, cost) { if(saveData.coins >= cost) { saveData.coins -= cost; saveData.ownedClasses.push(id); saveData.currentClass = id; save(); renderClasses(); } else alert("ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!"); }

// Ultimate Skill Selection
function openSkillScreen() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('skill-screen').classList.remove('hidden'); renderSkills(); }
function closeSkillScreen() { document.getElementById('skill-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }
function renderSkills() {
    const container = document.getElementById('skill-container'); container.innerHTML = '';
    if(!saveData.ownedUlts) saveData.ownedUlts = ['nuclear'];
    if(!saveData.currentUlt) saveData.currentUlt = 'nuclear';
    
    ULTIMATES.forEach(ult => {
        const owned = saveData.ownedUlts.includes(ult.id);
        const selected = saveData.currentUlt === ult.id;
        const div = document.createElement('div'); 
        div.className = 'ult-card' + (selected ? ' selected' : '');
        div.onclick = () => { saveData.currentUlt = ult.id; save(); renderSkills(); };
        
        div.innerHTML = `
            <div class="ult-icon-l">${ult.icon}</div>
            <div style="flex:1">
                <div style="font-weight:bold; font-size:1.1rem; color:${ult.color}">${ult.name}</div>
                <div style="font-size:0.8rem; color:#aaa;">${ult.desc}</div>
            </div>
            ${selected ? '<div style="color:#0f0; font-weight:bold;">EQUIPPED</div>' : ''}
        `;
        container.appendChild(div);
    });
}


// Input Handling
const joyZone = document.getElementById('joystick-zone'), joyBase = document.getElementById('joystick-base'), joyKnob = document.getElementById('joystick-knob');
joyZone.addEventListener('pointerdown', e => {
    e.preventDefault(); state.pointer.down = true; state.pointer.id = e.pointerId; state.pointer.x = e.clientX; state.pointer.y = e.clientY;
    state.joystick.active = true; state.joystick.originX = e.clientX; state.joystick.originY = e.clientY;
    joyBase.style.display = 'block'; joyKnob.style.display = 'block';
    joyBase.style.left = e.clientX + 'px'; joyBase.style.top = e.clientY + 'px'; joyKnob.style.left = e.clientX + 'px'; joyKnob.style.top = e.clientY + 'px';
    const now = Date.now(); if (now - state.lastTap < 300) { if (state.player) state.player.dash(); } state.lastTap = now;
});
window.addEventListener('pointermove', e => {
    if (!state.pointer.down || e.pointerId !== state.pointer.id) return; e.preventDefault();
    const maxDist = 60, dx = e.clientX - state.joystick.originX, dy = e.clientY - state.joystick.originY, dist = Math.sqrt(dx*dx + dy*dy);
    let kx = dx, ky = dy; if (dist > maxDist) { kx = (dx / dist) * maxDist; ky = (dy / dist) * maxDist; }
    joyKnob.style.left = (state.joystick.originX + kx) + 'px'; joyKnob.style.top = (state.joystick.originY + ky) + 'px';
    state.joystick.dx = kx / maxDist; state.joystick.dy = ky / maxDist;
});
window.addEventListener('pointerup', e => { if (e.pointerId !== state.pointer.id) return; e.preventDefault(); state.pointer.down = false; state.joystick.active = false; state.joystick.dx = 0; state.joystick.dy = 0; joyBase.style.display = 'none'; joyKnob.style.display = 'none'; });
window.addEventListener('keydown', e => { 
    if(e.code === 'Space') state.player?.dash(); 
    if(e.key.toLowerCase() === 'w') state.keys.w = true; if(e.key.toLowerCase() === 'a') state.keys.a = true; if(e.key.toLowerCase() === 's') state.keys.s = true; if(e.key.toLowerCase() === 'd') state.keys.d = true; 
    if(e.key === 'ArrowUp') state.keys.ArrowUp = true; if(e.key === 'ArrowLeft') state.keys.ArrowLeft = true; if(e.key === 'ArrowDown') state.keys.ArrowDown = true; if(e.key === 'ArrowRight') state.keys.ArrowRight = true;
    // Prevent scroll
    if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { 
    if(e.key.toLowerCase() === 'w') state.keys.w = false; if(e.key.toLowerCase() === 'a') state.keys.a = false; if(e.key.toLowerCase() === 's') state.keys.s = false; if(e.key.toLowerCase() === 'd') state.keys.d = false; 
    if(e.key === 'ArrowUp') state.keys.ArrowUp = false; if(e.key === 'ArrowLeft') state.keys.ArrowLeft = false; if(e.key === 'ArrowDown') state.keys.ArrowDown = false; if(e.key === 'ArrowRight') state.keys.ArrowRight = false;
});
</script>
</body>
</html>
